# 一、打印机任务和打印机队列

打印任务是根据saas可选择的

打印机：打印机，打印队列，打印任务。

打印机类型有：U口打印机、串口打印机、网口打印机、驱动打印机

一次打印三份：顾客桌一张、划菜口一张、后厨多张

可有多个主打印机和多个备用打印，主打印机负载均衡打印，当所有主打印机故障启动备用打印机并负载均衡

一个计算机可以绑定多台打印机（Fanout）







# 二、JetCache缓存框架

## 1、源码

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202501181805730.png" alt="image-20250118180556662" style="zoom:50%;" />

```yaml
jetcache:
  statIntervalMinutes: 15
  areaInCacheName: false
  hidePackages: com.alibaba
  local:
    default:
      type: caffeine
      limit: 100
      keyConvertor: fastjson2 #其他可选：fastjson/jackson
      expireAfterWriteInMillis: 100000
    otherArea:
      type: linkedhashmap
      limit: 100
      keyConvertor: none
      expireAfterWriteInMillis: 100000
  remote:
    default:
      type: redisson
      keyConvertor: fastjson2 #其他可选：fastjson/jackson
      # broadcastChannel: projectA
      valueEncoder: java #其他可选：kryo/kryo5
      valueDecoder: java #其他可选：kryo/kryo5
```



本地缓存（Local Cache）：**Caffeine**、**LinkedHashMap**

远程缓存（Remote Cache）：**Redisson**、**Redis**



### LinkedHashMap

![image-20250118210912044](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202501182109130.png)

![image-20250118210958524](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202501182109588.png)

**利用LinkedHashMap实现LRU算法缓存**

```java
public class LRUCache extends LinkedHashMap
{
    public LRUCache(int maxSize)
    {
        super(maxSize, 0.75F, true);
        maxElements = maxSize;
    }

    protected boolean removeEldestEntry(java.util.Map.Entry eldest)
    {
        return size() > maxElements;
    }

    private static final long serialVersionUID = 1L;
    protected int maxElements;
}
```

顾名思义，LRUCache就是基于LRU算法的Cache（缓存），这个类继承自LinkedHashMap，而类中看到没有什么特别的方法，这说明LRUCache实现缓存LRU功能都是源自LinkedHashMap的。LinkedHashMap可以实现LRU算法的缓存基于两点：

**1、LinkedList首先它是一个Map，Map是基于K-V的，和缓存一致**

**2、LinkedList提供了一个boolean值可以让用户指定是否实现LRU**

那么，首先我们了解一下什么是LRU：**LRU即Least Recently Used，最近最少使用，也就是说，当缓存满了，会优先淘汰那些最近最不常访问的数据**。比方说数据a，1天前访问了；数据b，2天前访问了，缓存满了，优先会淘汰数据b。

我们看一下LinkedList带boolean型参数的构造方法：

```java
public LinkedHashMap(int initialCapacity,
         float loadFactor,
                     boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
```

就是这个accessOrder，它表示：

**（1）false，所有的Entry按照插入的顺序排列**

**（2）true，所有的Entry按照访问的顺序排列**

第二点的意思就是，如果有1 2 3这3个Entry，那么访问了1，就把1移到尾部去，即2 3 1。每次访问都把访问的那个数据移到双向队列的尾部去，那么每次要淘汰数据的时候，双向队列最头的那个数据不就是最不常访问的那个数据了吗？换句话说，双向链表最头的那个数据就是要淘汰的数据。

"访问"，这个词有两层意思：

**1、根据Key拿到Value，也就是get方法**

**2、修改Key对应的Value，也就是put方法**

recordAccess，顾名思义，记录访问，也就是说你这次访问了双向链表，我就把你记录下来，怎么记录？**把你访问的Entry移到尾部去**。这个方法在HashMap中是一个空方法，就是用来给子类记录访问用的，看一下LinkedHashMap中的实现：

看到每次recordAccess的时候做了两件事情：

**1、把待移动的Entry的前后Entry相连**

**2、把待移动的Entry移动到尾部**





## 2、缓存框架：

用模板方法进行缓存，简便缓存的更新，

简便了切换本地和远程缓存，自动同步本地和远程缓存。

**支持多级缓存**：支持本地缓存（如 Caffeine）+ 远程缓存（如 Redis），既能提高性能，又能保证数据一致性。

**过期策略**：支持自动过期、刷新、预加载等策略，避免缓存击穿、雪崩等问题。















# 三、JDK21 虚拟线程



























# 四、看门狗

- 开发看门狗模块

  ：

  - **功能实现**：负责开发看门狗模块，用于监控 app-server 是否在运行，若发现其未运行，则自动拉起该服务，确保系统的高可用性和稳定性。

  - 核心逻辑

    ：

    - 定时任务调度：使用 Spring 的 `@Scheduled` 注解实现每 5 秒对 app-server 进行一次健康检查。
    - 健康检查机制：通过向 `http://127.0.0.1:9180/api/health-check` 发送 HTTP GET 请求，根据响应状态码判断 app-server 是否正常运行。若请求失败或响应码不为 200，则判定为不健康。
    - 故障处理逻辑：当检测到 app-server 持续 45 秒未正常运行时，记录错误日志并尝试启动 app-server。启动命令通过获取软件安装目录，拼接 `app-server\server.exe` 路径，使用 `ProcessBuilder` 启动进程。

  - 技术亮点

    ：

    - 利用静态方法 `getAppDir()` 获取软件安装目录，通过对当前工作目录进行处理，确保启动命令路径的正确性。
    - 合理运用日志记录，在关键节点如心跳检测失败、启动程序时出错等情况，使用日志输出详细信息，方便后续问题排查。













# 五、计时计价模块

## 1、需求分析

计时计价的入口是时间段（上钟落钟等），通过计时计价来算出订单金额，出口接口是供给订单模块调取订单金额。

计时计价通过计价类型（按小时、包场、包钟）和桌台类型（散台、包厢、外卖、酒席）

拆分成两部分，一个是计时计价属性表，一个是计时计价时间段表。







## 五、预约时段在营业时段范围和重叠校验（区间树）

请帮我写一个使用设计模式来解决判断多个小时间段是否在另一个大时间段，并且多个小时间段之间要不能时间段重叠的java工具，并且可以方便调用



###### ChatGPT 说：

这个问题涉及时间范围的判断和验证，可以使用 **组合模式（Composite Pattern）** 来表示时间段的层级结构，同时结合 **策略模式（Strategy Pattern）** 来处理不同的时间判断规则。
我们可以设计一个 `TimeRangeValidator` 工具类来检查多个小时间段是否在一个大时间段内，并且确保它们之间没有重叠。

------

### **解决方案：**

1. **使用 `TimePeriod` 表示时间段**
   - 提供基本的时间范围逻辑，如判断一个时间段是否在另一个时间段内。
2. **使用 `TimePeriodComposite` 组合多个 `TimePeriod`**
   - 负责管理多个时间段，并提供检测功能。
3. **使用 `ValidationStrategy` 进行规则验证**
   - 确保所有子时间段都在父时间段内，并且不相互重叠。

------

### **代码实现**

```java
java复制编辑import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

// 时间段类
class TimePeriod {
    private LocalTime start;
    private LocalTime end;

    public TimePeriod(LocalTime start, LocalTime end) {
        if (start.isAfter(end)) {
            throw new IllegalArgumentException("开始时间不能晚于结束时间");
        }
        this.start = start;
        this.end = end;
    }

    public LocalTime getStart() {
        return start;
    }

    public LocalTime getEnd() {
        return end;
    }

    public boolean isWithin(TimePeriod other) {
        return !this.start.isBefore(other.getStart()) && !this.end.isAfter(other.getEnd());
    }

    @Override
    public String toString() {
        return "[" + start + " - " + end + "]";
    }
}

// 组合模式管理多个时间段
class TimePeriodComposite {
    private TimePeriod mainPeriod;
    private List<TimePeriod> subPeriods;

    public TimePeriodComposite(TimePeriod mainPeriod) {
        this.mainPeriod = mainPeriod;
        this.subPeriods = new ArrayList<>();
    }

    public void addSubPeriod(TimePeriod period) {
        subPeriods.add(period);
    }

    public List<TimePeriod> getSubPeriods() {
        return Collections.unmodifiableList(subPeriods);
    }

    public TimePeriod getMainPeriod() {
        return mainPeriod;
    }
}

// 策略模式：时间验证策略
interface ValidationStrategy {
    boolean validate(TimePeriodComposite composite);
}

// 策略实现：确保所有子时间段都在主时间段内
class WithinMainPeriodStrategy implements ValidationStrategy {
    @Override
    public boolean validate(TimePeriodComposite composite) {
        for (TimePeriod subPeriod : composite.getSubPeriods()) {
            if (!subPeriod.isWithin(composite.getMainPeriod())) {
                return false;
            }
        }
        return true;
    }
}

// 策略实现：确保子时间段之间没有重叠
class NoOverlapStrategy implements ValidationStrategy {
    @Override
    public boolean validate(TimePeriodComposite composite) {
        List<TimePeriod> periods = new ArrayList<>(composite.getSubPeriods());
        periods.sort(Comparator.comparing(TimePeriod::getStart));

        for (int i = 1; i < periods.size(); i++) {
            if (!periods.get(i).getStart().isAfter(periods.get(i - 1).getEnd())) {
                return false;
            }
        }
        return true;
    }
}

// 时间验证工具
class TimeRangeValidator {
    private List<ValidationStrategy> strategies = new ArrayList<>();

    public TimeRangeValidator() {
        // 默认添加两个策略
        strategies.add(new WithinMainPeriodStrategy());
        strategies.add(new NoOverlapStrategy());
    }

    public void addStrategy(ValidationStrategy strategy) {
        strategies.add(strategy);
    }

    public boolean validate(TimePeriodComposite composite) {
        for (ValidationStrategy strategy : strategies) {
            if (!strategy.validate(composite)) {
                return false;
            }
        }
        return true;
    }
}

// 示例调用
public class Main {
    public static void main(String[] args) {
        // 定义一个主时间段
        TimePeriod mainPeriod = new TimePeriod(LocalTime.of(9, 0), LocalTime.of(18, 0));
        TimePeriodComposite composite = new TimePeriodComposite(mainPeriod);

        // 添加子时间段
        composite.addSubPeriod(new TimePeriod(LocalTime.of(10, 0), LocalTime.of(11, 0)));
        composite.addSubPeriod(new TimePeriod(LocalTime.of(12, 0), LocalTime.of(13, 0)));
        composite.addSubPeriod(new TimePeriod(LocalTime.of(14, 0), LocalTime.of(15, 0)));

        // 初始化验证器
        TimeRangeValidator validator = new TimeRangeValidator();

        // 进行验证
        boolean isValid = validator.validate(composite);
        System.out.println("时间段是否符合规则: " + isValid);
    }
}
```

------

### **设计模式使用**

1. **组合模式（Composite Pattern）**
   - `TimePeriodComposite` 作为父级时间段，管理多个 `TimePeriod`。
2. **策略模式（Strategy Pattern）**
   - `ValidationStrategy` 定义验证规则，如 **子时间段必须在主时间段内** 和 **子时间段之间不能重叠**。

------

### **代码优势**

- **可扩展**：可以添加新的验证策略，比如检查是否存在最小间隔。
- **解耦**：时间段表示与验证逻辑分离，提高代码可读性和维护性。
- **易用性**：可以方便地通过 `TimeRangeValidator` 进行调用。

这样，你可以直接使用 `TimeRangeValidator` 来验证任何时间段组合是否符合规则。

















# 六、京东外卖

![image-20250218154302109](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202502181543227.png)

1、顾客在京东的app点外卖
2、京东的app把订单信息发送给京东服务器
3、京东服务器把订单信息推送给我们云端服务器
4、我们云端服务器把订单推送给门店服务器
5、门店服务器接到订单后，给打印机发指令，在厨房打印出来







# 七、灯控器

灯控器有ip和端口，端口对应相应的房台，可以开灯关灯



1、解析出设备管理里的附加信息，变成VO返回前端，VO有ip、port、tableToPort

```json
{
  "ip": "192.168.1.10",
  "portNum": 8,
  "portToTblMap": {
    "1": 201,
    "2": 202,
    "3": 203,
    "4": 204,
    "5": 205,
    "6": 206,
    "7": 207,
    "8": 208
  }
}
```

2、控制对应房台的灯开关，通过灯控器



老版本代码：

```java
package com.lemontree.framework.lightcontorl;

import com.lemontree.framework.beans.Prn_LightControl;
import com.lemontree.framework.beans.Prn_WorkStation;
import com.lemontree.framework.comUtil.QJCSInMemManager;
import com.lemontree.framework.comUtil.QJCSManager;
import com.lemontree.framework.comUtil.SpringContextAdapter;
import com.lemontree.framework.comUtil.StackTraceToString;
import com.sun.jna.Library;
import com.sun.jna.Native;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;

public class LightControl implements InitializingBean, Runnable {

  @Override
  public void run() {
    initLightStatuts(); // 软件启动时候初始化灯状态
    while (QJCSInMemManager.getInstance().sysIsRunning()) {
      SpringContextAdapter.sleepEx(10);
      try {
        proTask();
      } catch (Exception e) {
        logger.error(StackTraceToString.getExceptionTrace(e));
      }
    }
  }

  @Override
  public void afterPropertiesSet() throws Exception {
    int count =
        (int)
            SpringContextAdapter.getInstance()
                .executeSqlRetObj("select COUNT(1) from Prn_LightControl");
    if (count == 0) {
      return;
    }

    if (isServerMode()) {
      new Thread(this).start();
    }
  }

  public static void proTask() {
    Prn_WorkStation ws = SpringContextAdapter.getInstance().getQjcsManager().getWorkstation();
    StringBuilder sql = new StringBuilder();
    sql.append("SELECT Port, BridRate, LightNo, OnOff, PID\n");
    sql.append("FROM LightControlTask_WS\n");
    sql.append(String.format("WHERE WS_ID = '%s'\n", ws.getID()));
    sql.append("ORDER BY PID DESC\n");
    List<Object[]> lights = SpringContextAdapter.getInstance().executeSqlRetList(sql.toString());
    List<String> proControlLight = new ArrayList<String>();
    List<Integer> pids = new ArrayList<Integer>();
    for (Object[] light : lights) {
      Integer comPort = (Integer) light[0];
      Integer commBaud = (Integer) light[1];
      Integer lightNo = (Integer) light[2];
      byte offNo = (Byte) light[3];
      Integer pid = (Integer) light[4];
      if (proControlLight.contains(String.format("%s_%s", comPort, lightNo))) {
        // 同一个灯控箱下的同一个灯，之前已经控制过
        pids.add(pid);
        continue;
      }
      proControlLight.add(String.format("%s_%s", comPort, lightNo));
      boolean isSucc = false;
      if (offNo == 1) {
        isSucc = openLight(comPort, commBaud, lightNo);
      } else {
        isSucc = closeLight(comPort, commBaud, lightNo);
      }
      if (isSucc) {
        pids.add(pid);
      }
    }
    if (!pids.isEmpty()) {
      // 删除处理过的任务
      sql = new StringBuilder();
      sql.append("DELETE FROM LightControlTask_WS\n");
      sql.append(
          String.format("WHERE PID IN (%s)\n", Arrays.toString(pids.toArray()))
              .replace("[", "")
              .replace("]", ""));
      SpringContextAdapter.getInstance().executeUpdateSql(sql.toString());
    }
  }

  public static boolean isServerMode() {
    SpringContextAdapter spring = SpringContextAdapter.getInstance();
    Prn_WorkStation station = spring.getQjcsManager().getWorkstation();
    if (station == null) {
      logger.error("this workstation has not been config,please config it first");
      return false;
    }

    String whereSql = String.format("WHERE WorkStation = %d", station.getPID());
    Prn_LightControl lightControl =
        (Prn_LightControl) spring.loadBean("Prn_LightControl", whereSql);

    if (lightControl == null) {
      return false;
    }

    return SpringContextAdapter.g_appType == SpringContextAdapter.AppType.SERVER;
  }

  public static boolean isUseLightControl() {
    return QJCSInMemManager.getInstance().getBoolValue(QJCSManager.g_UseLightControl, false);
  }

  public static Boolean openLight(String billID) {
    return controlLight(billID, true);
  }

  public static Boolean closeLight(String billID) {
    return controlLight(billID, false);
  }

  public static Boolean controlLight(String billID, boolean offNo) {
    if (!isUseLightControl()) {
      return null;
    }
    Object[] light = getLight(billID);
    if (light == null) {
      return null;
    }
    String wsID = (String) light[0];
    int comPort = Integer.parseInt(((String) light[1]).replaceFirst("COM", ""));
    int commBaud = (Integer) light[2];
    int lightNo = (Integer) light[3];

    // 当前站点无灯控器，发布通知相应站点
    String sql =
        "INSERT INTO LightControlTask_WS(WS_ID, Port, BridRate, LightNo, OnOff) \n"
            + String.format(
                "VALUES('%s', %d, %d, %d, %d)\n", wsID, comPort, commBaud, lightNo, offNo ? 1 : 0);
    SpringContextAdapter.getInstance().executeUpdateSql(sql);
    return true;
  }

  private static Object[] getLight(String billID) {
    String sql =
        "SELECT W.ID\n"
            + "     , light.Port\n"
            + "     , light.BridRate\n"
            + "     , zt.lightNo\n"
            + "FROM XiaoFeiDan xfd\n"
            + "INNER JOIN ZuoTai zt ON zt.ZuoTaiID = xfd.TaiHao\n"
            + "INNER JOIN Prn_LightControl light ON light.PID = zt.LightControl\n"
            + "INNER JOIN Prn_WorkStation W ON W.PID = light.WorkStation\n"
            + String.format("WHERE xfd.XiaoFeiDanID = '%s' \n", billID);
    return (Object[]) SpringContextAdapter.getInstance().executeSqlRetObj(sql);
  }

  public static boolean openLight(int comPort, int commBaud, int lightNo) {
    LightControlLibrary.INSTANCE.SetCommBaud(commBaud);
    int ret =
        LightControlLibrary.INSTANCE.Write_StartAddress(comPort, 1, getStartAddress(lightNo, true));
    return ret == 0;
  }

  public static boolean closeLight(int comPort, int commBaud, int lightNo) {
    LightControlLibrary.INSTANCE.SetCommBaud(commBaud);
    int ret =
        LightControlLibrary.INSTANCE.Write_StartAddress(
            comPort, 1, getStartAddress(lightNo, false));
    return ret == 0;
  }

  private static int getStartAddress(int lightNo, boolean onOff) {
    int control = 0xFF00; // 0xFF00 全部打开，
    if (onOff) {
      control = 0x00;
    }
    int addr;
    int row = lightNo / 8;
    int rowIndex = lightNo % 8;
    if (lightNo <= 8) { // 第一组J1~J8
      rowIndex = lightNo - 1;
      // System.err.println(lightNo +" 第一组J1~J8:"+rowIndex);
      int j = lightRow[rowIndex];
      if (onOff) {
        TQDZT1 = TQDZT1 | j;
      } else {
        TQDZT1 = TQDZT1 & (~j);
      }
      addr = TQDZT1 | 2;
      // return control ^ lightRow[rowIndex] | 2;
    } else if (lightNo <= 16) { // 第二组J9~J16
      rowIndex = (lightNo - 1) % 8;
      // System.err.println(lightNo +" 第二组J9~J16:"+rowIndex);
      // return control ^ lightRow[rowIndex] | 1;
      int j = lightRow[rowIndex];
      if (onOff) {
        TQDZT2 = TQDZT2 | j;
      } else {
        TQDZT2 = TQDZT2 & (~j);
      }
      addr = TQDZT2 | 1;
    } else { // 第三组J17~J24
      rowIndex = (lightNo - 1) % 16;

      int j = lightRow[rowIndex];
      if (onOff) {
        TQDZT3 = TQDZT3 | j;
      } else {
        TQDZT3 = TQDZT3 & (~j);
      }
      addr = TQDZT3;
    }
    return addr;
  }

  /** 软件启动时候初始化灯状态 */
  private static LinkedHashMap<Integer, Integer> initLightStatuts(
      LinkedHashMap<Integer, Boolean> lightStatuts) {
    LinkedHashMap<Integer, Integer> lightNoAddr = new LinkedHashMap<Integer, Integer>();
    for (Integer lightNo : lightStatuts.keySet()) {
      boolean onOff = lightStatuts.get(lightNo);
      int addr;
      int row = lightNo / 8;
      int rowIndex = lightNo % 8;
      if (lightNo <= 8) { // 第一组J1~J8
        rowIndex = lightNo - 1;
        // System.err.println(lightNo +" 第一组J1~J8:"+rowIndex);
        int j = lightRow[rowIndex];
        if (onOff) {
          TQDZT1 = TQDZT1 | j;
        } else {
          TQDZT1 = TQDZT1 & (~j);
        }
        addr = TQDZT1 | 2;
        // return control ^ lightRow[rowIndex] | 2;
      } else if (lightNo <= 16) { // 第二组J9~J16
        rowIndex = (lightNo - 1) % 8;
        // System.err.println(lightNo +" 第二组J9~J16:"+rowIndex);
        // return control ^ lightRow[rowIndex] | 1;
        int j = lightRow[rowIndex];
        if (onOff) {
          TQDZT2 = TQDZT2 | j;
        } else {
          TQDZT2 = TQDZT2 & (~j);
        }
        addr = TQDZT2 | 1;
      } else { // 第三组J17~J24
        rowIndex = (lightNo - 1) % 16;
        // System.err.println(lightNo +" 第三组J17~J24:"+rowIndex);
        // return control ^ lightRow[rowIndex];
        int j = lightRow[rowIndex];
        if (onOff) {
          TQDZT3 = TQDZT3 | j;
        } else {
          TQDZT3 = TQDZT3 & (~j);
        }
        addr = TQDZT3;
      }
      lightNoAddr.put(lightNo, addr);
    }
    return lightNoAddr;
  }

  /** 软件启动时候初始化灯状态 */
  public static void initLightStatuts(
      int comPort, int commBaud, LinkedHashMap<Integer, Boolean> lightStatuts) {
    LinkedHashMap<Integer, Integer> lightNoAddr = initLightStatuts(lightStatuts);
    for (Integer addr : lightNoAddr.values()) {
      LightControlLibrary.INSTANCE.SetCommBaud(commBaud);
      LightControlLibrary.INSTANCE.Write_StartAddress(comPort, 1, addr);
    }
  }

  /** 软件启动时候初始化灯状态 */
  public static void initLightStatuts() {
    SpringContextAdapter spring = SpringContextAdapter.getInstance();
    Prn_WorkStation station = spring.getQjcsManager().getWorkstation();
    String sql =
        "SELECT W.ID\n"
            + "     , light.Port\n"
            + "     , light.BridRate\n"
            + "     , zt.lightNo\n"
            + "     , JS.PID\n"
            + "FROM Prn_LightControl light\n"
            + "INNER JOIN Prn_WorkStation W ON W.PID = light.WorkStation\n"
            + "INNER JOIN ZuoTai zt ON zt.LightControl = light.PID\n"
            + "LEFT JOIN XiaoFeiDan xfd ON zt.ZuoTaiID = xfd.TaiHao\n"
            + "LEFT JOIN RC_JiShijiJiaRecode JS ON JS.BillId = xfd.XiaoFeiDanID AND JS.EndTime IS NULL\n"
            + // 正在上钟的桌台
            String.format("WHERE W.ID = '%s' \n", station.getID())
            + "ORDER BY light.Port ASC\n";
    List<Object[]> using = (List<Object[]>) spring.executeSqlRetList(sql);
    if (using.isEmpty()) {
      return;
    }
    LinkedHashMap<String, LinkedHashMap<Integer, Boolean>> light =
        new LinkedHashMap<String, LinkedHashMap<Integer, Boolean>>();
    for (Object[] v : using) {
      String comPort = (String) v[1];
      Integer bridRate = (Integer) v[2];
      Integer lightNoTrue = (Integer) v[3];
      Integer jsPID = (Integer) v[4];
      String key = String.format("%s_%s", comPort, bridRate);
      LinkedHashMap<Integer, Boolean> lightStatuts = light.get(key);
      if (lightStatuts == null) {
        lightStatuts = new LinkedHashMap<>();
        for (int lightNo = 1; lightNo < 25; lightNo++) {
          lightStatuts.put(lightNo, false);
        }
        light.put(key, lightStatuts);
      }
      if (jsPID != null) {
        lightStatuts.put(lightNoTrue, true);
      }
    }
    for (String key : light.keySet()) {
      String[] portBand = key.split("_");
      int comPort = Integer.parseInt(portBand[0].replaceFirst("COM", ""));
      int commBaud = Integer.parseInt(portBand[1]);
      LinkedHashMap<Integer, Boolean> lightStatuts = light.get(key);
      initLightStatuts(comPort, commBaud, lightStatuts);
    }
  }

  private static int TQDZT1 = 0x0000;
  private static int TQDZT2 = 0x0000;
  private static int TQDZT3 = 0x0000;
  private static final int[] lightRow = {
    0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000
  };

  private static final Logger logger = LoggerFactory.getLogger(LightControl.class);

  public interface LightControlLibrary extends Library {
    LightControlLibrary INSTANCE =
        (LightControlLibrary) Native.loadLibrary("Sfdrv", LightControlLibrary.class);
    int TQDZT1 = 0;
    int TQDZT2 = 0;
    int TQDZT3 = 0;

    int SetCommBaud(int BaudPara);

    int TestComm(int ComPort, int NodeAddr);

    int Get_Status(int ComPort, int NodeAddr);

    int Write_StartAddress(int ComPort, int NodeAddr, int StartAddress);

    int Write_EndAddress(int ComPort, int NodeAddr, int StartAddress);
  }
}

```



