# 操作系统

### 操作系统主要有哪些功能？



[![ 三分恶面渣逆袭：操作系统主要功能](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091853891.png)](https://camo.githubusercontent.com/29fdd18db05f4a583133acdf0936fa234d8c5d5dd70737057a3104fa125aad88/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d65656538323935322d633936662d343563392d383335652d3239646233376330663664382e706e67)

①、负责**创建和终止进程**。进程是正在运行的程序实例，每个进程都有自己的地址空间和资源。

②、负责**为进程分配资源**，比如说**内存**，并在进程终止时回收内存。

③、提供**创建、删除、读写文件**的功能，并组织文件的存储结构，比如说目录。

④、通过**设备驱动**程序控制和管理计算机的硬件设备，如键盘、鼠标、打印机等。



## 操作系统结构

### 什么是内核？

可以这么说，**内核是一个计算机程序，它是操作系统的核心**，提供了操作系统最核心的能力，可以控制操作系统中所有的内容。



### 什么是用户态和内核态？

在计算机系统中，**内存**可以分为两大区域：**内核空间**（Kernel Space）和**用户空间**（User Space）。这种划分主要用于保护系统稳定性和安全性。

- 内核空间，是操作系统内核代码及其运行时数据结构所在的内存区域，**拥有对系统所有资源的完全访问权限**，如进程管理、内存管理、文件系统、网络堆栈等。
- ⽤户空间，是操作系统为**应用程序**（如用户运行的进程）分配的内存区域，**用户空间中的进程不能直接访问硬件或内核数据结构，只能通过系统调用与内核通信。**

[![二哥的 Java 进阶之路：用户空间和内核空间](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091855734.png)](https://camo.githubusercontent.com/42d3db982c4f306ea0e043eb6b5814cf2e46051c96efd2438fd88bbf6692d751/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6f732d32303234303732343137303435312e706e67)

当程序使用用户空间时，我们常说该程序在 **用户态** 执行，而当程序使内核空间时，程序则在 **内核态** 执⾏。



### 用户态和内核态是如何切换的？

当**应用程序执行系统调用**时，CPU 将从用户态切换到内核态，进入内核空间执行相应的内核代码，然后再切换回用户态。

[![三分恶面渣逆袭：用户态&内核态切换](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091856144.png)](https://camo.githubusercontent.com/640bbad7d41371aa05d592db4c6ebcbe464806734b98f0e8a7467d453e6227fe/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d62333538636461652d313862362d343564342d386135622d3465613361376366633237332e706e67)

系统调用是**应用程序请求操作系统内核提供服务的接口**，如**文件操作**（如 open、read、write）、**进程控制**（如 fork、exec）、**内存管理**（如 mmap）等。







## 进程和线程

### 并行和并发有什么区别？

**并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行**。单核处理器做到的并发，其实是利用**时间片的轮转**，例如有两个进程 A 和 B，A 运行一个时间片之后，切换到 B，B 运行一个时间片之后又切换到 A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。

**并行就是在同一时刻，有多个任务在执行。**这个需要**多核处理器**才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。

[![并发和并行](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091859758.png)](https://camo.githubusercontent.com/568a819e1654bda5b349592235f8026c83379963017a96ecfaec9bd8d1f0cf81/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d66623738393164382d383333302d343934622d396263312d6366383239623563633832642e706e67)





### 什么是进程上下文切换？

[![三分恶面渣逆袭：进程上下文切换](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091905717.png)](https://camo.githubusercontent.com/ecef2b80b683f10620b74a91ed593471e27274f463a70584e38143ed3ccab78c/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d31383764316366392d393731642d343339352d623838382d3565366561663262653566312e706e67)

上下文切换是操作系统**在多任务处理环境中，将 CPU 从一个进程切换到另一个进程的过程**。**通过让多个进程共享 CPU 资源，使系统能够并发执行多个任务。**

进程上下文切换通畅包含以下几个步骤：

- 保存当前进程的上下文：操作系统保存当前进程的 CPU 寄存器，程序状态等关键信息。
- 选择下一个进程：调度程序选择下一个要执行的进程。
- 恢复上一个进程的上下文。
- 切换到下一个进程。





### 进程有哪些状态？

当一个进程开始运行时，它可能会经历下面这几种状态：

上图中各个状态的意义：

- 运⾏状态（*Runing*）：该时刻进程占⽤ CPU；
- 就绪状态（*Ready*）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；
- 阻塞状态（*Blocked*）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它 CPU 控制权，它也⽆法运⾏；

[![进程3种状态](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091907569.png)](https://camo.githubusercontent.com/71dff417bc1560212911baf95a58c6ed4adf7fa1896a4149933292dde503608d/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d35646633303633312d616437642d346336352d616632302d3530623762363135656361382e706e67)

当然，进程还有另外两个基本状态：

- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；

![进程5种状态](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091907906.png)





































































































































































































































































































































































































































































































































































































































































































