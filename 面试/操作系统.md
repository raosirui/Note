# 操作系统

### 操作系统主要有哪些功能？



[![ 三分恶面渣逆袭：操作系统主要功能](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091853891.png)](https://camo.githubusercontent.com/29fdd18db05f4a583133acdf0936fa234d8c5d5dd70737057a3104fa125aad88/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d65656538323935322d633936662d343563392d383335652d3239646233376330663664382e706e67)

①、负责**创建和终止进程**。进程是正在运行的程序实例，每个进程都有自己的地址空间和资源。

②、负责**为进程分配资源**，比如说**内存**，并在进程终止时回收内存。

③、提供**创建、删除、读写文件**的功能，并组织文件的存储结构，比如说目录。

④、通过**设备驱动**程序控制和管理计算机的硬件设备，如键盘、鼠标、打印机等。



## 操作系统结构

### 什么是内核？

可以这么说，**内核是一个计算机程序，它是操作系统的核心**，提供了操作系统最核心的能力，可以控制操作系统中所有的内容。



### 什么是用户态和内核态？

在计算机系统中，**内存**可以分为两大区域：**内核空间**（Kernel Space）和**用户空间**（User Space）。这种划分主要用于保护系统稳定性和安全性。

- 内核空间，是操作系统内核代码及其运行时数据结构所在的内存区域，**拥有对系统所有资源的完全访问权限**，如进程管理、内存管理、文件系统、网络堆栈等。
- ⽤户空间，是操作系统为**应用程序**（如用户运行的进程）分配的内存区域，**用户空间中的进程不能直接访问硬件或内核数据结构，只能通过系统调用与内核通信。**

[![二哥的 Java 进阶之路：用户空间和内核空间](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091855734.png)](https://camo.githubusercontent.com/42d3db982c4f306ea0e043eb6b5814cf2e46051c96efd2438fd88bbf6692d751/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6f732d32303234303732343137303435312e706e67)

当程序使用用户空间时，我们常说该程序在 **用户态** 执行，而当程序使内核空间时，程序则在 **内核态** 执⾏。



### 用户态和内核态是如何切换的？

当**应用程序执行系统调用**时，CPU 将从用户态切换到内核态，进入内核空间执行相应的内核代码，然后再切换回用户态。

[![三分恶面渣逆袭：用户态&内核态切换](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091856144.png)](https://camo.githubusercontent.com/640bbad7d41371aa05d592db4c6ebcbe464806734b98f0e8a7467d453e6227fe/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d62333538636461652d313862362d343564342d386135622d3465613361376366633237332e706e67)

系统调用是**应用程序请求操作系统内核提供服务的接口**，如**文件操作**（如 open、read、write）、**进程控制**（如 fork、exec）、**内存管理**（如 mmap）等。







## 进程和线程

### 并行和并发有什么区别？

**并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行**。单核处理器做到的并发，其实是利用**时间片的轮转**，例如有两个进程 A 和 B，A 运行一个时间片之后，切换到 B，B 运行一个时间片之后又切换到 A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。

**并行就是在同一时刻，有多个任务在执行。**这个需要**多核处理器**才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。

[![并发和并行](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091859758.png)](https://camo.githubusercontent.com/568a819e1654bda5b349592235f8026c83379963017a96ecfaec9bd8d1f0cf81/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d66623738393164382d383333302d343934622d396263312d6366383239623563633832642e706e67)





### 什么是进程上下文切换？

[![三分恶面渣逆袭：进程上下文切换](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091905717.png)](https://camo.githubusercontent.com/ecef2b80b683f10620b74a91ed593471e27274f463a70584e38143ed3ccab78c/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d31383764316366392d393731642d343339352d623838382d3565366561663262653566312e706e67)

上下文切换是操作系统**在多任务处理环境中，将 CPU 从一个进程切换到另一个进程的过程**。**通过让多个进程共享 CPU 资源，使系统能够并发执行多个任务。**

进程上下文切换通畅包含以下几个步骤：

- 保存当前进程的上下文：操作系统保存当前进程的 CPU 寄存器，程序状态等关键信息。
- 选择下一个进程：调度程序选择下一个要执行的进程。
- 恢复上一个进程的上下文。
- 切换到下一个进程。





### 进程有哪些状态？

当一个进程开始运行时，它可能会经历下面这几种状态：

上图中各个状态的意义：

- **运⾏状态**（*Runing*）：该时刻进程占⽤ CPU；
- **就绪状态**（*Ready*）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；
- **阻塞状态**（*Blocked*）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它 CPU 控制权，它也⽆法运⾏；

当然，进程还有另外两个基本状态：

- **创建状态**（*new*）：进程正在被创建时的状态；
- **结束状态**（*Exit*）：进程正在从系统中消失时的状态；

![进程5种状态](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503091907906.png)





### 什么是僵尸进程？

僵尸进程是**已完成且处于终止状态，但在进程表中却仍然存在的进程**。

僵尸进程**一般发生有父子关系的进程中**，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中。



### 什么是孤儿进程？

一个**父进程退出**，而它的**一个或多个子进程还在运行**，那么这些子进程将成为孤儿进程。孤儿进程**将被 init 进程 (进程 ID 为 1 的进程) 所收养**，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以**孤儿进程不会对系统造成危害**。





### 进程有哪些调度算法？

进程调度是操作系统中的核心功能之一，它负责决定哪些进程在何时使用 CPU。这一决定基于系统中的进程调度算法。

1. **先来先服务**
2. **短作业优先**
3. **优先级调度**
4. **时间片轮转**
5. **最短剩余时间优先**
6. **多级反馈队列**



①、**先来先服务**

这是最简单的调度算法，也称为**先进先出**（FIFO）。进程按照请求 CPU 的顺序进行调度。这种方式易于实现，但**可能会导致较短的进程等待较长进程执行完成，从而产生“饥饿”现象。**

[![三分恶面渣逆袭：先来先服务](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100953264.png)](https://camo.githubusercontent.com/be0684ef030dba161699f695ff1c02ee7ad713c0a0029f43ec31f6f279a7dab6/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d39333038386430332d383063392d343663352d396561662d6565616432616462366531322e706e67)

②、**短作业优先**

选择**预计运行时间最短的进程优先执行**。这种方式可以减少平均等待时间和响应时间，但缺点是**很难准确预知**进程的执行时间，并且**可能因为短作业一直在执行，导致长作业持续被推迟执行。**

[![三分恶面渣逆袭：短作业优先](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100953800.png)](https://camo.githubusercontent.com/1555abd1ee70729d9b014d827dc45ac8fe743e31d2c7086543cbdaade7f93e1b/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d35313765383339322d363466652d346465332d396531632d6233613934343832326162612e706e67)

③、**优先级调度**

在这种调度方式中，**每个进程都被分配一个优先级。CPU 首先分配给优先级最高的进程。优先级调度可以是非抢占式的或抢占式的**。在非抢占式优先级调度中，进程一旦开始执行将一直运行直到完成；在抢占式优先级调度中，更高优先级的进程可以中断正在执行的低优先级进程。

[![三分恶面渣逆袭：优先级调度](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100953352.png)](https://camo.githubusercontent.com/a1ddd398fa652d75d67b04c507aeadfd1ef8e4a24859ff0d13e3ad08977ce495/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d37633434343163662d376238632d343636302d386261382d3239623830373665326461312e706e67)

④、**时间片轮转**

时间片轮转调度**为每个进程分配一个固定的时间段**，称为时间片，进程可以在这个时间片内运行。**如果进程在时间片结束时还没有完成，它将被放回队列的末尾**。时间片轮转是**公平的调度**方式，可以保证所有进程得到公平的 CPU 时间，**适用于共享系统**。

[![三分恶面渣逆袭：时间片轮转](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100953498.png)](https://camo.githubusercontent.com/cee829182545d8b11093f7d1ff3c9c5aea202a80f9fef627db0de6e5d620c1b2/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d61643232346333612d386163392d343233302d383465342d6563343334643562343966392e706e67)

⑤、**最短剩余时间优先**

这是短作业优先的一种改进形式，它是**抢占式的。**即**如果一个新进程的预计执行时间比当前运行进程的剩余时间短，调度器将暂停当前的进程，并切换到新进程**。这种方法也可以最小化平均等待时间，但同样**面临预测执行时间的困难**。

⑥ **多级反馈队列**

一个进程需要执行100 个时间片，如果采用时间片轮转调度算法，那么需要交互 100 次。

多级队列就是为这种**需要连续执行多个时间片的进程考虑**，它设置了**多个队列，每个队列的时间片大小不同**，比如 2,4,6,8······。**进程在第一个队列没执行完，就会被移到下一个队列。**

这种方式下，之前的进程只需要交换 7 次就可以了。每个队列优先权不一样，最上面的队列优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是**时间片轮转调度算法与优先级调度算法的结合**。

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100953628.png" alt="DIDA-lJ-多级反馈队列" style="zoom: 67%;" />







### 进程间通信有哪些方式？

进程间通信的方式有 6 种，管道、信号、消息队列、共享内存、信号量和套接字。

[![编程十万问：进程间通信](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100958456.png)](https://camo.githubusercontent.com/790550d58f9221b7b68735155483eb4eef1b74a1f169f33e918c6123d24751b1/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6f732d32303234303331343037333232362e706e67)



#### 简单说说管道：

管道可以理解成不同进程之间的传话筒，一方发声，一方接收，声音的介质可以是空气或者电缆。

**进程间的管道就是内核中的一串缓存**，从管道的一端写入数据，另一端读取。数据只能**单向流动**，遵循**先进先出（FIFO）**的原则。

[![编程十万问：管道](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100958217.png)](https://camo.githubusercontent.com/3911b0fe4f08237aa4ac2d929a06ac7a098b43968290a3652d13a6755d9da759/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6f732d32303234303331343037333533352e706e67)

①、**匿名管道**：允许具有亲缘关系的进程（如**父子进程**）进行通信。

![image-20250310095911467](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100959579.png)

②、**命名管道**：允许**无亲缘关系**的进程通信，通过在文件系统中创建一个特殊类型的文件来实现。



**缺点：管道的效率低，不适合进程间频繁地交换数据。**





#### 简单说说信号：

信号可以理解成以前的 BB 机，用于通知接收进程某件事情发生了，是一种较为简单的通信方式，主要用于处理**异步事件**。

比如`kill -9 1050`就表示给 PID 为 1050 的进程发送`SIGKIL`信号。

这里顺带普及一下 Linux 中常用的信号：

- SIGHUP：当我们退出终端（Terminal）时，由该终端启动的所有进程都会接收到这个信号，默认动作为终止进程。
- SIGINT：程序终止（interrupt）信号。按 `Ctrl+C` 时发出，大家应该在操作终端时有过这种操作。
- SIGQUIT：和 SIGINT 类似，按 `Ctrl+\` 键将发出该信号。它会产生核心转储文件，将内存映像和程序运行时的状态记录下来。
- SIGKILL：强制杀死进程，本信号不能被阻塞和忽略。
- SIGTERM：与 SIGKILL 不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。



#### 简单说说消息队列：

消息队列是**保存在内核中的消息链表**，按照消息的类型进行消息传递，具有较高的可靠性和稳定性。

[![编程十万问：消息队列](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503100959483.png)](https://camo.githubusercontent.com/6c0d29cb1a551b933d8b629591fd0636c97e0da0a7e481cabae5e2185ce52f02/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6f732d32303234303331343037353034352e706e67)

**缺点：消息体有一个最大长度的限制，不适合比较大的数据传输；存在用户态与内核态之间的数据拷贝开销。**

![编程十万问：消息队列](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101003432.png)



#### 简单说说共享内存：

**允许两个或多个进程共享一个给定的内存区，一个进程写入的东西，其他进程马上就能看到。**

共享内存是**最快的进程间通信方式**，它是针对其他进程间通信方式运行效率低而专门设计的。

[![三分恶面渣逆袭：共享内存](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101003181.png)](https://camo.githubusercontent.com/5ef3cd0750d97c2ec7426188fc5c4105c7a3ec48edc20897cbfcc23a45f159e2/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d64396533636661662d303165372d343266662d393239302d3934656634613563376435652e706e67)

**缺点：当多进程竞争同一个共享资源时，会造成数据错乱的问题。**





#### 简单说说信号量：

信号量可以理解成红绿灯，红灯停（信号量为零），绿灯行（信号量非零）。**它本质上是一个计数器**，用来控制对共享资源的访问数量。

[![三分恶面渣逆袭：信号量](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101004280.png)](https://camo.githubusercontent.com/704f8ce0bfed4be3c5bbf7d6ddbc5de0a08c6be1d44c1e60124504ea78bfef31/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d35666237363561662d393138632d343033372d613361642d3463616434643938356531362e706e67)

它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。Java 中的 [java.util.concurrent.Semaphore 类](https://javabetter.cn/thread/CountDownLatch.html#semaphore)就实现了类似的功能。

控制信号量的⽅式有两种原⼦操作：

- ⼀个是 **P 操作**（wait，减操作），当进程希望获取资源时，它会执行 P 操作。如果信号量的值大于 0，表示有资源可用，信号量的值减 1，进程继续执行。如果信号量的值为 0，表示没有可用资源，进程进入等待状态，直到信号量的值变为大于 0。
- 另⼀个是 **V 操作**（signal，加操作），当进程释放资源时，它会执行 V 操作，信号量的值加 1。如果有其他进程因为等待该资源而被阻塞，这时会唤醒其中一个进程。

![编程十万问：信号量](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101004351.png)



#### 简单说说套接字 Socket：

这个和 Java 中的 Socket 很相似，提供网络通信的端点，**可以让不同机器上运行的进程之间进行双向通信。**

[![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101008417.png)](https://camo.githubusercontent.com/110fcc4f4066602cd6d7749e4a8b4dceb1d052b37ae50ee6ad777af45ff675f3/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6f732d32303234303331343038323433382e706e67)









### 进程和线程的联系和区别？

**进程是一个正在执行的程序实例**。**每个进程都有自己独立的地址空间、全局变量、堆栈、和文件描述符等资源。**

**线程是进程中的一个执行单元**。**一个进程可以包含多个线程，它们共享进程的地址空间和资源。**

[![多线程-图片来源于网络](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101009058.png)](https://camo.githubusercontent.com/f4d7dc8e275c2b3c85f8944a5eb3627017b4be2152c0c5abc3cb1c80a7072808/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d32373165343530622d363665662d346636632d623832332d3865306237333334373832352e706e67)

每个进程在独立的地址空间中运行，不会直接影响其他进程。线程共享同一个进程的内存空间、全局变量和文件描述符。

进程切换需要保存和恢复大量的上下文信息，代价较高。线程切换相对较轻量，因为线程共享进程的地址空间，只需要保存和恢复线程私有的数据。

线程的生命周期由进程控制，进程终止时，其所有线程也会终止。

| 特性       | 进程                         | 线程                             |
| ---------- | ---------------------------- | -------------------------------- |
| 地址空间   | 独立                         | 共享                             |
| 内存开销   | 高                           | 低                               |
| 上下文切换 | 慢，开销大                   | 快，开销小                       |
| 通信       | 需要 IPC 机制，开销较大      | 共享内存，直接通信               |
| 创建销毁   | 开销大，较慢                 | 开销小，较快                     |
| 并发性     | 低                           | 高                               |
| 崩溃影响   | 一个进程崩溃不会影响其他进程 | 一个线程崩溃可能导致整个进程崩溃 |







### 线程上下文切换了解吗？

这还得看线程是不是属于同⼀个进程：

- **当两个线程不是属于同⼀个进程：则切换的过程就跟进程上下文切换⼀样；**
- **当两个线程是属于同⼀个进程：    因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数            据、寄存器等不共享的数据**；

所以，线程的上下文切换相比进程，开销要小很多。





### 线程有哪些实现方式？

主要有三种线程的实现方式：

- **内核态线程实现**：在内核空间实现的线程，由内核直接管理直接管理线程。

[<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101021410.png" alt="内核态线程实现" style="zoom: 67%;" />](https://camo.githubusercontent.com/faead2bb6d5f55ecb919602eabe243bbb16d85e56a29cbc072936e1e88071730/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d33306238343238352d383032372d343732302d623530622d3362306662313863373536662e706e67)

- **用户态线程实现**：在用户空间实现线程，不需要内核的参与，内核对线程无感知。

[<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101021306.png" alt="用户态线程" style="zoom:67%;" />](https://camo.githubusercontent.com/afaeb7ecf0f89e60ebb2ef559450c16f7eb458049041d3339facd9861f3d9721/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d35373838363138312d353666652d343262662d383565312d3464303632343535373838612e706e67)

- **混合线程实现**：现代操作系统基本都是将两种方式结合起来使用。用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。即我们同时实现内核态和用户态线程管理。其中**内核态线程数量较少，而用户态线程数量较多**。每个**内核态线程可以服务一个或多个用户态线程。**

[
<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101021886.png" alt="混合线程实现" style="zoom:67%;" />](https://camo.githubusercontent.com/b8150a25ed2b99c7994595a3eb383ca9d04fa2a8a0980cd7752fab27b72b7b56/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d31353937643135392d316230372d343861652d616338362d3765396239636238353837362e706e67)





### 线程间如何同步？

同步解决的是多线程操作共享资源的问题，不管线程之间是如何穿插执行的，最后的结果都是正确的。

在操作系统层面，保证线程同步的方式有很多，比如锁、信号量等。那在此之前，需要先了解什么是临界区。

[<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101034148.png" alt="cxuan：使用临界区的互斥" style="zoom: 50%;" />](https://camo.githubusercontent.com/9a0f79a49d1c058290d91a9f5c6575cb17d89e12f37f78c2ccdf4dc9ca37aacb/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6a6176617468726561642d32303234313030383130323834342e706e67)

临界区：对共享资源访问的程序片段，我们希望这段代码是互斥的，可以保证在某个时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。

临界区不仅针对线程，同样针对进程。同步的实现方式有：

①、**互斥锁**

使⽤加锁操作和解锁操作可以解决并发线程/进程的互斥问题。

任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对临界资源的访问后再执⾏解锁操作，以释放该临界资源。

加锁和解锁锁住的是什么呢？可以是`临界区对象`，也可以只是一个简单的`互斥量`，例如互斥量是`0`无锁，`1`表示加锁。

根据锁的实现不同，可以分为`忙等待锁`和`⽆忙等待锁`。

- 忙等待锁（也称为自旋锁，Spinlock）是指当一个线程试图获取锁时，如果该锁已经被其他线程持有，当前线程不会立即进入休眠或阻塞，而是不断地检查锁的状态，直到该锁可用为止。这个过程被称为忙等待（busy waiting），因为线程在等待锁时仍然占用 CPU 资源，处于活跃状态。优点是避免了线程的上下文切换。
- 无忙等待锁是指当一个线程尝试获取锁时，如果锁已经被其他线程持有，当前线程不会忙等待，而是主动让出 CPU，进入阻塞状态或休眠状态，等待锁释放。当锁被释放时，线程被唤醒并重新尝试获取锁。这类锁的主要目的是避免忙等待带来的 CPU 资源浪费。

②、**信号量**

信号量是操作系统提供的⼀种协调共享资源访问的⽅法。**通常表示资源的数量**，对应的变量是⼀个整型（sem）变量。

另外，还有**两个原⼦操作的系统调⽤函数来控制信号量**，分别是：

- *P* 操作：当线程想要进入临界区时，会尝试执行 P 操作。如果信号量的值大于 0，信号量值减 1，线程可以进入临界区；否则，线程会被阻塞，直到信号量大于 0。
- *V* 操作：当线程退出临界区时，执行 V 操作，信号量的值加 1，释放一个被阻塞的线程。



































































































































## IO

### 零拷贝了解吗？

假如需要文件传输，**使用传统 I/O，数据读取和写入是用户空间到内核空间来回赋值，而内核空间的数据是通过操作系统的 I/O 接口从磁盘读取或者写入，这期间发生了多次用户态和内核态的上下文切换，以及多次数据拷贝。**

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101039832.png" alt="传统文件传输示意图-来源参考[3]" style="zoom:67%;" />

为了提升 I/O 性能，就需要**减少用户态与内核态的上下文切换**和**内存拷贝的次数**。

这就用到了我们零拷贝的技术，零拷贝技术实现主要有两种：



- **mmap + write**

mmap() 系统调用函数会直接把内核缓冲区里的数据「**映射**」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101040822.png" alt="mmap示意图-来源参考[3]" style="zoom: 67%;" />



- **sendfile**

在 Linux 内核版本 2.1 中，提供了⼀个专⻔发送⽂件的系统调⽤函数 sendfile() 。

⾸先，它可以替代前⾯的 read() 和 write() 这两个系统调⽤，这样就可以减少⼀次系统调⽤，也就减少了 2 次上下⽂切换的开销。

其次，该系统调⽤，可以直接把内核缓冲区⾥的数据拷⻉到 socket 缓冲区⾥，不再拷⻉到⽤户态，这样就只有 2 次上下⽂切换，和 3 次数据拷⻉。

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101040972.png" alt="sendfile示意图-来源参考[3]" style="zoom:67%;" />

很多开源项目如 Kafka、RocketMQ 都采用了零拷贝技术来提升 IO 效率。













### 详细讲一讲 I/O 多路复用？

> 我们先了解什么是 I/O 多路复用？

我们在传统的 I/O 模型中，如果服务端需要支持多个客户端，我们可能要为每个客户端分配一个进程/线程。

不管是基于重一点的进程模型，还是轻一点的线程模型，假如连接多了，操作系统是扛不住的。

所以就引入了**I/O 多路复用** 技术。

简单说，就是一个进程/线程维护多个 Socket，这个多路复用就是多个连接复用一个进程/线程。

[![I/O多路复用](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101045968.png)](https://camo.githubusercontent.com/32559cb509651fae05563be805f6edd308bf7bbe7c314e9e3dacb2a1f4071b80/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6f732d39623237366231342d656231622d343762662d623261612d3235323132653162626466382e706e67)

我们来看看 I/O 多路复用三种实现机制：



- **select**

select 实现多路复⽤的⽅式是：

将已连接的 Socket 都放到⼀个**⽂件描述符集合**fd_set，然后调⽤ select 函数将 fd_set 集合拷⻉到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历 fd_set 的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个 fd_set 拷⻉回⽤户态⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，再对其处理。

select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 1024 ，只能监听 0~1023 的⽂件描述符。

> select 机制的缺点：

（1）每次调用 select，都需要把 fd_set 集合从用户态拷贝到内核态，如果 fd_set 集合很大时，那这个开销也很大，比如百万连接却只有少数活跃连接时这样做就太没有效率。

（2）每次调用 select 都需要在内核遍历传递进来的所有 fd_set，如果 fd_set 集合很大时，那这个开销也很大。

（3）为了减少数据拷贝带来的性能损坏，内核对被监控的 fd_set 集合大小做了限制，一般为 1024，如果想要修改会比较麻烦，可能还需要编译内核。

（4）每次调用 select 之前都需要遍历设置监听集合，重复工作。



- **poll**

poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤动态数组，以链表形式来组织，突破了 select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。

但是 poll 和 select 并没有太⼤的本质区别，都是使⽤线性结构存储进程关注的 Socket 集合，因此都需要遍历⽂件描述符集合来找到可读或可写的 Socke，时间复杂度为 O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。



- **epoll**

epoll 通过两个⽅⾯，很好解决了 select/poll 的问题。

第⼀点，epoll 在内核⾥使⽤**红⿊树来跟踪进程所有待检测的⽂件描述字**，把需要监控的 socket 通过 epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是 O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，**减少了内核和⽤户空间⼤量的数据拷⻉和内存分配**。

第⼆点， epoll 使⽤事件驱动的机制，内核⾥**维护了⼀个链表来记录就绪事件**，当某个 socket 有事件发⽣时，通过回调函数，内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤ epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。

![epoll接口作用-来源参考[3]](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503101045495.png)

epoll 的⽅式即使监听的 Socket 数量越多的时候，效率不会⼤幅度降低，能够同时监听的 Socket 的数⽬也⾮常的多了，上限就为系统定义的进程打开的最⼤⽂件描述符个数。因⽽，**epoll** **被称为解决** **C10K** **问题的利器**。







### **I/O 多路复用通俗讲解**

#### **1. 为什么需要 I/O 多路复用？**

想象你在一个餐厅工作，客人（客户端）点餐后需要等待菜品做好（数据读取完成）。

- **传统方式（一个线程/进程一个连接）**：
  - 你（服务器）需要给每个客人安排一个专门的服务员（线程/进程），一直守着他们，看看菜做好了没有。
  - 如果客人很多，餐厅就得雇很多服务员（线程/进程），这就会消耗大量资源。
- **I/O 多路复用（一个线程/进程多个连接）**：
  - 你（服务器）雇一个总服务员（主线程），负责管理所有客人（多个连接）。
  - 总服务员定期查看有哪些客人的菜做好了（数据可读写），然后通知专门的送餐员（业务逻辑处理）。
  - 这样一个服务员可以管理很多客人，不需要给每个客人安排一个单独的服务员，节省资源。

------

#### **2. I/O 多路复用的三种方式**

##### **(1) select** —— 「老旧但可用」

📌 **特点**：

- 让一个服务员管理多个客人，但每次都得问一遍**“你们的菜做好了吗？”**（遍历 fd_set）。
- 每次询问都要**把客人名单从前厅搬到厨房**（用户态拷贝到内核态），然后再搬回来（开销大）。
- 最多只能管理 1024 个客人（FD_SETSIZE 限制）。

📌 **问题**：

- 每次查询都要遍历所有客人，即使有些客人还没点菜（没有事件发生）。
- 管理的客人数量有限（1024）。
- 频繁搬运数据，效率低。

🛑 **总结**：select 适合少量并发，但遇到高并发（比如 1 万个连接）就不行了。

------

##### **(2) poll** —— 「select 的改进版」

📌 **特点**：

- 也需要轮询所有客人**“你的菜好了没？”**（遍历文件描述符），但客人数量**不受 1024 限制**。
- 采用动态数组存储连接信息，比 select 灵活。
- **问题和 select 本质相同**，依然是**遍历所有客人**，效率低。

🛑 **总结**：poll 解决了 select 的数量限制，但并没有根本性优化查询方式，效率仍然不高。

------

##### **(3) epoll** —— 「高效的餐厅管理系统」

📌 **特点**：

- **不再轮询所有客人**，而是让客人**自己举手**：“服务员，我的菜好了！”（事件通知机制）。
- **客人名单存放在内核的红黑树里**，查询速度快（O(logN)）。
- **只关心有需求的客人**，减少不必要的遍历，提高效率。

📌 **优势**：
 ✅ **省去了遍历的开销**（事件驱动）
 ✅ **客人数量几乎无限制**（只受系统文件描述符限制）
 ✅ **只有真的有事情要处理时，才去关注**（减少 CPU 资源浪费）

🛑 **总结**：epoll 非常适合高并发场景，比如**上万连接**的服务器，真正解决了**C10K**（同时处理 1 万个客户端连接）问题。



























































































































































































































































































































































































































































