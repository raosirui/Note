# JVM

### 什么是 JVM?

JVM 大致可以划分为三个部分：类加载器、运行时数据区和执行引擎。

[<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503312304109.png" alt="截图来源于网络" style="zoom: 60%;" />](https://camo.githubusercontent.com/fc6107f4bb47f25688efdde784e66ba7e6f6b3a2c72324839512aabe1daf30a1/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f776861742d69732d6a766d2d32303233313033303138353734322e706e67)

① 类加载器，负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。

② 运行时数据区，JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照 Java 虚拟机规范可以划分为方法区、堆、虚拟机栈、程序计数器和本地方法栈。

③ 执行引擎，也是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器、即时编译器 JIT 和垃圾回收器。





JVM，也就是 Java 虚拟机，它是 Java 实现跨平台的基石。

程序运行之前，需要先通过编译器将 Java 源代码文件编译成 Java 字节码文件；

**程序运行时，JVM 会对字节码文件进行逐行解释，翻译成机器码指令，并交给对应的操作系统去执行。**

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503312238431.png" alt="三分恶面渣逆袭：Java语言编译运行" style="zoom: 50%;" />

这样就实现了 Java 一次编译，处处运行的特性。



#### 说说 JVM 的其他特性？

①、JVM 可以**自动管理内存**，通过垃圾回收器回收不再使用的对象并释放内存空间。

②、JVM 包含一个**即时编译器 JIT**，它可以在运行时将热点代码缓存到 codeCache 中，下次执行的时候不用再一行一行的解释，而是直接执行缓存后的机器码，执行效率会大幅提高。

[![截图来自美团技术](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503312238019.png)](https://camo.githubusercontent.com/afd75b0c08b756159d632ab2491a8b160942a8ef1e34ea506f9fe5b700d61295/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f6a766d2f6a69742d39613632666330322d316136612d343531652d626232622d3139666330383664356265302e706e67)

③、任何可以通过 Java 编译的语言，比如说 Groovy、Kotlin、Scala 等，都可以在 JVM 上运行。



#### 为什么要学习 JVM？

学习 JVM 可以帮助我们开发者更好地优化程序性能、避免内存问题。

比如说了解 JVM 的内存模型和垃圾回收机制，可以帮助我们更合理地配置内存、减少 GC 停顿。

比如说掌握 JVM 的类加载机制可以帮助我们排查类加载冲突或异常。

再比如说，JVM 还提供了很多调试和监控工具，可以帮助我们分析内存和线程的使用情况，从而解决内存溢出内存泄露等问题。







## 内存管理

### 能说一下 JVM 的内存区域吗？

按照 Java 虚拟机规范，JVM 的内存区域可以细分为`程序计数器`、`虚拟机栈`、`本地方法栈`、`堆`和`方法区`。

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503312309225.png" alt="image-20250331230936084" style="zoom:50%;" />

其中`方法区`和`堆`是线程共享的，`虚拟机栈`、`本地方法栈`和`程序计数器`是线程私有的。



#### 介绍一下程序计数器？

程序计数器也被称为 PC 寄存器，是一块较小的内存空间。它可以看作是当前线程所执行的**字节码行号指示器**。

作用：

- 在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个**内存地址**。如0x000001f248c072c0
- 程序计数器可以控制程序指令的进行，实现**分支、跳转、异常**等逻辑。
- 在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行。



#### 介绍一下 Java 虚拟机栈？

Java 虚拟机栈的**生命周期与线程相同**。

当线程执行一个方法时，会创建一个对应的[栈帧](https://javabetter.cn/jvm/stack-frame.html)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，然后栈帧会被压入虚拟机栈中。当方法执行完毕后，栈帧会从虚拟机栈中移除。

[<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503312310209.png" alt="三分恶面渣逆袭：Java虚拟机栈" style="zoom:50%;" />](https://camo.githubusercontent.com/53ec48e38765a9125799fc9a87a0ce22595c8fdf92c510a5b625276a6094c5b3/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6a766d2d342e706e67)



#### 一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？

```java
public class VarDemo1 {
    public void emptyMethod() {
        // 什么都没有
    }

    public static void staticEmptyMethod() {
        // 什么都没有
    }
}
```

对于**静态方法**，由于**不需要访问实例对象 this**，因此在局部变量表中不会有任何变量。

对于**非静态方法**，即使是一个完全空的方法，局部变量表中也会有一个用于**存储 this 引用的变量**。this 引用指向当前实例对象，在方法调用时被**隐式传入**。





#### 介绍一下本地方法栈？

本地方法栈与虚拟机栈相似，区别在于**虚拟机栈是为 JVM 执行 Java 编写的方法服务的**，而**本地方法栈是为 Java 调用[本地 native 方法](https://javabetter.cn/oo/native-method.html)服务**的，通常由 C/C++ 编写。

在本地方法栈中，主要存放了 native 方法的局部变量、动态链接和方法出口等信息。当一个 Java 程序调用一个 native 方法时，JVM 会切换到本地方法栈来执行这个方法。



#### 介绍一下本地方法栈的运行场景？

当 Java 应用需要与操作系统底层或硬件交互时，通常会用到本地方法栈。

比如**调用操作系统的特定功能，如内存管理、文件操作、系统时间、系统调用等**。





#### native 方法解释一下？

推荐阅读：[手把手教你用 C语言实现 Java native 本地方法](https://javabetter.cn/oo/native-method.html)

native 方法是在 Java 中通过 [native 关键字](https://javabetter.cn/basic-extra-meal/48-keywords.html)声明的，用于调用非 Java 语言，如 C/C++ 编写的代码。Java 可以通过 JNI，也就是 Java Native Interface 与**底层系统、硬件设备、或者本地库**进行交互。





#### 介绍一下 Java 堆？

堆是 JVM 中最大的一块内存区域，**被所有线程共享**，**在 JVM 启动时创建**，主要**用来存储 new 出来的对象。**

<img src="https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503312320176.png" alt="二哥的 Java 进阶之路：堆" style="zoom: 67%;" />

Java 中“几乎”所有的对象都会在堆中分配，堆也是[垃圾收集器](https://javabetter.cn/jvm/gc-collector.html)管理的目标区域。

从内存回收的角度来看，由于垃圾收集器大部分都是基于分代收集理论设计的，所以堆又被细分为`新生代`、`老年代`、`Eden空间`、`From Survivor空间`、`To Survivor空间`等。

[![三分恶面渣逆袭：Java 堆内存结构](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202503312319243.png)](https://camo.githubusercontent.com/b89884570d24cae83eb155408a6c46276f2bb5affc51e845813cdbf8cb8e9127/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6a766d2d352e706e67)

随着 **[JIT 编译器](https://javabetter.cn/jvm/jit.html)**的发展和**逃逸技术**的逐渐成熟，“所有的对象都会分配到堆上”就不再那么绝对了。

从 JDK 7 开始，JVM 默认开启了**逃逸分析，意味着如果某些方法中的对象引用没有被返回或者没有在方法体外使用，也就是未逃逸出去，那么对象可以直接在栈上分配内存。**



#### 堆和栈的区别是什么？

堆属于**线程共享**的内存区域，几乎所有 new 出来的对象都会堆上分配，生命周期不由单个方法调用所决定，**可以在方法调用结束后继续存在，直到不再被任何变量引用，最后被垃圾收集器回收。**

栈属于**线程私有**的内存区域，主要存储**局部变量、方法参数、对象引用**等，通常**随着方法调用的结束而自动释放**，不需要垃圾收集器处理。



#### 介绍一下方法区？

**方法区并不真实存在**，属于 Java 虚拟机规范中的一个逻辑概念，用于**存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等**。

在 HotSpot 虚拟机中，方法区的实现称为**永久代** PermGen，但在 Java 8 及之后的版本中，已经被**元空间** Metaspace 所替代。



#### 变量存在堆栈的什么位置？

对于**局部变量**，它**存储在当前方法栈帧中的局部变量表中**。当方法执行完毕，栈帧被回收，局部变量也会被释放。

```
public void method() {
    int localVar = 100;  // 局部变量，存储在栈帧中的局部变量表里
}
```

对于**静态变量**来说，它存储在 Java 虚拟机规范中的**方法区中**，在 Java 7 中是永久代，在 Java8 及以后 是元空间。

```
public class StaticVarDemo {
    public static int staticVar = 100;  // 静态变量，存储在方法区中
}
```







### 说一下 JDK 1.6、1.7、1.8 内存区域的变化？



























































































































































































































































































































































































































































