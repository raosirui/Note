# MySQL

## MySQL 基础

### 说一下数据库的三大范式？

三大范式的作用是为了减少数据冗余，提高数据完整性。

[![三分恶面渣逆袭：数据库三范式](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202412192038665.jpeg)](https://camo.githubusercontent.com/2728eb8cdd78f92531014969f087d2d9efcec784b5f38892fc8e12d7c54886f5/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6d7973716c2d31366537346136622d613432612d343634652d396231302d3032353265653765636336652e6a7067)

①、第一范式：**确保表的每一列都是不可分割的基本数据单元**，比如说用户地址，应该拆分成省、市、区、详细信息等 4 个字段。

[![Ruthless：第一范式](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202412192039814.png)](https://camo.githubusercontent.com/7039e0faf9405e4abb39489b6c9a234055f3f494c9abb98e819368e06280a37a/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6d7973716c2d32303234303431383039333233352e706e67)

②、第二范式：要求**表中的每一列都和主键直接相关，而不能只与主键的某一部分相关。**

比如在一个订单表中，可能会存在订单编号和商品编号。

[![Ruthless：不符合第二范式](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202412192039654.png)](https://camo.githubusercontent.com/c87339390f44b8bb2e408552c447694063b6f9c3402eb21c0970f2ea909575ed/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6d7973716c2d32303234303431383039333335312e706e67)

这个订单表中就存在冗余数据，比如说商品名称、单位、商品价格等，应该将其拆分为订单表、订单商品关联表、商品表。

③、第三范式：非主键列应该只依赖于主键列，不依赖于其他非主键列。

比如说在设计订单信息表的时候，可以把客户名称、所属公司、联系方式等信息拆分到客户信息表中，然后在订单信息表中用客户编号进行关联。

[![Ruthless：第三范式](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202412192040824.png)](https://camo.githubusercontent.com/a019beb05b89f98e1bf92fabba24ba2063c5716029186369d4f8cead00155c72/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f73747574796d6f72652f6d7973716c2d32303234303431383039343333322e706e67)





### varchar 与 char 的区别？

[![varchar](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202412192048416.jpeg)](https://camo.githubusercontent.com/71f5ef61bdb0f4102030375d0b09f9b69b3715b655cc05955c01eff7f49523b8/68747470733a2f2f63646e2e746f62656265747465726a61766165722e636f6d2f746f62656265747465726a61766165722f696d616765732f736964656261722f73616e66656e652f6d7973716c2d34306634326435392d613239352d343534332d386130332d3433393235646134643664392e6a7067)

| **特性**       | **CHAR**                                         | **VARCHAR**                                    |
| -------------- | ------------------------------------------------ | ---------------------------------------------- |
| **定义**       | 定长字符串，长度固定                             | 可变长字符串，长度可变                         |
| **存储方式**   | 长度不足时用空格填充到固定长度                   | 按实际数据长度存储，无需填充                   |
| **存取速度**   | 存取速度快（长度固定，效率高，可能快约 50%）     | 存取速度较慢（长度可变，需要额外开销）         |
| **空间利用率** | 空间利用率低，可能浪费存储空间                   | 空间利用率高，仅存储实际数据                   |
| **最大长度**   | 最多能存放 255 个字符，与编码无关                | 最多能存放 65532 个字符                        |
| **适用场景**   | 适用于存储长度固定的数据（如身份证号、邮政编码） | 适用于存储长度变化较大的数据（如姓名、地址等） |



### blob 和 text 有什么区别？

- blob 用于存储**二进制数据**，而 text 用于存储**大字符串**。
- **blob 没有字符集，text 有一个字符集**，并且根据字符集的校对规则对值进行**排序和比较**



### DATETIME 和 TIMESTAMP 的异同？

**相同点**：

1. 两个数据类型存储时间的表现格式一致。均为 `YYYY-MM-DD HH:MM:SS`
2. 两个数据类型都包含「日期」和「时间」部分。
3. 两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）

**区别**：

| **特性**     | **DATETIME**                                                 | **TIMESTAMP**                                                |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **日期范围** | `1000-01-01 00:00:00.000000` 到 `9999-12-31 23:59:59.999999` | `1970-01-01 00:00:01.000000` UTC 到 `2038-01-09 03:14:07.999999` UTC |
| **存储空间** | 8 字节                                                       | 4 字节                                                       |
| **时区相关** | 与时区无关                                                   | 与时区有关，存储的是 UTC 时间，显示时会转换为当前时区        |
| **默认值**   | 默认值为 `NULL`                                              | 默认值为当前时间（`CURRENT_TIMESTAMP`），默认非空            |
| **使用场景** | 适合表示独立于时区的时间（如日志、计划等）                   | 适合需要与时区相关的时间（如记录事件的精确时间戳）           |



### in 和 exists 的区别？

MySQL 中的 **in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。**我们可能认为 exists 比 in 语句的效率要高，这种说法其实是不准确的，要区分情景：

1. 如果查询的两个表大小相当，那么用 in 和 exists 差别不大。
2. 如果两个表中一个较小，一个是大表，则**子查询表大的用 exists，子查询表小的用 in**。
3. not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。



### 记录货币用什么字段类型比较好？

货币在数据库中 MySQL 常用 **Decimal 和 Numeric** 类型表示，这两种类型**被 MySQL 实现为同样的类型**。他们被用于保存与货币有关的数据。

例如 salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。

DECIMAL 和 NUMERIC 值**作为字符串存储**，而不是作为二进制浮点数，以便保存那些值的小数精度。

**之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。**



### 怎么存储 emoji?

MySQL 的 utf8 字符集仅支持最多 3 个字节的 UTF-8 字符，但是 emoji 表情（😊）是 4 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 表情时，需要使用 utf8mb4 字符集。

MySQL 8.0 已经默认支持 utf8mb4 字符集





### drop、delete 与 truncate 的区别？

三者都表示删除，但是三者有一些差别：

| 区别     | delete                                       | truncate                           | drop                                                   |
| -------- | -------------------------------------------- | ---------------------------------- | ------------------------------------------------------ |
| 类型     | 属于 DML                                     | 属于 DDL                           | 属于 DDL                                               |
| 回滚     | **可回滚**                                   | **不可回滚**                       | **不可回滚**                                           |
| 删除内容 | **表结构还在，删除表的全部或者一部分数据行** | **表结构还在，删除表中的所有数据** | **从数据库中删除表，所有数据行，索引和权限也会被删除** |
| 删除速度 | 删除速度慢，需要逐行删除                     | 删除速度快                         | 删除速度最快                                           |

因此，**在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。**



### UNION 与 UNION ALL 的区别？

| **特性**     | **UNION**                                      | **UNION ALL**                      |
| ------------ | ---------------------------------------------- | ---------------------------------- |
| **重复数据** | 默认会对结果进行去重，**移除重复行**           | **不去重，保留所有重复行**         |
| **性能**     | 因为需要去重，所以性能较低                     | 因为不需要去重，所以性能更高       |
| **使用场景** | 适用于需要合并且确保结果集中无重复数据的情况   | 适用于需要合并并保留所有数据的情况 |
| **去重机制** | 使用 `DISTINCT` 对结果集去重，增加额外计算开销 | 不执行去重操作                     |





















































































































































































































































































































































































































































































































































