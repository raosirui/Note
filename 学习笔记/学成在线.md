# 学成在线项目

# **1、JSR303校验**

## **5.7.1 统一校验的需求**

前端请求后端接口传输参数，是在controller中校验还是在Service中校验？

答案是都需要校验，只是分工不同。

Contoller中校验请求参数的合法性，包括：必填项校验，数据格式校验，比如：是否是符合一定的日期格式，等。

Service中要校验的是业务规则相关的内容，比如：课程已经审核通过所以提交失败。

Service中根据业务规则去校验不方便写成通用代码，Controller中则可以将校验的代码写成通用代码。

早在JavaEE6规范中就定义了参数校验的规范，它就是JSR-303，它定义了Bean Validation，即对bean属性进行校验。

SpringBoot提供了JSR-303的支持，它就是spring-boot-starter-validation，它的底层使用Hibernate Validator，Hibernate Validator是Bean Validation 的参考实现。

所以，我们准备在Controller层使用spring-boot-starter-validation完成对请求参数的基本合法性进行校验。

## **5.7.2 统一校验实现**

首先在Base工程添加spring-boot-starter-validation的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

在javax.validation.constraints包下有很多这样的校验注解，直接使用注解定义校验规则即可。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231418402.png)

规则如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231418426.png)

现在准备对内容管理模块添加课程接口进行参数校验，如下接口

```Java
@ApiOperation("新增课程基础信息")
@PostMapping("/course")
public CourseBaseInfoDto createCourseBase(@RequestBody AddCourseDto addCourseDto){
    //机构id，由于认证系统没有上线暂时硬编码
    Long companyId = 1232141425L;
  return courseBaseInfoService.createCourseBase(companyId,addCourseDto);
}
```

此接口使用AddCourseDto模型对象接收参数，所以进入AddCourseDto类，在属性上添加校验规则。

```Java
package com.xuecheng.content.model.dto;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.Size;
import java.math.BigDecimal;

/**
 * @description 添加课程dto
 * @author Mr.M
 * @date 2022/9/7 17:40
 * @version 1.0
 */
@Data
@ApiModel(value="AddCourseDto", description="新增课程基本信息")
public class AddCourseDto {

 @NotEmpty(message = "课程名称不能为空")
 @ApiModelProperty(value = "课程名称", required = true)
 private String name;

 @NotEmpty(message = "适用人群不能为空")
 @Size(message = "适用人群内容过少",min = 10)
 @ApiModelProperty(value = "适用人群", required = true)
 private String users;

 @ApiModelProperty(value = "课程标签")
 private String tags;

 @NotEmpty(message = "课程分类不能为空")
 @ApiModelProperty(value = "大分类", required = true)
 private String mt;

 @NotEmpty(message = "课程分类不能为空")
 @ApiModelProperty(value = "小分类", required = true)
 private String st;

 @NotEmpty(message = "课程等级不能为空")
 @ApiModelProperty(value = "课程等级", required = true)
 private String grade;

 @ApiModelProperty(value = "教学模式（普通，录播，直播等）", required = true)
 private String teachmode;

 @ApiModelProperty(value = "课程介绍")
 private String description;

 @ApiModelProperty(value = "课程图片", required = true)
 private String pic;

 @NotEmpty(message = "收费规则不能为空")
 @ApiModelProperty(value = "收费规则，对应数据字典", required = true)
 private String charge;

 @ApiModelProperty(value = "价格")
 private BigDecimal price;

}
```

上边用到了@NotEmpty和@Size两个注解，@NotEmpty表示属性不能为空，@Size表示限制属性内容的长短。

定义好校验规则还需要开启校验，在controller方法中添加@Validated注解，如下：

```Bash
@ApiOperation("新增课程基础信息")
@PostMapping("/course")
public CourseBaseInfoDto createCourseBase(@RequestBody @Validated AddCourseDto addCourseDto){
    //机构id，由于认证系统没有上线暂时硬编码
    Long companyId = 1L;
  return courseBaseInfoService.createCourseBase(companyId,addCourseDto);
}
```

如果校验出错Spring会抛出MethodArgumentNotValidException异常，我们需要在统一异常处理器中捕获异常，解析出异常信息。

代码 如下：

```Bash
@ResponseBody
@ExceptionHandler(MethodArgumentNotValidException.class)
@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
public RestErrorResponse methodArgumentNotValidException(MethodArgumentNotValidException e) {
    BindingResult bindingResult = e.getBindingResult();
    List<String> msgList = new ArrayList<>();
    //将错误信息放在msgList
    bindingResult.getFieldErrors().stream().forEach(item->msgList.add(item.getDefaultMessage()));
    //拼接错误信息
    String msg = StringUtils.join(msgList, ",");
    log.error("【系统异常】{}",msg);
    return new RestErrorResponse(msg);
}
```

重启内容管理服务。

使用httpclient进行测试，将必填项设置为空，“适用人群” 属性的内容设置1个字。

执行测试，接口响应结果如下：

```Bash
{
  "errMessage": "课程名称不能为空,课程分类不能为空,课程分类不能为空,适用人群内容过少"
}
```

可以看到校验器生效。

## **5.7.3 分组校验**

有时候在同一个属性上设置一个校验规则不能满足要求，比如：订单编号由系统生成，在添加订单时要求订单编号为空，在更新 订单时要求订单编写不能为空。此时就用到了分组校验，同一个属性定义多个校验规则属于不同的分组，比如：添加订单定义@NULL规则属于insert分组，更新订单定义@NotEmpty规则属于update分组，insert和update是分组的名称，是可以修改的。

下边举例说明

我们用class类型来表示不同的分组，所以我们定义不同的接口类型（空接口）表示不同的分组，由于校验分组是公用的，所以定义在 base工程中。如下：

```Bash
package com.xuecheng.base.exception;
 /**
 * @description 校验分组
 * @author Mr.M
 * @date 2022/9/8 15:05
 * @version 1.0
 */
public class ValidationGroups {

 public interface Inster{};
 public interface Update{};
 public interface Delete{};

}
```

下边在定义校验规则时指定分组：

```Bash
@NotEmpty(groups = {ValidationGroups.Inster.class},message = "添加课程名称不能为空")
 @NotEmpty(groups = {ValidationGroups.Update.class},message = "修改课程名称不能为空")
// @NotEmpty(message = "课程名称不能为空")
 @ApiModelProperty(value = "课程名称", required = true)
 private String name;
```

在Controller方法中启动校验规则指定要使用的分组名：

```Bash
@ApiOperation("新增课程基础信息")
@PostMapping("/course")
public CourseBaseInfoDto createCourseBase(@RequestBody @Validated({ValidationGroups.Inster.class}) AddCourseDto addCourseDto){
    //机构id，由于认证系统没有上线暂时硬编码
    Long companyId = 1L;
  return courseBaseInfoService.createCourseBase(companyId,addCourseDto);
}
```

再次测试，由于这里指定了Insert分组，所以抛出 异常信息：添加课程名称不能为空。

如果修改分组为ValidationGroups.Update.class，异常信息为：修改课程名称不能为空。

## **5.7.4 校验规则不满足？**

如果javax.validation.constraints包下的校验规则满足不了需求怎么办？

1、手写校验代码 。

2、自定义校验规则注解。

如何自定义校验规则注解，请自行查阅资料实现。





# 2、分布式文件系统

## 3.1 什么是分布式文件系统

要理解分布式文件系统首先了解什么是文件系统。

查阅百度百科：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDhhNzlmYmI2ZDVmYzAwNzk0MTY0NzY3Y2Y2M2Y2YjlfNW1jYWY0RDZYYnJMOUpoVFJzSXVxM0o1THZEcVc0QWFfVG9rZW46SkNORWJCS2E5b3l1ZEd4aWU5UGNSZ1VCbk9lXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

​       文件系统是负责管理和存储文件的系统软件，操作系统通过文件系统提供的接口去存取文件，用户通过操作系统访问磁盘上的文件。

下图指示了文件系统所处的位置：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzg5ZDc0NWQyZDU1NGQwOWMwODI2MDdjZWRmZDRlZmFfT1VYRElxbmtTMnNZNm5sclBvZEw1VjI2Z2pZMU81RXlfVG9rZW46VmV3Z2JJZHZhb0cyb2p4NlhPWGM3TWN2bkRoXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

常见的文件系统：FAT16/FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等 。

现在有个问题，一此短视频平台拥有大量的视频、图片，这些视频文件、图片文件该如何存储呢？如何存储可以满足互联网上海量用户的浏览。

今天讲的分布式文件系统就是海量用户查阅海量文件的方案。

我们阅读百度百科去理解分布式文件系统的定义：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk5ZTE4MDQ5NGRhZjUzZTI1Yzg5N2FmMGJlYWEzMGZfT05aSnBzNDBzV2l2aXZxaFR4Ymp1cVBFaDNUZTA1dmNfVG9rZW46RG5mdWJLeTRUb1FxU294TU0yUWN0UkZzbkRiXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

通过概念可以简单理解为：一个计算机无法存储海量的文件，通过网络将若干计算机组织起来共同去存储海量的文件，去接收海量用户的请求，这些组织起来的计算机通过网络进行通信，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419650.png)

 好处：

1、一台计算机的文件系统处理能力扩充到多台计算机同时处理。

 2、一台计算机挂了还有另外副本计算机提供数据。

 3、每台计算机可以放在不同的地域，这样用户就可以就近访问，提高访问速度。

市面上有哪些分布式文件系统的产品呢？

1、NFS

阅读百度百科：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419684.png)

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419776.png)

特点：

1）在客户端上映射NFS服务器的驱动器。

2）客户端通过网络访问NFS服务器的硬盘完全透明。

2、GFS

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419761.png)

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419882.png)

1）GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成。

2）master存储了数据文件的元数据，一个文件被分成了若干块存储在多个chunkserver中。

3）用户从master中获取数据元信息，向chunkserver存储数据。

3) HDFS

HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。 HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。

下图是HDFS的架构图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419994.png)

1）HDFS采用主从结构，一个HDFS集群由一个名称结点和若干数据结点组成。

2) 名称结点存储数据的元信息，一个完整的数据文件分成若干块存储在数据结点。

3）客户端从名称结点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存取数据。

**4、云计算厂家**

阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。其数据设计持久性不低于 99.9999999999%（12 个 9），服务设计可用性（或业务连续性）不低于 99.995%。

> 官方网站：https://www.aliyun.com/product/oss 

百度对象存储BOS提供稳定、安全、高效、高可扩展的云存储服务。您可以将任意数量和形式的非结构化数据存入BOS，并对数据进行管理和处理。BOS支持标准、低频、冷和归档存储等多种存储类型，满足多场景的存储需求。 

> 官方网站：https://cloud.baidu.com/product/bos.html 

## 3.2 MinIO

### 3.2.1 介绍

本项目采用MinIO构建分布式文件系统，MinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。

它一大特点就是轻量，使用简单，功能强大，支持各种平台，单个文件最大5TB，兼容 Amazon S3接口，提供了 Java、Python、GO等多版本SDK支持。

官网：https://min.io

中文：https://www.minio.org.cn/，http://docs.minio.org.cn/docs/

MinIO集群采用去中心化共享架构，每个结点是对等关系，通过Nginx可对MinIO进行负载均衡访问。

去中心化有什么好处？

在大数据领域，通常的设计理念都是无中心和分布式。Minio分布式模式可以帮助你搭建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真实物理位置。

它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式Minio避免了单点故障。如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419126.png)

Minio使用纠删码技术来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数据分块冗余的分散存储在各各节点的磁盘上，所有的可用磁盘组成一个集合，上图由8块硬盘组成一个集合，当上传一个文件时会通过纠删码算法计算对文件进行分块存储，除了将文件本身分成4个数据块，还会生成4个校验块，数据块和校验块会分散的存储在这8块硬盘上。

使用纠删码的好处是即便丢失一半数量（N/2）的硬盘，仍然可以恢复数据。 比如上边集合中有4个以内的硬盘损害仍可保证数据恢复，不影响上传和下载，如果多于一半的硬盘坏了则无法恢复。

### 3.2.2 数据恢复演示

下边在本机演示MinIO恢复数据的过程，在本地创建4个目录表示4个硬盘。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=N2MwMzllZjA3YWNkY2FmOTFlMGY5YzFmYjZjOWJjY2NfNFZPTzBNMzFEOGtLMTNvYlNaZnY5ZEhhV0ptclRhTTRfVG9rZW46UjhKNGJNdVE4b0JsTWt4OHN2NmNqcHV0bk5mXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

下载minio，下载地址在https://dl.min.io/server/minio/release/，可从课程资料找到MinIO的安装文件minio.zip解压即可使用，CMD进入有minio.exe的目录，运行下边的命令：

```Plain
minio.exe server D:\develop\minio_data\data1  D:\develop\minio_data\data2  D:\develop\minio_data\data3  D:\develop\minio_data\data4
```

启动结果如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419972.png)

说明如下：

```SQL
WARNING: MINIO_ACCESS_KEY and MINIO_SECRET_KEY are deprecated.
         Please use MINIO_ROOT_USER and MINIO_ROOT_PASSWORD
Formatting 1st pool, 1 set(s), 4 drives per set.
WARNING: Host local has more than 2 drives of set. A host failure will result in data becoming unavailable.
WARNING: Detected default credentials 'minioadmin:minioadmin', we recommend that you change these values with 'MINIO_ROOT_USER' and 'MINIO_ROOT_PASSWORD' environment variables
```

1）老版本使用的MINIO_ACCESS_KEY 和 MINIO_SECRET_KEY不推荐使用，推荐使用MINIO_ROOT_USER 和MINIO_ROOT_PASSWORD设置账号和密码。

2）pool即minio节点组成的池子，当前有一个pool和4个硬盘组成的set集合

3）因为集合是4个硬盘，大于2的硬盘损坏数据将无法恢复。

4）账号和密码默认为minioadmin、minioadmin，可以在环境变量中设置通过'MINIO_ROOT_USER' and 'MINIO_ROOT_PASSWORD' 进行设置。

下边输入http://localhost:9000进行登录，账号和密码为：minioadmin/minioadmin

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTczODRiNDcxYTQwMTE3N2VmN2M4ZjlmMDMxNGI5YmVfaW9GTlk2dVZvTXA1REtHNXFqa1hLV3RST1BQdUV6VnZfVG9rZW46TlFSYmJ2ZG1xb0lEMEN4NjVCZ2MwN1labm5kXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

登录成功：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OWEyM2VhMjQ5YWZiNTI3OTEwODFhNmJjNGIzMmZiZDRfejlHZnFXUmR2aXptMTU1dzI2M3JPZDdXMjNDeHY4UHlfVG9rZW46RnFQN2JTNjhLb04yZGl4VUFVSmNTbVBabm1iXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

下一步创建bucket，桶，它相当于存储文件的目录，可以创建若干的桶。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419232.png)

输入bucket的名称，点击“CreateBucket”，创建成功

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419687.png)

点击“upload”上传文件。

下边上传几个文件 

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJhMGY0NGRjYTIyMDIzOWVlOTAzMTU5ZWZlYjc1ZWZfYU1iZXFBRzllMGFOWFdxNnRJT0M1dTVYcm5rV0R1dlRfVG9rZW46WnZXRWJQY2dQb2w2eUp4bmxiT2NlV1ZXbmZGXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

下边去四个目录观察文件的存储情况

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419638.png)

我们发现上传的1.mp4文件存储在了四个目录，即四个硬盘上。

下边测试minio的数据恢复过程：

1、首先删除一个目录。

删除目录后仍然可以在web控制台上传文件和下载文件。

稍等片刻删除的目录自动恢复。

2、删除两个目录。

删除两个目录也会自动恢复。

3、删除三个目录 。

由于 集合中共有4块硬盘，有大于一半的硬盘损坏数据无法恢复。

此时报错：We encountered an internal error, please try again.  (Read failed.  Insufficient number of drives online)在线驱动器数量不足。

### 3.2.3 测试Docker环境

开发阶段和生产阶段统一使用Docker下的MINIO。

在下发的虚拟机中已安装了MinIO的镜像和容器，执行sh /data/soft /restart.sh启动Docker下的MinIO

启动完成登录MinIO查看是否正常。

访问http://192.168.101.65:9000

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJiOTQwNWJmNDZhYTBiYTNiYTA5NjM2NjlkNGFmMDdfV3VrSVFKTTlDZXc1ak4wSzdVY0hIU2hnOENHZWV1UUlfVG9rZW46TmhPTGJhYTNKb3ZqWjF4SFE2OGN2S29VbmZmXzE3MzIzNDI3Njk6MTczMjM0NjM2OV9WNA)

本项目创建两个buckets：

mediafiles： 普通文件

video：视频文件

### 3.2.4 SDK

#### 3.2.4.1上传文件

MinIO提供多个语言版本SDK的支持，下边找到java版本的文档：

地址：https://docs.min.io/docs/java-client-quickstart-guide.html

最低需求Java 1.8或更高版本:

maven依赖如下：

```XML
<dependency>
    <groupId>io.minio</groupId>
    <artifactId>minio</artifactId>
    <version>8.4.3</version>
</dependency>
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>4.8.1</version>
</dependency>
```

在media-service工程添加此依赖。

参数说明：

需要三个参数才能连接到minio服务。

| 参数       | 说明                                         |
| ---------- | -------------------------------------------- |
| Endpoint   | 对象存储服务的URL                            |
| Access Key | Access key就像用户ID，可以唯一标识你的账户。 |
| Secret Key | Secret key是你账户的密码。                   |

 

官方的示例代码如下：

```Java
import io.minio.BucketExistsArgs;
import io.minio.MakeBucketArgs;
import io.minio.MinioClient;
import io.minio.UploadObjectArgs;
import io.minio.errors.MinioException;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
public class FileUploader {
  public static void main(String[] args)throws IOException, NoSuchAlgorithmException, InvalidKeyException {
    try {
      // Create a minioClient with the MinIO server playground, its access key and secret key.
      MinioClient minioClient =
          MinioClient.builder()
              .endpoint("https://play.min.io")
              .credentials("Q3AM3UQ867SPQQA43P2F", "zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG")
              .build();
      // Make 'asiatrip' bucket if not exist.
      boolean found =
          minioClient.bucketExists(BucketExistsArgs.builder().bucket("asiatrip").build());
      if (!found) {
        // Make a new bucket called 'asiatrip'.
        minioClient.makeBucket(MakeBucketArgs.builder().bucket("asiatrip").build());
      } else {
        System.out.println("Bucket 'asiatrip' already exists.");
      }
      // Upload '/home/user/Photos/asiaphotos.zip' as object name 'asiaphotos-2015.zip' to bucket
      // 'asiatrip'.
      minioClient.uploadObject(
          UploadObjectArgs.builder()
              .bucket("asiatrip")
              .object("asiaphotos-2015.zip")
              .filename("/home/user/Photos/asiaphotos.zip")
              .build());
      System.out.println(
          "'/home/user/Photos/asiaphotos.zip' is successfully uploaded as "
              + "object 'asiaphotos-2015.zip' to bucket 'asiatrip'.");
    } catch (MinioException e) {
      System.out.println("Error occurred: " + e);
      System.out.println("HTTP trace: " + e.httpTrace());
    }
  }
}
```

参考示例在media-service工程中 测试上传文件功能，

首先创建一个用于测试的bucket

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419529.png)

点击“Manage”修改bucket的访问权限

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419694.png)

选择public权限

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231419311.png)

在xuecheng-plus-media-service工程 的test下编写测试代码如下：

```Java
package com.xuecheng.media;

import io.minio.BucketExistsArgs;
import io.minio.MakeBucketArgs;
import io.minio.MinioClient;
import io.minio.UploadObjectArgs;
import io.minio.errors.MinioException;

import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

/**
 * @description 测试MinIO
 * @author Mr.M
 * @date 2022/9/11 21:24
 * @version 1.0
 */
public class MinioTest {

    static MinioClient minioClient =
            MinioClient.builder()
                    .endpoint("http://192.168.101.65:9000")
                    .credentials("minioadmin", "minioadmin")
                    .build();

   //上传文件
    @Test
    public  void upload() {
        try {
            UploadObjectArgs testbucket = UploadObjectArgs.builder()
                    .bucket("testbucket")
//                    .object("test001.mp4")
                    .object("001/test001.mp4")//添加子目录
                    .filename("D:\\develop\\upload\\1mp4.temp")
                    .contentType("video/mp4")//默认根据扩展名确定文件内容类型，也可以指定
                    .build();
            minioClient.uploadObject(testbucket);
            System.out.println("上传成功");
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("上传失败");
        }

    }

}
```

执行upload方法，分别测试向桶的根目录上传文件以及子目录上传文件。

上传成功，通过web控制台查看文件，并预览文件。

说明：

设置contentType可以通过com.j256.simplemagic.ContentType枚举类查看常用的mimeType（媒体类型）

通过扩展名得到mimeType，代码如下：

```Java
    //根据扩展名取出mimeType
    ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(".mp4");
    String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;//通用mimeType，字节流
```

完善上边的代码 如下：

```Java
@Test
    public  void upload() {
        //根据扩展名取出mimeType
        ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(".mp4");
        String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;//通用mimeType，字节流
        if(extensionMatch!=null){
            mimeType = extensionMatch.getMimeType();
        }
        try {
            UploadObjectArgs testbucket = UploadObjectArgs.builder()
                    .bucket("testbucket")
//                    .object("test001.mp4")
                    .object("001/test001.mp4")//添加子目录
                    .filename("D:\\develop\\upload\\1mp4.temp")
                    .contentType(mimeType)//默认根据扩展名确定文件内容类型，也可以指定
                    .build();
            minioClient.uploadObject(testbucket);
            System.out.println("上传成功");
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("上传失败");
        }

    }
```

#### 3.2.4.2 删除文件

下边测试删除文件

参考：https://docs.min.io/docs/java-client-api-reference#removeObject

```Java
@Test
public void delete(){
    try {
        minioClient.removeObject(
               RemoveObjectArgs.builder().bucket("testbucket").object("001/test001.mp4").build());
        System.out.println("删除成功");
    } catch (Exception e) {
       e.printStackTrace();
        System.out.println("删除失败");
    }
}
```

#### 3.2.4.3 查询文件

通过查询文件查看文件是否存在minio中。

参考：https://docs.min.io/docs/java-client-api-reference#getObject

```Java
//查询文件
@Test
public void getFile() {
    GetObjectArgs getObjectArgs = GetObjectArgs.builder().bucket("testbucket").object("test001.mp4").build();
    try(
        FilterInputStream inputStream = minioClient.getObject(getObjectArgs);
        FileOutputStream outputStream = new FileOutputStream(new File("D:\\develop\\upload\\1_2.mp4"));
     ) {
        IOUtils.copy(inputStream,outputStream);
     } catch (Exception e) {
        e.printStackTrace();
     }
}
```

校验文件的完整性，对文件计算出md5值，比较原始文件的md5和目标文件的md5，一致则说明完整

```Java
//校验文件的完整性对文件的内容进行md5
FileInputStream fileInputStream1 = new FileInputStream(new File("D:\\develop\\upload\\1.mp4"));
String source_md5 = DigestUtils.md5Hex(fileInputStream1);
FileInputStream fileInputStream = new FileInputStream(new File("D:\\develop\\upload\\1a.mp4"));
String local_md5 = DigestUtils.md5Hex(fileInputStream);
if(source_md5.equals(local_md5)){
    System.out.println("下载成功");
}
```







# **3、上传图片**

## **4.1 需求分析**

### 4.1.1 业务流程

课程图片是宣传课程非常重要的信息，在新增课程界面上传课程图片，也可以修改课程图片。

如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421423.png)

上传课程图片总体上包括两部分：

1、上传课程图片前端请求媒资管理服务将文件上传至分布式文件系统，并且在媒资管理数据库保存文件信息。

2、上传图片成功保存图片地址到课程基本信息表中。

详细流程如下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjFiYTM1NDNkNWYwMDhlZDUzMDE0MDFlNTI3OWFiMzhfZmVKRDcxWldySE5mY0RLU1ZxM0dweHB3blpZdVdJSFlfVG9rZW46QnptTWJ0UzB3b2ptSk14OWM4YmNtSXZ4bmVkXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

1、前端进入上传图片界面

2、上传图片，请求媒资管理服务。

3、媒资管理服务将图片文件存储在MinIO。

4、媒资管理记录文件信息到数据库。

5、前端请求内容管理服务保存课程信息，在内容管理数据库保存图片地址。

### 4.1.2 数据模型

涉及到的数据表有：课程信息表中的图片字段、媒资数据库的文件表，下边主要看媒资数据库的文件表。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjU1YTJhNDMxOGY0NTQ0Zjk5N2NjNWFkZGZhZjdlNmZfclVPMU5HaDJPVkN4OUpQSkk3ZWFKak1MUDRkMXpqOUdfVG9rZW46RTVQV2JRMWlib2Rva2h4VXdNMmNvVjZXbnNnXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

各字段描述如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421505.png)

## 4.2 准备环境

首先在minio配置bucket，bucket名称为：mediafiles，并设置bucket的权限为公开。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQ5YzVmM2FmN2I5YWY2ZWU2NDYyZTUxMWUwYmE2YjVfRWVOR0ZkakFYczAybENQbU95VjlrM1Z2aGR0T09ZM2ZfVG9rZW46TVFLSmJTdE9Nb1RHWTh4NW56T2M4czRxbmY5XzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

在nacos配置中minio的相关信息，进入media-service-dev.yaml:

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y5NzE2ZDUyNWIyZjBiNjM1MjZjY2Q3YTc0NGU2ZjlfbGlKeU9vRmhSNEcwU2pjQkZXbzlZSndZMENjUzBDdHVfVG9rZW46TGdDRGJic3BRb29BVDZ4SVd3ZmNmQ1hIbjBlXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

配置信息如下：

```YAML
minio:
  endpoint: http://192.168.101.65:9000
  accessKey: minioadmin
  secretKey: minioadmin
  bucket:
    files: mediafiles
    videofiles: video
```

在media-service工程编写minio的配置类：

```Java
package com.xuecheng.media.config;

import io.minio.MinioClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @description minio配置
 * @author Mr.M
 * @date 2022/9/12 19:32
 * @version 1.0
 */
 @Configuration
public class MinioConfig {


 @Value("${minio.endpoint}")
 private String endpoint;
 @Value("${minio.accessKey}")
 private String accessKey;
 @Value("${minio.secretKey}")
 private String secretKey;

 @Bean
 public MinioClient minioClient() {

  MinioClient minioClient =
          MinioClient.builder()
                  .endpoint(endpoint)
                  .credentials(accessKey, secretKey)
                  .build();
  return minioClient;
 }
}
```

## 4.3 接口定义

根据需求分析，下边进行接口定义，此接口定义为一个通用的上传文件接口，可以上传图片或其它文件。

首先分析接口：

请求地址：/media/upload/coursefile

请求内容：**Content-Type:** multipart/form-data;

form-data; name="filedata"; filename="具体的文件名称"

响应参数：文件信息，如下

```JSON
{
  "id": "a16da7a132559daf9e1193166b3e7f52",
  "companyId": 1232141425,
  "companyName": null,
  "filename": "1.jpg",
  "fileType": "001001",
  "tags": "",
  "bucket": "/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg",
  "fileId": "a16da7a132559daf9e1193166b3e7f52",
  "url": "/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg",
  "timelength": null,
  "username": null,
  "createDate": "2022-09-12T21:57:18",
  "changeDate": null,
  "status": "1",
  "remark": "",
  "auditStatus": null,
  "auditMind": null,
  "fileSize": 248329
}
```

定义上传响应模型类：

```Java
package com.xuecheng.media.model.dto;

import com.xuecheng.media.model.po.MediaFiles;
import lombok.Data;
import lombok.ToString;

/**
 * @description 上传普通文件成功响应结果
 * @author Mr.M
 * @date 2022/9/12 18:49
 * @version 1.0
 */
 @Data
public class UploadFileResultDto extends MediaFiles {
  

}
```

定义接口如下：

```Java
@ApiOperation("上传文件")
@RequestMapping(value = "/upload/coursefile", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public UploadFileResultDto upload(@RequestPart("filedata") MultipartFile upload) throws IOException {

    return null;
}
```

接口定义好后可以用httpclient工具测试一下

使用httpclient测试

```Java
### 上传文件
POST {{media_host}}/media/upload/coursefile
Content-Type: multipart/form-data; boundary=WebAppBoundary

--WebAppBoundary
Content-Disposition: form-data; name="filedata"; filename="1.jpg"
Content-Type: application/octet-stream

< d:/develop/upload/1.jpg
```

## 4.4 接口开发

### 4.4.1 DAO开发

根据需求分析DAO层实现向media_files表插入一条记录，使用media_files表生成的mapper即可。

### 4.4.2 Service开发

Service方法需要提供一个更加通用的保存文件的方法。

定义请求参数类：

```Java
package com.xuecheng.media.model.dto;

import com.xuecheng.media.model.po.MediaFiles;
import lombok.Data;
import lombok.ToString;

/**
 * @description 上传普通文件请求参数
 * @author Mr.M
 * @date 2022/9/12 18:49
 * @version 1.0
 */
 @Data
public class UploadFileParamsDto {

 /**
  * 文件名称
  */
 private String filename;


 /**
  * 文件类型（文档，音频，视频）
  */
 private String fileType;
 /**
  * 文件大小
  */
 private Long fileSize;

 /**
  * 标签
  */
 private String tags;

 /**
  * 上传人
  */
 private String username;

 /**
  * 备注
  */
 private String remark;



}
```

定义service方法：

```Java
/**
 * 上传文件
 * @param companyId 机构id
 * @param uploadFileParamsDto 上传文件信息
 * @param localFilePath 文件磁盘路径
 * @return 文件信息
 */
public UploadFileResultDto uploadFile(Long companyId, UploadFileParamsDto uploadFileParamsDto, String localFilePath);
```

实现方法如下：

```Java
@Autowired
MinioClient minioClient;

@Autowired
MediaFilesMapper mediaFilesMapper;

//普通文件桶
@Value("${minio.bucket.files}")
private String bucket_Files;


//获取文件默认存储目录路径 年/月/日
private String getDefaultFolderPath() {
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    String folder = sdf.format(new Date()).replace("-", "/")+"/";
    return folder;
}

//获取文件的md5
private String getFileMd5(File file) {
    try (FileInputStream fileInputStream = new FileInputStream(file)) {
        String fileMd5 = DigestUtils.md5Hex(fileInputStream);
        return fileMd5;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}


private String getMimeType(String extension){
    if(extension==null)
        extension = "";
    //根据扩展名取出mimeType
    ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(extension);
    //通用mimeType，字节流
    String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;
    if(extensionMatch!=null){
        mimeType = extensionMatch.getMimeType();
    }
    return mimeType;
}
/**
 * @description 将文件写入minIO
 * @param localFilePath  文件地址
 * @param bucket  桶
 * @param objectName 对象名称
 * @return void
 * @author Mr.M
 * @date 2022/10/12 21:22
 */
public boolean addMediaFilesToMinIO(String localFilePath,String mimeType,String bucket, String objectName) {
    try {
        UploadObjectArgs testbucket = UploadObjectArgs.builder()
                .bucket(bucket)
                .object(objectName)
                .filename(localFilePath)
                .contentType(mimeType)
                .build();
        minioClient.uploadObject(testbucket);
        log.debug("上传文件到minio成功,bucket:{},objectName:{}",bucket,objectName);
        System.out.println("上传成功");
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        log.error("上传文件到minio出错,bucket:{},objectName:{},错误原因:{}",bucket,objectName,e.getMessage(),e);
        XueChengPlusException.cast("上传文件到文件系统失败");
    }
    return false;
}

/**
 * @description 将文件信息添加到文件表
 * @param companyId  机构id
 * @param fileMd5  文件md5值
 * @param uploadFileParamsDto  上传文件的信息
 * @param bucket  桶
 * @param objectName 对象名称
 * @return com.xuecheng.media.model.po.MediaFiles
 * @author Mr.M
 * @date 2022/10/12 21:22
 */
@Transactional
public MediaFiles addMediaFilesToDb(Long companyId,String fileMd5,UploadFileParamsDto uploadFileParamsDto,String bucket,String objectName){
    //从数据库查询文件
    MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5);
    if (mediaFiles == null) {
        mediaFiles = new MediaFiles();
        //拷贝基本信息
        BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);
        mediaFiles.setId(fileMd5);
        mediaFiles.setFileId(fileMd5);
        mediaFiles.setCompanyId(companyId);
        mediaFiles.setUrl("/" + bucket + "/" + objectName);
        mediaFiles.setBucket(bucket);
        mediaFiles.setFilePath(objectName);
        mediaFiles.setCreateDate(LocalDateTime.now());
        mediaFiles.setAuditStatus("002003");
        mediaFiles.setStatus("1");
        //保存文件信息到文件表
        int insert = mediaFilesMapper.insert(mediaFiles);
        if (insert < 0) {
            log.error("保存文件信息到数据库失败,{}",mediaFiles.toString());
            XueChengPlusException.cast("保存文件信息失败");
        }
        log.debug("保存文件信息到数据库成功,{}",mediaFiles.toString());

    }
    return mediaFiles;

}
@Transactional
@Override
public UploadFileResultDto uploadFile(Long companyId, UploadFileParamsDto uploadFileParamsDto, String localFilePath) {
    File file = new File(localFilePath);
    if (!file.exists()) {
        XueChengPlusException.cast("文件不存在");
    }
    //文件名称
    String filename = uploadFileParamsDto.getFilename();
    //文件扩展名
    String extension = filename.substring(filename.lastIndexOf("."));
    //文件mimeType
    String mimeType = getMimeType(extension);
    //文件的md5值
    String fileMd5 = getFileMd5(file);
    //文件的默认目录
    String defaultFolderPath = getDefaultFolderPath();
    //存储到minio中的对象名(带目录)
    String  objectName = defaultFolderPath + fileMd5 + exension;
    //将文件上传到minio
    boolean b = addMediaFilesToMinIO(localFilePath, mimeType, bucket_files, objectName);
    //文件大小
    uploadFileParamsDto.setFileSize(file.length());
    //将文件信息存储到数据库
    MediaFiles mediaFiles = addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucket_files, objectName);
    //准备返回数据
    UploadFileResultDto uploadFileResultDto = new UploadFileResultDto();
    BeanUtils.copyProperties(mediaFiles, uploadFileResultDto);
    return uploadFileResultDto;

}
```

### 4.4.3 完善接口层

完善接口层代码 ：

```Java
@ApiOperation("上传文件")
@RequestMapping(value = "/upload/coursefile",consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
@ResponseBody
public UploadFileResultDto upload(@RequestPart("filedata") MultipartFile upload,@RequestParam(value = "folder",required=false) String folder,@RequestParam(value = "objectName",required=false) String objectName) throws IOException {

        Long companyId = 1232141425L;
    UploadFileParamsDto uploadFileParamsDto = new UploadFileParamsDto();
    //文件大小
    uploadFileParamsDto.setFileSize(filedata.getSize());
    //图片
    uploadFileParamsDto.setFileType("001001");
    //文件名称
    uploadFileParamsDto.setFilename(filedata.getOriginalFilename());//文件名称
    //文件大小
    long fileSize = filedata.getSize();
    uploadFileParamsDto.setFileSize(fileSize);
    //创建临时文件
    File tempFile = File.createTempFile("minio", "temp");
    //上传的文件拷贝到临时文件
    filedata.transferTo(tempFile);
    //文件路径
    String absolutePath = tempFile.getAbsolutePath();
    //上传文件
    UploadFileResultDto uploadFileResultDto = mediaFileService.uploadFile(companyId, uploadFileParamsDto, absolutePath);
    
    return uploadFileResultDto;
}
```

### 4.4.4 接口测试

1、首先使用httpclient测试

```Java
### 上传文件
POST {{media_host}}/media/upload/coursefile
Content-Type: multipart/form-data; boundary=WebAppBoundary

--WebAppBoundary
Content-Disposition: form-data; name="filedata"; filename="1.jpg"
Content-Type: application/octet-stream

< d:/develop/upload/1.jpg
```

2、再进行前后端联调测试

在新增课程、编辑课程界面上传图，保存课程信息后再次进入编辑课程界面，查看是否可以正常保存课程图片信息。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTA1MzI4MTM2Zjc1OTBlYjFlZGEzMmEwMWYxMDQ2ZTBfeldwdXcyYmxpWG14eXpyU01jMk1wRnI3VUFsMjExUkdfVG9rZW46UGIxcmJwR0Vnb3RQQnN4QktyeGMyMGVxbnZnXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

上图图片完成后，进入媒资管理，查看文件列表中是否有刚刚上传的图片信息。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421829.png)

### 4.4.5 Service事务优化

上边的service方法优化后并测试通过，现在思考关于uploadFile方法的是否应该开启事务。

目前是在uploadFile方法上添加@Transactional，当调用uploadFile方法前会开启数据库事务，如果上传文件过程时间较长那么数据库的事务持续时间就会变长，这样数据库链接释放就慢，最终导致数据库链接不够用。

我们只将addMediaFilesToDb方法添加事务控制即可,uploadFile方法上的@Transactional注解去掉。

优化后如下：

```Java
@Transactional
public MediaFiles addMediaFilesToDb(Long companyId,String fileMd5,UploadFileParamsDto uploadFileParamsDto,String bucket,String objectName){

   //从数据库查询文件
MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5);
if (mediaFiles == null) {
    mediaFiles = new MediaFiles();
    //拷贝基本信息
    BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);
    mediaFiles.setId(fileMd5);
    mediaFiles.setFileId(fileMd5);
    mediaFiles.setCompanyId(companyId);
    mediaFiles.setUrl("/" + bucket + "/" + objectName);
    mediaFiles.setBucket(bucket);
    mediaFiles.setFilePath(objectName);
    mediaFiles.setCreateDate(LocalDateTime.now());
    mediaFiles.setAuditStatus("002003");
    mediaFiles.setStatus("1");
    //保存文件信息到文件表
    int insert = mediaFilesMapper.insert(mediaFiles);
    if (insert < 0) {
        log.error("保存文件信息到数据库失败,{}",mediaFiles.toString());
        XueChengPlusException.cast("保存文件信息失败");
    }
    log.debug("保存文件信息到数据库成功,{}",mediaFiles.toString());

}
return mediaFiles;

}
```

我们人为在int insert = mediaFilesMapper.insert(mediaFiles);下边添加一个异常代码int a=1/0;

测试是否事务控制。很遗憾，事务控制失败。

方法上已经添加了@Transactional注解为什么该方法不能被事务控制呢？

如果是在uploadFile方法上添加@Transactional注解就可以控制事务，去掉则不行。

现在的问题其实是一个非事务方法调同类一个事务方法，事务无法控制，这是为什么？

下边分析原因：

如果在uploadFile方法上添加@Transactional注解，代理对象执行此方法前会开启事务，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421769.png)

如果在uploadFile方法上没有@Transactional注解，代理对象执行此方法前不进行事务控制，如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=M2MxMjc1ZTVjMGM2ZDE2MWE0ZGRiZDcxY2YzYzQ2M2FfYU9QdzJJQ2c4TE9RU2psVDR4QlI4SjNSeGRVUUVsQnVfVG9rZW46RDVXT2JSdVdzb2lzUDV4QXlyOGNSaW1CbjRmXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

所以判断该方法是否可以事务控制必须保证是通过代理对象调用此方法，且此方法上添加了@Transactional注解。

现在在addMediaFilesToDb方法上添加@Transactional注解，也不会进行事务控制是因为并不是通过代理对象执行的addMediaFilesToDb方法。为了判断在uploadFile方法中去调用addMediaFilesToDb方法是否是通过代理对象去调用，我们可以打断点跟踪。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421108.png)

我们发现在uploadFile方法中去调用addMediaFilesToDb方法不是通过代理对象去调用。

如何解决呢？通过代理对象去调用addMediaFilesToDb方法即可解决。

在MediaFileService的实现类中注入MediaFileService的代理对象，如下：

```Java
@Autowired
MediaFileService currentProxy;
```

将addMediaFilesToDb方法提成接口。

```Java
/**
 * @description 将文件信息添加到文件表
 * @param companyId  机构id
 * @param fileMd5  文件md5值
 * @param uploadFileParamsDto  上传文件的信息
 * @param bucket  桶
 * @param objectName 对象名称
 * @return com.xuecheng.media.model.po.MediaFiles
 * @author Mr.M
 * @date 2022/10/12 21:22
 */

public MediaFiles addMediaFilesToDb(Long companyId,String fileMd5,UploadFileParamsDto uploadFileParamsDto,String bucket,String objectName);
```

调用addMediaFilesToDb方法的代码处改为如下：

```Java
.....
//写入文件表
MediaFiles mediaFiles = currentProxy.addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucket_files, objectName);
 ....
```

再次测试事务是否可以正常控制。

# **4、上传视频**

## **5.1 需求分析**

1、教学机构人员进入媒资管理列表查询自己上传的媒资文件。

点击“媒资管理”

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQxNzM2NWQxNmI4MGE1ZDllODE1NGQyNjY2YTg1ZmZfcmxjdDR4WVpaQUljNEIweTBJd3VoR29DZzdVWVhMc3lfVG9rZW46WW5ocWJsVnZvb1RIYzN4V2hDYWNKT3RrbmNiXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

进入媒资管理列表页面查询本机构上传的媒资文件。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc3ZDAxYTIyM2MwMWI3MDU2MjIzNTg5ZjVjMzUxNmNfaG43Qjl6MFRZWGtzODV3TllVYjRzbVdQUHdzeUZyUnVfVG9rZW46QkFvTmJJRkY1b3dsVmF4T2ZWMmNLQ1pkbk5mXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

2、教育机构用户在"媒资管理"页面中点击 "上传视频" 按钮。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTcxNThlOTkwYWFmNjI3ZTZmYzVlYmY3YjgyY2YyMTlfOWVJSDdYN3BrM0I0UFVodml1UHI0d1pqekM3MEhidnZfVG9rZW46RnVpeGI4Vk1ib1p1Z254VHppbGN3R2NVbjZlXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

点击“上传视频”打开上传页面

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421187.png)

3、选择要上传的文件，自动执行文件上传。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNjZTY0MWY5OTEzMTMxYmNiOWVkZmJkMDYzNWE5N2VfVlhweXdyTzQzckdYUzBLM1lNYU9rT1A3QlQxSDExbUJfVG9rZW46VHdVUGIxb2JVb3VIbnF4MHl4WWNWWEV2bmJlXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

4、视频上传成功会自动处理，处理完成可以预览视频。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421585.png)

## 5.2 断点续传技术

### 5.2.1 什么是断点续传

通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足大文件的上传要求。http协议本身对上传文件大小没有限制，但是客户的网络环境质量、电脑硬件环境等参差不齐，如果一个大文件快上传完了网断了没有上传完成，需要客户重新上传，用户体验非常差，所以对于大文件上传的要求最基本的是断点续传。

什么是断点续传：

​        引用百度百科：断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载，断点续传可以提高节省操作时间，提高用户体验性。

断点续传流程如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421870.png)

流程如下：

1、前端上传前先把文件分成块

2、一块一块的上传，上传中断后重新上传，已上传的分块则不用再上传

3、各分块上传完成最后在服务端合并文件

### 5.2.2 分块与合并测试

为了更好的理解文件分块上传的原理，下边用java代码测试文件的分块与合并。

文件分块的流程如下：

1、获取源文件长度

2、根据设定的分块文件的大小计算出块数

3、从源文件读数据依次向每一个块文件写数据。

测试代码如下：

```Java
package com.xuecheng.media;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.IOUtils;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.*;

/**
 * @author Mr.M
 * @version 1.0
 * @description 大文件处理测试
 * @date 2022/9/13 9:21
 */
public class BigFileTest {


    //测试文件分块方法
    @Test
    public void testChunk() throws IOException {
        File sourceFile = new File("d:/develop/bigfile_test/nacos.mp4");
        String chunkPath = "d:/develop/bigfile_test/chunk/";
        File chunkFolder = new File(chunkPath);
        if (!chunkFolder.exists()) {
            chunkFolder.mkdirs();
        }
        //分块大小
        long chunkSize = 1024 * 1024 * 1;
        //分块数量
        long chunkNum = (long) Math.ceil(sourceFile.length() * 1.0 / chunkSize);
        System.out.println("分块总数："+chunkNum);
        //缓冲区大小
        byte[] b = new byte[1024];
        //使用RandomAccessFile访问文件
        RandomAccessFile raf_read = new RandomAccessFile(sourceFile, "r");
        //分块
        for (int i = 0; i < chunkNum; i++) {
            //创建分块文件
            File file = new File(chunkPath + i);
            if(file.exists()){
                file.delete();
            }
            boolean newFile = file.createNewFile();
            if (newFile) {
                //向分块文件中写数据
                RandomAccessFile raf_write = new RandomAccessFile(file, "rw");
                int len = -1;
                while ((len = raf_read.read(b)) != -1) {
                    raf_write.write(b, 0, len);
                    if (file.length() >= chunkSize) {
                        break;
                    }
                }
                raf_write.close();
                System.out.println("完成分块"+i);
            }

        }
        raf_read.close();

    }


   

}
```

文件合并流程：

1、找到要合并的文件并按文件合并的先后进行排序。

2、创建合并文件

3、依次从合并的文件中读取数据向合并文件写入数

文件合并的测试代码 ：

```Java
 //测试文件合并方法
    @Test
    public void testMerge() throws IOException {
        //块文件目录
        File chunkFolder = new File("d:/develop/bigfile_test/chunk/");
        //原始文件
        File originalFile = new File("d:/develop/bigfile_test/nacos.mp4");
        //合并文件
        File mergeFile = new File("d:/develop/bigfile_test/nacos01.mp4");
        if (mergeFile.exists()) {
            mergeFile.delete();
        }
        //创建新的合并文件
        mergeFile.createNewFile();
        //用于写文件
        RandomAccessFile raf_write = new RandomAccessFile(mergeFile, "rw");
        //指针指向文件顶端
        raf_write.seek(0);
        //缓冲区
        byte[] b = new byte[1024];
        //分块列表
        File[] fileArray = chunkFolder.listFiles();
        // 转成集合，便于排序
        List<File> fileList = Arrays.asList(fileArray);
        // 从小到大排序
        Collections.sort(fileList, new Comparator<File>() {
            @Override
            public int compare(File o1, File o2) {
                return Integer.parseInt(o1.getName()) - Integer.parseInt(o2.getName());
            }
        });
        //合并文件
        for (File chunkFile : fileList) {
            RandomAccessFile raf_read = new RandomAccessFile(chunkFile, "rw");
            int len = -1;
            while ((len = raf_read.read(b)) != -1) {
                raf_write.write(b, 0, len);

            }
            raf_read.close();
        }
        raf_write.close();

        //校验文件
        try (

                FileInputStream fileInputStream = new FileInputStream(originalFile);
                FileInputStream mergeFileStream = new FileInputStream(mergeFile);

        ) {
            //取出原始文件的md5
            String originalMd5 = DigestUtils.md5Hex(fileInputStream);
            //取出合并文件的md5进行比较
            String mergeFileMd5 = DigestUtils.md5Hex(mergeFileStream);
            if (originalMd5.equals(mergeFileMd5)) {
                System.out.println("合并文件成功");
            } else {
                System.out.println("合并文件失败");
            }

        }


    }
```

### 5.2.3 视频上传流程

下图是上传视频的整体流程：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421345.png)

1、前端对文件进行分块。

2、前端上传分块文件前请求媒资服务检查文件是否存在，如果已经存在则不再上传。

3、如果分块文件不存在则前端开始上传

4、前端请求媒资服务上传分块。

5、媒资服务将分块上传至MinIO。

6、前端将分块上传完毕请求媒资服务合并分块。

7、媒资服务判断分块上传完成则请求MinIO合并文件。

8、合并完成校验合并后的文件是否完整，如果完整则上传完成，否则删除文件。

### 5.2.4 minio合并文件测试

1、将分块文件上传至minio

```Java
//将分块文件上传至minio
@Test
public void uploadChunk(){
    String chunkFolderPath = "D:\\develop\\upload\\chunk\\";
    File chunkFolder = new File(chunkFolderPath);
    //分块文件
    File[] files = chunkFolder.listFiles();
    //将分块文件上传至minio
    for (int i = 0; i < files.length; i++) {
        try {
           UploadObjectArgs uploadObjectArgs = UploadObjectArgs.builder().bucket("testbucket").object("chunk/" + i).filename(files[i].getAbsolutePath()).build();
            minioClient.uploadObject(uploadObjectArgs);
            System.out.println("上传分块成功"+i);
        } catch (Exception e) {
          e.printStackTrace();
        }
    }

}
```

2、通过minio的合并文件

```Java
//合并文件，要求分块文件最小5M
@Test
public void test_merge() throws Exception {
    List<ComposeSource> sources = Stream.iterate(0, i -> ++i)
            .limit(6)
            .map(i -> ComposeSource.builder()
                    .bucket("testbucket")
                    .object("chunk/".concat(Integer.toString(i)))
                    .build())
            .collect(Collectors.toList());

    ComposeObjectArgs composeObjectArgs = ComposeObjectArgs.builder().bucket("testbucket").object("merge01.mp4").sources(sources).build();
    minioClient.composeObject(composeObjectArgs);

}
//清除分块文件
@Test
public void test_removeObjects(){
    //合并分块完成将分块文件清除
    List<DeleteObject> deleteObjects = Stream.iterate(0, i -> ++i)
            .limit(6)
            .map(i -> new DeleteObject("chunk/".concat(Integer.toString(i))))
            .collect(Collectors.toList());

    RemoveObjectsArgs removeObjectsArgs = RemoveObjectsArgs.builder().bucket("testbucket").objects(deleteObjects).build();
    Iterable<Result<DeleteError>> results = minioClient.removeObjects(removeObjectsArgs);
    results.forEach(r->{
        DeleteError deleteError = null;
        try {
            deleteError = r.get();
        } catch (Exception e) {
            e.printStackTrace();
        }
    });
}
```

使用minio合并文件报错：java.lang.IllegalArgumentException: source testbucket/chunk/0: size 1048576 must be greater than 5242880

minio合并文件默认分块最小5M，我们将分块改为5M再次测试。

## 5.3 接口定义

根据上传视频流程，定义接口，与前端的约定是操作成功返回{code:0}否则返回{code:-1}

从课程资料中拷贝RestResponse.java类到base工程下的model包下。

定义接口如下：

```Java
package com.xuecheng.media.api;

import com.j256.simplemagic.ContentInfo;
import com.j256.simplemagic.ContentInfoUtil;
import com.xuecheng.base.model.RestResponse;
import com.xuecheng.media.model.dto.UploadFileParamsDto;
import com.xuecheng.media.service.MediaFileService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

/**
 * @author Mr.M
 * @version 1.0
 * @description 大文件上传接口
 * @date 2022/9/6 11:29
 */
@Api(value = "大文件上传接口", tags = "大文件上传接口")
@RestController
public class BigFilesController {



    @ApiOperation(value = "文件上传前检查文件")
    @PostMapping("/upload/checkfile")
    public RestResponse<Boolean> checkfile(
            @RequestParam("fileMd5") String fileMd5
    ) throws Exception {
        return null;
    }


    @ApiOperation(value = "分块文件上传前的检测")
    @PostMapping("/upload/checkchunk")
    public RestResponse<Boolean> checkchunk(@RequestParam("fileMd5") String fileMd5,
                                            @RequestParam("chunk") int chunk) throws Exception {
       return null;
    }

    @ApiOperation(value = "上传分块文件")
    @PostMapping("/upload/uploadchunk")
    public RestResponse uploadchunk(@RequestParam("file") MultipartFile file,
                                    @RequestParam("fileMd5") String fileMd5,
                                    @RequestParam("chunk") int chunk) throws Exception {

        return null;
    }

    @ApiOperation(value = "合并文件")
    @PostMapping("/upload/mergechunks")
    public RestResponse mergechunks(@RequestParam("fileMd5") String fileMd5,
                                    @RequestParam("fileName") String fileName,
                                    @RequestParam("chunkTotal") int chunkTotal) throws Exception {
        return null;

    }


}
```

## 5.4 上传分块开发

### 5.4.1 DAO开发

向媒资数据库的文件表插入记录，使用自动生成的Mapper接口即可满足要求。

### 5.4.2 Service开发

#### 5.4.2.1 检查文件和分块

接口完成进行接口实现，首先实现检查文件方法和检查分块方法。

在MediaFileService中定义service接口如下：

```Java
/**
 * @description 检查文件是否存在
 * @param fileMd5 文件的md5
 * @return com.xuecheng.base.model.RestResponse<java.lang.Boolean> false不存在，true存在
 * @author Mr.M
 * @date 2022/9/13 15:38
*/
public RestResponse<Boolean> checkFile(String fileMd5);

/**
 * @description 检查分块是否存在
 * @param fileMd5  文件的md5
 * @param chunkIndex  分块序号
 * @return com.xuecheng.base.model.RestResponse<java.lang.Boolean> false不存在，true存在
 * @author Mr.M
 * @date 2022/9/13 15:39
*/
public RestResponse<Boolean> checkChunk(String fileMd5, int chunkIndex);
```

service接口实现方法：

```Java
@Override
public RestResponse<Boolean> checkFile(String fileMd5) {
    //查询文件信息
    MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5);
    if (mediaFiles != null) {
        //桶
        String bucket = mediaFiles.getBucket();
        //存储目录
        String filePath = mediaFiles.getFilePath();
        //文件流
        InputStream stream = null;
        try {
            stream = minioClient.getObject(
                    GetObjectArgs.builder()
                            .bucket(bucket)
                            .object(filePath)
                            .build());

            if (stream != null) {
                //文件已存在
                return RestResponse.success(true);
            }
        } catch (Exception e) {
           
        }
    }
    //文件不存在
    return RestResponse.success(false);
}



@Override
public RestResponse<Boolean> checkChunk(String fileMd5, int chunkIndex) {

    //得到分块文件目录
    String chunkFileFolderPath = getChunkFileFolderPath(fileMd5);
    //得到分块文件的路径
    String chunkFilePath = chunkFileFolderPath + chunkIndex;

    //文件流
    InputStream fileInputStream = null;
    try {
        fileInputStream = minioClient.getObject(
                GetObjectArgs.builder()
                        .bucket(bucket_videoFiles)
                        .object(chunkFilePath)
                        .build());

        if (fileInputStream != null) {
            //分块已存在
            return RestResponse.success(true);
        }
    } catch (Exception e) {
        
    }
    //分块未存在
    return RestResponse.success(false);
}

//得到分块文件的目录
private String getChunkFileFolderPath(String fileMd5) {
    return fileMd5.substring(0, 1) + "/" + fileMd5.substring(1, 2) + "/" + fileMd5 + "/" + "chunk" + "/";
}
```

#### 5.4.2.2 上传分块

定义service接口

```Java
/**
 * @description 上传分块
 * @param fileMd5  文件md5
 * @param chunk  分块序号
 * @param localChunkFilePath  分块文件本地路径
 * @return com.xuecheng.base.model.RestResponse
 * @author Mr.M
 * @date 2022/9/13 15:50
 */
public RestResponse uploadChunk(String fileMd5,int chunk,String localChunkFilePath);
```

接口实现：

```Java
@Override
public RestResponse uploadChunk(String fileMd5, int chunk, String localChunkFilePath) {

    //得到分块文件的目录路径
    String chunkFileFolderPath = getChunkFileFolderPath(fileMd5);
    //得到分块文件的路径
    String chunkFilePath = chunkFileFolderPath + chunk;
    //mimeType
    String mimeType = getMimeType(null);
    //将文件存储至minIO
    boolean b = addMediaFilesToMinIO(localChunkFilePath, mimeType, bucket_videoFiles, chunkFilePath);
    if (!b) {
        log.debug("上传分块文件失败:{}", chunkFilePath);
        return RestResponse.validfail(false, "上传分块失败");
    }
    log.debug("上传分块文件成功:{}",chunkFilePath);
    return RestResponse.success(true);

}
```

#### 5.4.2.3 上传分块测试

完善接口层：

```Java
@ApiOperation(value = "文件上传前检查文件")
@PostMapping("/upload/checkfile")
public RestResponse<Boolean> checkfile(
        @RequestParam("fileMd5") String fileMd5
) throws Exception {
    return mediaFileService.checkFile(fileMd5);
}


@ApiOperation(value = "分块文件上传前的检测")
@PostMapping("/upload/checkchunk")
public RestResponse<Boolean> checkchunk(@RequestParam("fileMd5") String fileMd5,
                                        @RequestParam("chunk") int chunk) throws Exception {
    return mediaFileService.checkChunk(fileMd5,chunk);
}

@ApiOperation(value = "上传分块文件")
@PostMapping("/upload/uploadchunk")
public RestResponse uploadchunk(@RequestParam("file") MultipartFile file,
                                @RequestParam("fileMd5") String fileMd5,
                                @RequestParam("chunk") int chunk) throws Exception {

    //创建临时文件
    File tempFile = File.createTempFile("minio", "temp");
    //上传的文件拷贝到临时文件
    file.transferTo(tempFile);
    //文件路径
    String absolutePath = tempFile.getAbsolutePath();
    return mediaFileService.uploadChunk(fileMd5,chunk,absolutePath);
}
```

启动前端工程，进入上传视频界面进行前后端联调测试。

前端对文件分块的大小为5MB，SpringBoot web默认上传文件的大小限制为1MB，这里需要在media-api工程修改配置如下：

```Python
spring:
  servlet:
    multipart:
      max-file-size: 50MB
      max-request-size: 50MB
```

max-file-size：单个文件的大小限制

Max-request-size: 单次请求的大小限制

## 5.5 合并分块开发

### 5.5.1 service开发

定义service接口：

```Java
/**
 * @description 合并分块
 * @param companyId  机构id
 * @param fileMd5  文件md5
 * @param chunkTotal 分块总和
 * @param uploadFileParamsDto 文件信息
 * @return com.xuecheng.base.model.RestResponse
 * @author Mr.M
 * @date 2022/9/13 15:56
 */
public RestResponse mergechunks(Long companyId,String fileMd5,int chunkTotal,UploadFileParamsDto uploadFileParamsDto);
```

service实现：

```Java
@Override
public RestResponse mergechunks(Long companyId, String fileMd5, int chunkTotal, UploadFileParamsDto uploadFileParamsDto) {
    //=====获取分块文件路径=====
    String chunkFileFolderPath = getChunkFileFolderPath(fileMd5);
    //组成将分块文件路径组成 List<ComposeSource>
    List<ComposeSource> sourceObjectList = Stream.iterate(0, i -> ++i)
            .limit(chunkTotal)
            .map(i -> ComposeSource.builder()
                    .bucket(bucket_videoFiles)
                    .object(chunkFileFolderPath.concat(Integer.toString(i)))
                    .build())
            .collect(Collectors.toList());
    //=====合并=====
    //文件名称
    String fileName = uploadFileParamsDto.getFilename();
    //文件扩展名
    String extName = fileName.substring(fileName.lastIndexOf("."));
    //合并文件路径
    String mergeFilePath = getFilePathByMd5(fileMd5, extName);
    try {
        //合并文件
        ObjectWriteResponse response = minioClient.composeObject(
                ComposeObjectArgs.builder()
                        .bucket(bucket_videoFiles)
                        .object(mergeFilePath)
                        .sources(sourceObjectList)
                        .build());
        log.debug("合并文件成功:{}",mergeFilePath);
    } catch (Exception e) {
        log.debug("合并文件失败,fileMd5:{},异常:{}",fileMd5,e.getMessage(),e);
        return RestResponse.validfail(false, "合并文件失败。");
    }

    // ====验证md5====
    //下载合并后的文件
    File minioFile = downloadFileFromMinIO(bucket_videoFiles,mergeFilePath);
    if(minioFile == null){
        log.debug("下载合并后文件失败,mergeFilePath:{}",mergeFilePath);
        return RestResponse.validfail(false, "下载合并后文件失败。");
    }

    try (InputStream newFileInputStream = new FileInputStream(minioFile)) {
        //minio上文件的md5值
        String md5Hex = DigestUtils.md5Hex(newFileInputStream);
        //比较md5值，不一致则说明文件不完整
        if(!fileMd5.equals(md5Hex)){
            return RestResponse.validfail(false, "文件合并校验失败，最终上传失败。");
        }
        //文件大小
        uploadFileParamsDto.setFileSize(minioFile.length());
    }catch (Exception e){
        log.debug("校验文件失败,fileMd5:{},异常:{}",fileMd5,e.getMessage(),e);
        return RestResponse.validfail(false, "文件合并校验失败，最终上传失败。");
    }finally {
       if(minioFile!=null){
           minioFile.delete();
       }
    }

    //文件入库
    currentProxy.addMediaFilesToDb(companyId,fileMd5,uploadFileParamsDto,bucket_videoFiles,mergeFilePath);
    //=====清除分块文件=====
    clearChunkFiles(chunkFileFolderPath,chunkTotal);
    return RestResponse.success(true);
}

/**
 * 从minio下载文件
 * @param bucket 桶
 * @param objectName 对象名称
 * @return 下载后的文件
 */
public File downloadFileFromMinIO(String bucket,String objectName){
    //临时文件
    File minioFile = null;
    FileOutputStream outputStream = null;
    try{
        InputStream stream = minioClient.getObject(GetObjectArgs.builder()
                .bucket(bucket)
                .object(objectName)
                .build());
        //创建临时文件
        minioFile=File.createTempFile("minio", ".merge");
        outputStream = new FileOutputStream(minioFile);
        IOUtils.copy(stream,outputStream);
        return minioFile;
    } catch (Exception e) {
       e.printStackTrace();
    }finally {
        if(outputStream!=null){
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return null;
}
/**
 * 得到合并后的文件的地址
 * @param fileMd5 文件id即md5值
 * @param fileExt 文件扩展名
 * @return
 */
private String getFilePathByMd5(String fileMd5,String fileExt){
    return   fileMd5.substring(0,1) + "/" + fileMd5.substring(1,2) + "/" + fileMd5 + "/" +fileMd5 +fileExt;
}

/**
 * 清除分块文件
 * @param chunkFileFolderPath 分块文件路径
 * @param chunkTotal 分块文件总数
 */
private void clearChunkFiles(String chunkFileFolderPath,int chunkTotal){

    try {
        List<DeleteObject> deleteObjects = Stream.iterate(0, i -> ++i)
                .limit(chunkTotal)
                .map(i -> new DeleteObject(chunkFileFolderPath.concat(Integer.toString(i))))
                .collect(Collectors.toList());

        RemoveObjectsArgs removeObjectsArgs = RemoveObjectsArgs.builder().bucket("video").objects(deleteObjects).build();
        Iterable<Result<DeleteError>> results = minioClient.removeObjects(removeObjectsArgs);
        results.forEach(r->{
            DeleteError deleteError = null;
            try {
                deleteError = r.get();
            } catch (Exception e) {
                e.printStackTrace();
                log.error("清楚分块文件失败,objectname:{}",deleteError.objectName(),e);
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
        log.error("清楚分块文件失败,chunkFileFolderPath:{}",chunkFileFolderPath,e);
    }
}
```

### 5.5.2 接口层完善

下边完善接口层

```Java
@ApiOperation(value = "合并文件")
@PostMapping("/upload/mergechunks")
public RestResponse mergechunks(@RequestParam("fileMd5") String fileMd5,
                                @RequestParam("fileName") String fileName,
                                @RequestParam("chunkTotal") int chunkTotal) throws Exception {
    Long companyId = 1232141425L;

    UploadFileParamsDto uploadFileParamsDto = new UploadFileParamsDto();
    uploadFileParamsDto.setFileType("001002");
    uploadFileParamsDto.setTags("课程视频");
    uploadFileParamsDto.setRemark("");
    uploadFileParamsDto.setFilename(fileName);

    return mediaFileService.mergechunks(companyId,fileMd5,chunkTotal,uploadFileParamsDto);

}
```

### 5.5.2 合并分块测试

下边进行前后端联调：

1、上传一个视频测试合并分块的执行逻辑

进入service方法逐行跟踪。

2、断点续传测试

上传一部分后，停止刷新浏览器再重新上传，通过浏览器日志发现已经上传过的分块不再重新上传

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421370.png)

# **5、视频处理**

## 7.1 视频转码需求

### 7.7.1 什么是视频编码

视频上传成功后需要对视频进行转码处理。

什么是视频编码？查阅百度百科如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421836.png)

详情参考 ：[https://baike.baidu.com/item/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/839038](https://baike.baidu.com/item/视频编码/839038)

首先我们要分清文件格式和编码格式：

文件格式：是指.mp4、.avi、.rmvb等 这些不同扩展名的视频文件的文件格式  ，视频文件的内容主要包括视频和音频，其文件格式是按照一 定的编码格式去编码，并且按照该文件所规定的封装格式将视频、音频、字幕等信息封装在一起，播放器会根据它们的封装格式去提取出编码，然后由播放器解码，最终播放音视频。

音视频编码格式：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输。比如：一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b，音频原来为c，通过编码后变为d。

音视频编码格式各类繁多，主要有几下几类：

MPEG系列

（由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发 ）视频编码方面主要是Mpeg1（vcd用的就是它）、Mpeg2（DVD使用）、Mpeg4（的DVDRIP使用的都是它的变种，如：divx，xvid等）、Mpeg4 AVC（正热门）；音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（大名鼎鼎的mp3）、MPEG-2 AAC 、MPEG-4 AAC等等。注意：DVD音频没有采用Mpeg的。

H.26X系列

（由ITU[国际电传视讯联盟]主导，侧重网络传输，注意：只是视频编码）

包括H.261、H.262、H.263、H.263+、H.263++、H.264（就是MPEG4 AVC-合作的结晶）

目前最常用的编码标准是视频H.264，音频AAC。

提问：

H.264是编码格式还是文件格式？

mp4是编码格式还是文件格式？

### 7.7.2 **FFmpeg 的基本使用**

我们将视频录制完成后，使用视频编码软件对视频进行编码，本项目 使用FFmpeg对视频进行编码 。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NzliOTJjZTA0YjU1MDBjZTA3YWVmOWY4MDY1ZjMzMjhfc2xtZGN0Y2xvTGE2Q1FLQk9QY2kwb0lFYkxRNTFHaDBfVG9rZW46RVEwUWJOeFRBb0xCb0x4TVN1c2NrVzlVbmhiXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

FFmpeg被许多开源项目采用，QQ影音、暴风影音、VLC等。

下载：FFmpeg https://www.ffmpeg.org/download.html#build-windows

请从常用工具软件目录找到ffmpeg.exe，并将ffmpeg.exe加入环境变量path中。

测试是否正常：cmd运行 ffmpeg -version

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421290.png)

安装成功，作下简单测试

将一个.avi文件转成mp4、mp3、gif等。

比如我们将nacos.avi文件转成mp4，运行如下命令：

D:\soft\ffmpeg\ffmpeg.exe -i 1.avi 1.mp4

可以将ffmpeg.exe配置到环境变量path中，进入视频目录直接运行：ffmpeg.exe -i 1.avi 1.mp4

转成mp3：ffmpeg -i nacos.avi nacos.mp3

转成gif：ffmpeg -i nacos.avi nacos.gif

官方文档（英文）：http://ffmpeg.org/ffmpeg.html

### 7.7.3 视频处理工具类

将课程资料的工具类中的util拷贝至base工程。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTBmZTY4YzQyY2ZlMTM1OTYyOTIzZWYzZWU4OTEzN2VfRVFlRWdUZlNmRjNIS1RGdUVuRTV1TE1CTUFWUmJoNzlfVG9rZW46SXNOdGJTVnhobzQwQ0h4TGc1NWNIWG9Jbm9lXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

其中Mp4VideoUtil类是用于将视频转为mp4格式，是我们项目要使用的工具类。

下边看下这个类的代码，并进行测试。

我们要通过ffmpeg对视频转码，Java程序调用ffmpeg，使用java.lang.ProcessBuilder去完成，具体在Mp4VideoUtil类的63行，下边进行简单的测试，下边的代码运行本机安装的QQ软件。

```Java
ProcessBuilder builder = new ProcessBuilder();
builder.command("C:\\Program Files (x86)\\Tencent\\QQ\\Bin\\QQScLauncher.exe");
//将标准输入流和错误输入流合并，通过标准输入流程读取信息
builder.redirectErrorStream(true);
Process p = builder.start();
```

对Mp4VideoUtil类需要学习使用方法，下边代码将一个avi视频转为mp4视频，如下：

```Java
public static void main(String[] args) throws IOException {
    //ffmpeg的路径
    String ffmpeg_path = "D:\\soft\\ffmpeg\\ffmpeg.exe";//ffmpeg的安装位置
    //源avi视频的路径
    String video_path = "D:\\develop\\bigfile_test\\nacos01.avi";
    //转换后mp4文件的名称
    String mp4_name = "nacos01.mp4";
    //转换后mp4文件的路径
    String mp4_path = "D:\\develop\\bigfile_test\\nacos01.mp4";
    //创建工具类对象
    Mp4VideoUtil videoUtil = new Mp4VideoUtil(ffmpeg_path,video_path,mp4_name,mp4_path);
    //开始视频转换，成功将返回success
    String s = videoUtil.generateMp4();
    System.out.println(s);
}
```

执行main方法，最终在控制台输出 success 表示执行成功。

## 7.2 分布式任务处理

### 7.2.1 什么是分布式任务调度

对一个视频的转码可以理解为一个任务的执行，如果视频的数量比较多，如何去高效处理一批任务呢？

1、多线程

多线程是充分利用单机的资源。

2、分布式加多线程

充分利用多台计算机，每台计算机使用多线程处理。

方案2可扩展性更强。

方案2是一种分布式任务调度的处理方案。

什么是分布式任务调度？

我们可以先思考一下下面业务场景的解决方案：

​        每隔24小时执行数据备份任务。

​       12306网站会根据车次不同，设置几个时间点分批次放票。

​        某财务系统需要在每天上午10点前结算前一天的账单数据，统计汇总。

​        商品成功发货后，需要向客户发送短信提醒。

类似的场景还有很多，我们该如何实现？

**多线程方式实现：**

学过多线程的同学，可能会想到，我们可以开启一个线程，每sleep一段时间，就去检查是否已到预期执行时间。

以下代码简单实现了任务调度的功能：

```Java
public static void main(String[] args) {    
    //任务执行间隔时间
    final long timeInterval = 1000;
    Runnable runnable = new Runnable() {
        public void run() {
            while (true) {
                //TODO：something
                try {
                    Thread.sleep(timeInterval);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    };
    Thread thread = new Thread(runnable);
    thread.start();
}
```

上面的代码实现了按一定的间隔时间执行任务调度的功能。

Jdk也为我们提供了相关支持，如Timer、ScheduledExecutor，下边我们了解下。

**Timer方式实现**：

```Java
public static void main(String[] args){  
    Timer timer = new Timer();  
    timer.schedule(new TimerTask(){
        @Override  
        public void run() {  
           //TODO：something
        }  
    }, 1000, 2000);  //1秒后开始调度，每2秒执行一次
}
```

​        Timer 的优点在于简单易用，每个Timer对应一个线程，因此可以同时启动多个Timer并行执行多个任务，同一个Timer中的任务是串行执行。

**ScheduledExecutor方式实现**：

```Java
public static void main(String [] agrs){
    ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
    service.scheduleAtFixedRate(
            new Runnable() {
                @Override
                public void run() {
                    //TODO：something
                    System.out.println("todo something");
                }
            }, 1,
            2, TimeUnit.SECONDS);
}
```

​        Java 5 推出了基于线程池设计的 ScheduledExecutor，其设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。

​        Timer 和 ScheduledExecutor 都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每月第一天凌晨1点执行任务、复杂调度任务的管理、任务间传递数据等等。

**第三方Quartz方式实现，项目地址：****https://github.com/quartz-scheduler/quartz**   

​        Quartz 是一个功能强大的任务调度框架，它可以满足更多更复杂的调度需求，Quartz 设计的核心类包括 Scheduler, Job 以及 Trigger。其中，Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行。Quartz支持简单的按时间间隔调度、还支持按日历调度方式，通过设置CronTrigger表达式（包括：秒、分、时、日、月、周、年）进行任务调度。

下边是一个例子代码：

```Java
public static void main(String [] agrs) throws SchedulerException {
    //创建一个Scheduler
    SchedulerFactory schedulerFactory = new StdSchedulerFactory();
    Scheduler scheduler = schedulerFactory.getScheduler();
    //创建JobDetail
    JobBuilder jobDetailBuilder = JobBuilder.newJob(MyJob.class);
    jobDetailBuilder.withIdentity("jobName","jobGroupName");
    JobDetail jobDetail = jobDetailBuilder.build();
    //创建触发的CronTrigger 支持按日历调度
        CronTrigger trigger = TriggerBuilder.newTrigger()
                .withIdentity("triggerName", "triggerGroupName")
                .startNow()
                .withSchedule(CronScheduleBuilder.cronSchedule("0/2 * * * * ?"))
                .build();
    scheduler.scheduleJob(jobDetail,trigger);
    scheduler.start();
}

public class MyJob implements Job {
    @Override
    public void execute(JobExecutionContext jobExecutionContext){
        System.out.println("todo something");
    }
}
```

通过以上内容我们学习了什么是任务调度，任务调度所解决的问题，以及任务调度的多种实现方式。

**任务调度顾名思义，就是对任务的调度，它是指系统为了完成特定业务，基于给定时间点，给定时间间隔或者给定执行次数自动执行任务。**

**什么是分布式任务调度？**

​        通常任务调度的程序是集成在应用中的，比如：优惠卷服务中包括了定时发放优惠卷的的调度程序，结算服务中包括了定期生成报表的任务调度程序，由于采用分布式架构，一个服务往往会部署多个冗余实例来运行我们的业务，在这种分布式系统环境下运行任务调度，我们称之为**分布式任务调度**，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421351.png)

**分布式调度要实现的目标：**

​        不管是任务调度程序集成在应用程序中，还是单独构建的任务调度系统，如果采用分布式调度任务的方式就相当于将任务调度程序分布式构建，这样就可以具有分布式系统的特点，并且提高任务的调度处理能力：

1、并行任务调度

​        并行任务调度实现靠多线程，如果有大量任务需要调度，此时光靠多线程就会有瓶颈了，因为一台计算机CPU的处理能力是有限的。

​        如果将任务调度程序分布式部署，每个结点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率。

2、高可用

​        若某一个实例宕机，不影响其他实例来执行任务。

3、弹性扩容

​        当集群中增加实例就可以提高并执行任务的处理效率。

4、任务管理与监测

​        对系统中存在的所有定时任务进行统一的管理及监测。让开发人员及运维人员能够时刻了解任务执行情况，从而做出快速的应急处理响应。

5、避免任务重复执行

​        当任务调度以集群方式部署，同一个任务调度可能会执行多次，比如在上面提到的电商系统中到点发优惠券的例子，就会发放多次优惠券，对公司造成很多损失，所以我们需要控制相同的任务在多个运行实例上只执行一次。

### 7.2.2 XXL-JOB介绍

XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。

官网：https://www.xuxueli.com/xxl-job/

文档：https://www.xuxueli.com/xxl-job/#%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB%E3%80%8B

XXL-JOB主要有调度中心、执行器、任务：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421965.png)

**调度中心：**

​        负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码；

​        主要职责为执行器管理、任务管理、监控运维、日志管理等

**任务执行器：**

​        负责接收调度请求并执行任务逻辑；

​        只要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等

**任务：**负责执行具体的业务处理。

调度中心与执行器之间的工作流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421491.png)

**执行流程：**

​        1.任务执行器根据配置的调度中心的地址，自动注册到调度中心

​        2.达到任务触发条件，调度中心下发任务

​        3.执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中

​        4.执行器消费内存队列中的执行结果，主动上报给调度中心

​        5.当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情

### 7.2.3 搭建XXL-JOB

#### 7.2.3.1 调度中心

首先下载XXL-JOB

GitHub：https://github.com/xuxueli/xxl-job

码云：https://gitee.com/xuxueli0323/xxl-job

项目使用2.3.1版本： https://github.com/xuxueli/xxl-job/releases/tag/2.3.1

也可从课程资料目录获取，解压xxl-job-2.3.1.zip

使用IDEA打开解压后的目录

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFiNDM5Mjg0NjE5OTc2OTlkNGJhOGNjODM0ZWUzYWVfMmVCc3ZBUVhmVkZaOHVqT0pJOW05UmwxekRBeWZaWFhfVG9rZW46UVZ2V2JJNE1Sb0FBWUx4dWpGVWNNVkRDbnhoXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

xxl-job-admin：调度中心

xxl-job-core：公共依赖

xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用）

​    ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；

​    ：xxl-job-executor-sample-frameless：无框架版本；

doc :文档资料，包含数据库脚本

在下发的虚拟机的MySQL中已经创建了xxl_job_2.3.1数据库

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZkNDdlNTI2OWVlMzUzNDRiNjdmZjdiZmY2NjVkYTBfbUNubFdObFZDWGxad0FibVhBQnBXVFQ1SEtKQkhyblpfVG9rZW46UDZlU2J5ZTcyb05sUGJ4UnM5U2NTbWptbjlnXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421858.png)

执行sh /data/soft/restart.sh自动启动xxl-job调度中心

访问：http://192.168.101.65:8088/xxl-job-admin/

账号和密码：admin/123456

如果无法使用虚拟机运行xxl-job可以在本机idea运行xxl-job调度中心。

#### 7.2.3.2 执行器

下边配置执行器，执行器负责与调度中心通信接收调度中心发起的任务调度请求。

1、下边进入调度中心添加执行器

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJmNzczMTQ2MDk2MzVlNzc2YjYxOGY5Yjg2ODdlN2RfRDlEb2hleFdxNnRUeUp2NGh5VVE1R3RkVHd6OE53UERfVG9rZW46U3I0VGJVMUJTb2thU0l4SHlvWGNiS3JSblMzXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

点击新增，填写执行器信息，appname是前边在nacos中配置xxl信息时指定的执行器的应用名。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421398.png)

添加成功：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OWFmNzljY2UzZWZiMzZiZGRhZmQ5ZTQyMTM4ZTNmYTFfNXYzZzRoeVVSVnhIaktUd2I4dk1PTkgxTW04cWttRFVfVG9rZW46Sm9paGJJTklQb0xUS2x4bnJkbGNBc2xlblliXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

2、首先在媒资管理模块的service工程添加依赖，在项目的父工程已约定了版本2.3.1

```XML
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
</dependency>
```

3、在nacos下的media-service-dev.yaml下配置xxl-job

```YAML
xxl:
  job:
    admin: 
      addresses: http://192.168.101.65:8088/xxl-job-admin
    executor:
      appname: media-process-service
      address: 
      ip: 
      port: 9999
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 30
    accessToken: default_token
```

注意配置中的appname这是执行器的应用名，port是执行器启动的端口，如果本地启动多个执行器注意端口不能重复。

4、配置xxl-job的执行器

将xxl-job示例工程下配置类拷贝到媒资管理的service工程下

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421866.png)

拷贝至：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjYyMGQ5YmU1ZWE2OGQ5OWVkMWVlOTgyMTVlMDdjNjdfTTkzVTNFVGdicnBxVjNXRlc5YUFWS0pKa2tQYjgxZkJfVG9rZW46S2pDQ2J4TmtlbzlkR2J4SGJ2bWNqQnJTbklRXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

到此完成媒资管理模块service工程配置xxl-job执行器，在xxl-job调度中心添加执行器，下边准备测试执行器与调度中心是否正常通信，因为接口工程依赖了service工程，所以启动媒资管理模块的接口工程。

启动后观察日志，出现下边的日志表示执行器在调度中心注册成功

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzg3ZGViMTZhM2NlYjI5MTNiMDYxYTBmY2I4NmQwMmRfSExlZDE2TEo5QXd0OTNWaFl0cHV3UDZXUmVDZXZUWkdfVG9rZW46WjVMR2JnNDIwbzN4QzF4ZUJwM2NiWlJqbmViXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

同时观察调度中心中的执行器界面

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQ1NTEzYmNkNDU3ODczMmMxOGYzMWQzYWMzMjg2YmZfRGVWQm4wTzYwd2M5Mzgwd0hkR05QZTVNUHZZTDFkdUZfVG9rZW46TjVEc2JjNXUwbzR0bGp4U2ZEcWNEOXAxblA2XzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

在线机器地址处已显示1个执行器。

#### 7.2.3.3 执行任务

下边编写任务，参考示例工程中任务类的编写方法，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421609.png)

在媒资服务service包下新建jobhandler存放任务类，下边参考示例工程编写一个任务类

```Java
package com.xuecheng.media.service.jobhandler;

import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.handler.annotation.XxlJob;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

/**
 * @description 测试执行器
 * @author Mr.M
 * @date 2022/9/13 20:32
 * @version 1.0
 */
 @Component
 @Slf4j
public class SampleJob {

 /**
  * 1、简单任务示例（Bean模式）
  */
 @XxlJob("testJob")
 public void testJob() throws Exception {
  log.info("开始执行.....");

 }

}
```

下边在调度中心添加任务，进入任务管理

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDNmN2VmODI4YWVhMTJjMzhkODg0ZDM1YjA5MTYxNTlfUHZJWVd4UnFYQlJMS2RQSkJLYkJpZ3hmOWFVa0Nnd2VfVG9rZW46UGNidmJvb0pab1V5OEF4a3E2VWM2eUlBbkFoXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

点击新增，填写任务信息

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUxZmFjYzU5ZWMwMTI3NDU0ODcyZTM2N2M3ZGE0NGNfbmVTN3ZERTNuamN2UnpFak9MMExGSmhoZEZEMDdNU2tfVG9rZW46Wk5pSGJXOVRnb3lYa214QllDcmNlVzJ6bkJmXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

注意红色标记处：

调度类型：

固定速度指按固定的间隔定时调度。

Cron，通过Cron表达式实现更丰富的定时调度策略。

Cron表达式是一个字符串，通过它可以定义调度策略，格式如下：

{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}

xxl-job提供图形界面去配置：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421168.png)

一些例子如下：

30 10 1 * * ?  每天1点10分30秒触发

0/30 * * * * ? 每30秒触发一次

\* 0/10 * * * ? 每10分钟触发一次

运行模式有BEAN和GLUE，bean模式较常用就是在项目工程中编写执行器的任务代码，GLUE是将任务代码编写在调度中心。

JobHandler即任务方法名，填写任务方法上边@XxlJob注解中的名称。

路由策略：当执行器集群部署时，调度中心向哪个执行器下发任务，这里选择第一个表示只向第一个执行器下发任务，路由策略的其它选项稍后在分片广播章节详细解释。

高级配置的其它配置项稍后在分片广播章节详细解释。

添加成功，启动任务

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421104.png)

通过调度日志查看任务执行情况

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZhNTVhYzk2MzRhNWVhZjk3NDUxZGRjODFmYzk1ZDVfY2UxRVBLWE1HU0duS0xyd21aQTlaQjIwNkttTFpTZVRfVG9rZW46UEFnT2I3eW1nb3JUb1Z4Nmo5RWM5VjFqbk9mXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

下边启动媒资管理的service工程，启动执行器。

观察执行器方法的执行。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421997.png)

如果要停止任务需要在调度中心操作

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWRkMDdlNmFlZTQzYTQ1ZjlhZjM4ODc3MDI2YTZlYzFfMkxhVkNyWUxwYVNkZVZ1Vkk4T1FzWFVCeDhaN0JjaUhfVG9rZW46RzV0cWJ2TUNTb3JOZUl4QmNvOWNlU0VSbmZjXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

任务跑一段时间注意清理日志

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421696.png)

### 7.2.4 分片广播

掌握了xxl-job的基本使用，下边思考如何进行分布式任务处理呢？如下图，我们会启动多个执行器组成一个集群，去执行任务。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YWUxMTQzZGJjYWIwZDYxYTVlOWU0NjkyMjJlMzYyYmZfeDg1NTR3N2hoMWVFQlluTnZRd2NKRk9FZGZyNVc1b01fVG9rZW46QlF2bGJlZ3ZMb3BzYWZ4WEhTUmNOTmo0bmRrXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

执行器在集群部署下调度中心有哪些路由策略呢？

查看xxl-job官方文档，阅读高级配置相关的内容：

```SQL
高级配置：
    - 路由策略：当执行器集群部署时，提供丰富的路由策略，包括；
        FIRST（第一个）：固定选择第一个机器；
        LAST（最后一个）：固定选择最后一个机器；
        ROUND（轮询）：；
        RANDOM（随机）：随机选择在线的机器；
        CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。
        LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；
        LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；
        FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；
        BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；
        SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；

    - 子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度，通过子任务可以实现一个任务执行完成去执行另一个任务。
    - 调度过期策略：
        - 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；
        - 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；
    - 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；
        单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；
        丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；
        覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；
    - 任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；
    - 失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；
```

下边要重点说的是分片广播策略，分片是指是调度中心以执行器为维度进行分片，将集群中的执行器标上序号：0，1，2，3...，广播是指每次调度会向集群中的所有执行器发送任务调度，请求中携带分片参数。

如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421617.png)

每个执行器收到调度请求同时接收分片参数。

xxl-job支持动态扩容执行器集群从而动态增加分片数量，当有任务量增加可以部署更多的执行器到集群中，调度中心会动态修改分片的数量。

**作业分片适用哪些场景呢？**

- 分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；
- 广播任务场景：广播执行器同时运行shell脚本、广播集群节点进行缓存更新等。

所以，广播分片方式不仅可以充分发挥每个执行器的能力，并且根据分片参数可以控制任务是否执行，最终灵活控制了执行器集群分布式处理任务。

**使用说明：**

"分片广播" 和普通任务开发流程一致，不同之处在于可以获取分片参数进行分片业务处理。

Java语言任务获取分片参数方式：

BEAN、GLUE模式(Java)，可参考Sample示例执行器中的示例任务"ShardingJobHandler"：

```Java
/**
 * 2、分片广播任务
 */
@XxlJob("shardingJobHandler")
public void shardingJobHandler() throws Exception {
    // 分片序号，从0开始
    int shardIndex = XxlJobHelper.getShardIndex();
    // 分片总数
    int shardTotal = XxlJobHelper.getShardTotal();
    ....
```

下边测试作业分片：

1、定义作业分片的任务方法

```Java
/**
  * 2、分片广播任务
  */
 @XxlJob("shardingJobHandler")
 public void shardingJobHandler() throws Exception {

  // 分片参数
  int shardIndex = XxlJobHelper.getShardIndex();
  int shardTotal = XxlJobHelper.getShardTotal();

log.info("分片参数：当前分片序号 = {}, 总分片数 = {}", shardIndex, shardTotal);
log.info("开始执行第"+shardIndex+"批任务");

 }
```

2、在调度中心添加任务

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421000.png)

添加成功：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmEwYmQ3MTA2NDc3M2VhODJlZGIxZmUzNTQ5MmY5ZjRfMFJWY2RteGhYSWJvc3hMdmFiMUhaOGJVV1Z2eXpIY3VfVG9rZW46VmdiMGJVUlhPb2F6SXR4RUxJdWNTYzg2blpjXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

启动任务，观察日志

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421976.png)

下边启动两个执行器实例，观察每个实例的执行情况

首先在nacos中配置media-service的本地优先配置：

```YAML
#配置本地优先
spring:
 cloud:
  config:
    override-none: true
```

将media-service启动两个实例

两个实例的在启动时注意端口不能冲突：

实例1 在VM options处添加：-Dserver.port=63051 -Dxxl.job.executor.port=9998

实例2 在VM options处添加：-Dserver.port=63050 -Dxxl.job.executor.port=9999

例如：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421045.png)

启动两个实例

观察任务调度中心，稍等片刻执行器有两个

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQwMDZhN2Q0ZjE2ZDljY2U5MzQ1OTQ5YzcwMzM4MjVfbGxBZUhyNjhHMEZLM0VqVjJwWWRIMHVOcmNWdHVLYWFfVG9rZW46QU9ramJabUE3b0ZXbDZ4TnB0Z2NpbVNkbkdlXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

观察两个执行实例的日志：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421017.png)

另一实例的日志如下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFmMTk1ZWNkMDRlMGNhYmI1ZDYzMmNkYTYwY2U1MTdfMTRGeTh0RHpPSU1QaGxJT0NSTjNkMGo4eXprSEVxaFpfVG9rZW46RW1iMGJiWVkzb3g5RFB4SDhGNGNDS0Nubm5mXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

从日志可以看每个实例的分片序号不同。

如果其中一个执行器挂掉，只剩下一个执行器在工作，稍等片刻调用中心发现少了一个执行器将动态调整总分片数为1。

到此作业分片任务调试完成，此时我们可以思考：

当一次分片广播到来，各执行器如何根据分片参数去分布式执行任务，保证执行器之间执行的任务不重复呢？

## 7.3 视频处理技术方案

### 7.3.1 作业分片方案

掌握了xxl-job的分片广播调度方式，下边思考如何分布式去执行学成在线平台中的视频处理任务。

任务添加成功后，对于要处理的任务会添加到待处理任务表中，现在启动多个执行器实例去查询这些待处理任务，此时如何保证多个执行器不会查询到重复的任务呢？

XXL-JOB并不直接提供数据处理的功能，它只会给执行器分配好分片序号，在向执行器任务调度的同时下发分片总数以及分片序号等参数，执行器收到这些参数根据自己的业务需求去利用这些参数。

下图表示了多个执行器获取视频处理任务的结构：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421310.png)

每个执行器收到广播任务有两个参数：分片总数、分片序号。每个执行从数据表取任务时可以让任务id 模上 分片总数，如果等于分片序号则执行此任务。

上边两个执行器实例那么分片总数为2，序号为0、1，从任务1开始，如下：

1  %  2 = 1    执行器2执行

2  %  2 =  0    执行器1执行

3  %  2 =  1     执行器2执行

以此类推.

### 7.3.2 保证任务不重复执行

通过作业分片方案保证了执行器之间查询到不重复的任务，如果一个执行器在处理一个视频还没有完成，此时调度中心又一次请求调度，为了不重复处理同一个视频该怎么办？

首先配置调度过期策略：

查看文档如下：

​    \- 调度过期策略：调度中心错过调度时间的补偿处理策略，包括：忽略、立即补偿触发一次等；        - 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；        - 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；    - 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；

这里我们选择忽略，如果立即执行一次就可能重复执行相同的任务。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421419.png)

其次，再看阻塞处理策略，阻塞处理策略就是当前执行器正在执行任务还没有结束时调度中心进行任务调度，此时该如何处理。

查看文档如下：        

单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；        

丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；       

覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；

这里如果选择覆盖之前调度则可能重复执行任务，这里选择 丢弃后续调度或单机串行方式来避免任务重复执行。

只做这些配置可以保证任务不会重复执行吗？

做不到，还需要保证任务处理的幂等性，什么是任务的幂等性？任务的幂等性是指：对于数据的操作不论多少次，操作的结果始终是一致的。在本项目中要实现的是不论多少次任务调度同一个视频只执行一次成功的转码。

什么是幂等性？

它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果。

幂等性是为了解决重复提交问题，比如：恶意刷单，重复支付等。

解决幂等性常用的方案：

1）数据库约束，比如：唯一索引，主键。

2）乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新。

3）唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等则执行。

基于以上分析，在执行器接收调度请求去执行视频处理任务时要实现视频处理的幂等性，要有办法去判断该视频是否处理完成，如果正在处理中或处理完则不再处理。这里我们在数据库视频处理表中添加处理状态字段，视频处理完成更新状态为完成，执行视频处理前判断状态是否完成，如果完成则不再处理。

### 7.3.3 视频处理方案

确定了分片方案，下边梳理整个视频上传及处理的业务流程。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NzI3Y2YzZDM5YjkwOWIzZGJhOGFhZjdlNTFlMjA0NWJfclhZdEQ3Y01yWTd4WUFPQXdsbUZPbXd4a2h2c2k4TWRfVG9rZW46RGUwQmJQOEo4bzlkTW54MlRLNGNUZUR0bnVlXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

上传视频成功向视频处理待处理表添加记录。

视频处理的详细流程如下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YzgzNjMzNjAxYTgwNGFkNTIyM2ZlY2QzZjQwYjBhMjlfYU1ua1gxOWg2c3BXSll5QmtJN1NiRzZFbnVRVjN5amZfVG9rZW46SjFFT2JvNkRFb2pnRWd4NFZaaGMySmU5bldmXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

1、任务调度中心广播作业分片。

2、执行器收到广播作业分片，从数据库读取待处理任务，读取未处理及处理失败的任务。

3、执行器更新任务为处理中，根据任务内容从MinIO下载要处理的文件。

4、执行器启动多线程去处理任务。

5、任务处理完成，上传处理后的视频到MinIO。

6、将更新任务处理结果，如果视频处理完成除了更新任务处理结果以外还要将文件的访问地址更新至任务处理表及文件表中，最后将任务完成记录写入历史表。

## 7.4 查询待处理任务

### 7.4.1 需求分析

查询待处理任务只处理未提交及处理失败的任务，任务处理失败后进行重试，最多重试3次。

任务处理成功将待处理记录移动到历史任务表。

下图是待处理任务表：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421155.png)

历史任务表与待处理任务表的结构相同。

### 7.4.2添加待处理任务

上传视频成功向视频处理待处理表添加记录，暂时只添加对avi视频的处理记录。

根据MIME Type去判断是否是avi视频，下边列出部分MIME Type

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTMwY2I4ZTBjMjJmZjQ2OTA1Zjg5ODU4YjE2NDc2YzZfR2R3UFA5WU9jSnBPSmNsNEFCRm0xYVBpQm1oOXJveGJfVG9rZW46SXhGZ2JwRmpCb0xjY3R4NVN4U2N0MkI5bkZnXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

avi视频的MIME Type是video/x-msvideo

修改文件信息入库方法，如下：

```Java
@Transactional
public MediaFiles addMediaFilesToDb(Long companyId, String fileMd5, UploadFileParamsDto uploadFileParamsDto, String bucket, String objectName) {
    //从数据库查询文件
    MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5);
    if (mediaFiles == null) {
        mediaFiles = new MediaFiles();
        //拷贝基本信息
        BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);
        mediaFiles.setId(fileMd5);
        mediaFiles.setFileId(fileMd5);
        mediaFiles.setCompanyId(companyId);
        //媒体类型
        mediaFiles.setUrl("/" + bucket + "/" + objectName);
        mediaFiles.setBucket(bucket);
        mediaFiles.setFilePath(objectName);
        mediaFiles.setCreateDate(LocalDateTime.now());
        mediaFiles.setAuditStatus("002003");
        mediaFiles.setStatus("1");
        //保存文件信息到文件表
        int insert = mediaFilesMapper.insert(mediaFiles);
        if (insert < 0) {
            log.error("保存文件信息到数据库失败,{}", mediaFiles.toString());
            XueChengPlusException.cast("保存文件信息失败");
        }
        //添加到待处理任务表
        addWaitingTask(mediaFiles);
        log.debug("保存文件信息到数据库成功,{}", mediaFiles.toString());

    }
    return mediaFiles;

}

/**
 * 添加待处理任务
 * @param mediaFiles 媒资文件信息
 */
private void addWaitingTask(MediaFiles mediaFiles){
    //文件名称
    String filename = mediaFiles.getFilename();
    //文件扩展名
    String extension = filename.substring(filename.lastIndexOf("."));
    //文件mimeType
    String mimeType = getMimeType(extension);
    //如果是avi视频添加到视频待处理表
    if(mimeType.equals("video/x-msvideo")){
        MediaProcess mediaProcess = new MediaProcess();
        BeanUtils.copyProperties(mediaFiles,mediaProcess);
        mediaProcess.setStatus("1");//未处理
        mediaProcess.setFailCount(0);//失败次数默认为0
        mediaProcessMapper.insert(mediaProcess);
    }
}
```

进行前后端测试，上传4个avi视频，观察待处理任务表是否存在记录，记录是否完成。

### 7.4.3 查询待处理任务

如何保证查询到的待处理视频记录不重复？

编写根据分片参数获取待处理任务的DAO方法，定义DAO接口如下：

```Java
public interface MediaProcessMapper extends BaseMapper<MediaProcess> {
    /**
     * @description 根据分片参数获取待处理任务
     * @param shardTotal  分片总数
     * @param shardindex  分片序号
     * @param count 任务数
     * @return java.util.List<com.xuecheng.media.model.po.MediaProcess> 
     * @author Mr.M
     * @date 2022/9/14 8:54
    */
    @Select("select * from media_process t where t.id % #{shardTotal} = #{shardIndex} and (t.status = '1' or t.status = '3') and t.fail_count < 3 limit #{count}")
    List<MediaProcess> selectListByShardIndex(@Param("shardTotal") int shardTotal,@Param("shardIndex") int shardIndex,@Param("count") int count);
}
```

定义Service接口，查询待处理

```Java
package com.xuecheng.media.service;

import com.xuecheng.base.model.PageParams;
import com.xuecheng.base.model.PageResult;
import com.xuecheng.base.model.RestResponse;
import com.xuecheng.media.model.dto.QueryMediaParamsDto;
import com.xuecheng.media.model.dto.UploadFileParamsDto;
import com.xuecheng.media.model.dto.UploadFileResultDto;
import com.xuecheng.media.model.po.MediaFiles;
import com.xuecheng.media.model.po.MediaProcess;
import org.springframework.transaction.annotation.Transactional;

import java.io.File;
import java.util.List;

/**
 * @author Mr.M
 * @version 1.0
 * @description 媒资文件处理业务方法
 * @date 2022/9/10 8:55
 */
public interface MediaFileProcessService {

    /**
     * @description 获取待处理任务
     * @param shardIndex 分片序号
     * @param shardTotal 分片总数
     * @param count 获取记录数
     * @return java.util.List<com.xuecheng.media.model.po.MediaProcess>
     * @author Mr.M
     * @date 2022/9/14 14:49
    */
    public List<MediaProcess> getMediaProcessList(int shardIndex,int shardTotal,int count);


}
```

service接口实现

```Java
package com.xuecheng.media.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.media.mapper.MediaFilesMapper;
import com.xuecheng.media.mapper.MediaProcessHistoryMapper;
import com.xuecheng.media.mapper.MediaProcessMapper;
import com.xuecheng.media.model.po.MediaFiles;
import com.xuecheng.media.model.po.MediaProcess;
import com.xuecheng.media.model.po.MediaProcessHistory;
import com.xuecheng.media.service.MediaFileProcessService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.AutoConfigureOrder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

/**
 * @description TODO
 * @author Mr.M
 * @date 2022/9/14 14:41
 * @version 1.0
 */
@Slf4j
@Service
public class MediaFileProcessServiceImpl implements MediaFileProcessService {

 @Autowired
 MediaFilesMapper mediaFilesMapper;

 @Autowired
 MediaProcessMapper mediaProcessMapper;


 @Override
 public List<MediaProcess> getMediaProcessList(int shardIndex, int shardTotal, int count) {
  List<MediaProcess> mediaProcesses = mediaProcessMapper.selectListByShardIndex(shardTotal, shardIndex, count);
   return mediaProcesses;
 }


}
```

## 7.5 开始执行任务

### 7.5.1 分布式锁

前边分析了保证任务不重复执行的方案，理论上每个执行器分到的任务是不重复的，但是当在执行器弹性扩容时无法绝对避免任务不重复执行，比如：原来有四个执行器正在执行任务，由于网络问题原有的0、1号执行器无法与调度中心通信，调度中心就会对执行器重新编号，原来的3、4执行器可能就会执行和0、1号执行器相同的任务。

为了避免多线程去争抢同一个任务可以使用synchronized同步锁去解决，如下代码：

```Java
synchronized(锁对象){
   执行任务...
}
```

synchronized只能保证同一个虚拟机中多个线程去争抢锁。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421481.png)

如果是多个执行器分布式部署，并不能保证同一个视频只有一个执行器去处理。

现在要实现分布式环境下所有虚拟机中的线程去同步执行就需要让多个虚拟机去共用一个锁，虚拟机可以分布式部署，锁也可以分布式部署，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421048.png)

虚拟机都去抢占同一个锁，锁是一个单独的程序提供加锁、解锁服务。

**该锁已不属于某个虚拟机，而是分布式部署，由多个虚拟机所共享，这种锁叫分布式锁。**

实现分布式锁的方案有很多，常用的如下：

1、基于数据库实现分布锁

利用数据库主键唯一性的特点，或利用数据库唯一索引、行级锁的特点，比如：多个线程同时向数据库插入主键相同的同一条记录，谁插入成功谁就获取锁，多个线程同时去更新相同的记录，谁更新成功谁就抢到锁。

2、基于redis实现锁

redis提供了分布式锁的实现方案，比如：SETNX、set nx、redisson等。

拿SETNX举例说明，SETNX命令的工作过程是去set一个不存在的key，多个线程去设置同一个key只会有一个线程设置成功，设置成功的的线程拿到锁。

3、使用zookeeper实现

zookeeper是一个分布式协调服务，主要解决分布式程序之间的同步的问题。zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁。

本次我们选用数据库实现分布锁，后边的模块会选用其它方案到时再详细介绍。

### 7.5.2 开启任务

下边基于数据库方式实现分布锁，开始执行任务将任务执行状态更新为4表示任务执行中。

下边的sql语句可以实现更新操作：

```Java
update media_process m set m.status='4' where  m.id=?
```

如果是多个线程去执行该sql都将会执行成功，但需求是只能有一个线程抢到锁，所以此sql无法满足需求。

使用乐观锁方式实现更新操作：

```Java
update media_process m set m.status='4' where (m.status='1' or m.status='3') and m.fail_count<3 and m.id=?
```

多个线程同时执行上边的sql只会有一个线程执行成功。

什么是乐观锁、悲观锁？

synchronized是一种悲观锁，在执行被synchronized包裹的代码时需要首先获取锁，没有拿到锁则无法执行，是总悲观的认为别的线程会去抢，所以要悲观锁。

乐观锁的思想是它不认为会有线程去争抢，尽管去执行，如果没有执行成功就再去重试。

数据库的乐观锁实现方式是在表中增加一个version字段，更新时判断是否等于某个版本，等于则更新否则更新失败，如下方式。

```Java
update t1 set t1.data1 = '',t1.version='2' where t1.version='1'
```

实现如下：

1、定义mapper

```Java
public interface MediaProcessMapper extends BaseMapper<MediaProcess> {

    /**
     * 开启一个任务
     * @param id 任务id
     * @return 更新记录数
     */
    @Update("update media_process m set m.status='4' where (m.status='1' or m.status='3') and m.fail_count<3 and m.id=#{id}")
    int startTask(@Param("id") long id);

}
```

2、在MediaFileProcessService中定义接口

```Java
/**
 *  开启一个任务
 * @param id 任务id
 * @return true开启任务成功，false开启任务失败
 */
public boolean startTask(long id);

//实现如下
public boolean startTask(long id) {
    int result = mediaProcessMapper.startTask(id);
    return result<=0?false:true;
}
```

## 7.6 更新任务状态

任务处理完成需要更新任务处理结果，任务执行成功更新视频的URL、及任务处理结果，将待处理任务记录删除，同时向历史任务表添加记录。

在MediaFileProcessService接口添加方法

```Java
/**
 * @description 保存任务结果
 * @param taskId  任务id
 * @param status 任务状态
 * @param fileId  文件id
 * @param url url
 * @param errorMsg 错误信息
 * @return void
 * @author Mr.M
 * @date 2022/10/15 11:29
 */
void saveProcessFinishStatus(Long taskId,String status,String fileId,String url,String errorMsg);
```

service接口方法实现如下：

```Java
package com.xuecheng.media.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.media.mapper.MediaFilesMapper;
import com.xuecheng.media.mapper.MediaProcessHistoryMapper;
import com.xuecheng.media.mapper.MediaProcessMapper;
import com.xuecheng.media.model.po.MediaFiles;
import com.xuecheng.media.model.po.MediaProcess;
import com.xuecheng.media.model.po.MediaProcessHistory;
import com.xuecheng.media.service.MediaFileProcessService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.AutoConfigureOrder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

/**
 * @description TODO
 * @author Mr.M
 * @date 2022/9/14 14:41
 * @version 1.0
 */
@Slf4j
@Service
public class MediaFileProcessServiceImpl implements MediaFileProcessService {

 @Autowired
 MediaFilesMapper mediaFilesMapper;

 @Autowired
 MediaProcessMapper mediaProcessMapper;

 @Autowired
 MediaProcessHistoryMapper mediaProcessHistoryMapper;



@Transactional
@Override
public void saveProcessFinishStatus(Long taskId, String status, String fileId, String url, String errorMsg) {
    //查出任务，如果不存在则直接返回
    MediaProcess mediaProcess = mediaProcessMapper.selectById(taskId);
    if(mediaProcess == null){
        return ;
    }
    //处理失败，更新任务处理结果
    LambdaQueryWrapper<MediaProcess> queryWrapperById = new LambdaQueryWrapper<MediaProcess>().eq(MediaProcess::getId, taskId);
    //处理失败
    if(status.equals("3")){
        MediaProcess mediaProcess_u = new MediaProcess();
        mediaProcess_u.setStatus("3");
        mediaProcess_u.setErrormsg(errorMsg);
        mediaProcess_u.setFailCount(mediaProcess.getFailCount()+1);
        mediaProcessMapper.update(mediaProcess_u,queryWrapperById);
        log.debug("更新任务处理状态为失败，任务信息:{}",mediaProcess_u);
        return ;
    }
    //任务处理成功
    MediaFiles mediaFiles = mediaFilesMapper.selectById(fileId);
    if(mediaFiles!=null){
        //更新媒资文件中的访问url
        mediaFiles.setUrl(url);
        mediaFilesMapper.updateById(mediaFiles);
    }
    //处理成功，更新url和状态
    mediaProcess.setUrl(url);
    mediaProcess.setStatus("2");
    mediaProcess.setFinishDate(LocalDateTime.now());
    mediaProcessMapper.updateById(mediaProcess);

    //添加到历史记录
    MediaProcessHistory mediaProcessHistory = new MediaProcessHistory();
    BeanUtils.copyProperties(mediaProcess, mediaProcessHistory);
    mediaProcessHistoryMapper.insert(mediaProcessHistory);
    //删除mediaProcess
    mediaProcessMapper.deleteById(mediaProcess.getId());

}

 @Override
 public List<MediaProcess> getMediaProcessList(int shardIndex, int shardTotal, int count) {
  List<MediaProcess> mediaProcesses = mediaProcessMapper.selectListByShardIndex(shardTotal, shardIndex, count);
   return mediaProcesses;
 }


}
```

## 7.7 视频处理

视频采用并发处理，每个视频使用一个线程去处理，每次处理的视频数量不要超过cpu核心数。

所有视频处理完成结束本次执行，为防止代码异常出现无限期等待则添加超时设置，到达超时时间还没有处理完成仍结束任务。

定义任务类VideoTask 如下：

```Java
package com.xuecheng.media.service.jobhander;

import com.xuecheng.base.utils.Mp4VideoUtil;
import com.xuecheng.media.model.po.MediaProcess;
import com.xuecheng.media.service.MediaFileProcessService;
import com.xuecheng.media.service.MediaFileService;
import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.handler.annotation.XxlJob;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.*;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2022/10/15 11:58
 */
@Slf4j
@Component
public class VideoTask {

    @Autowired
    MediaFileService mediaFileService;
    @Autowired
    MediaFileProcessService mediaFileProcessService;


    @Value("${videoprocess.ffmpegpath}")
    String ffmpegpath;

    @XxlJob("videoJobHandler")
    public void videoJobHandler() throws Exception {

        // 分片参数
    int shardIndex = XxlJobHelper.getShardIndex();
    int shardTotal = XxlJobHelper.getShardTotal();
    List<MediaProcess> mediaProcessList = null;
    int size = 0;
    try {
        //取出cpu核心数作为一次处理数据的条数
        int processors = Runtime.getRuntime().availableProcessors();
        //一次处理视频数量不要超过cpu核心数
        mediaProcessList = mediaFileProcessService.getMediaProcessList(shardIndex, shardTotal, processors);
        size = mediaProcessList.size();
        log.debug("取出待处理视频任务{}条", size);
        if (size <= 0) {
            return;
        }
    } catch (Exception e) {
        e.printStackTrace();
        return;
    }
    //启动size个线程的线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(size);
    //计数器
    CountDownLatch countDownLatch = new CountDownLatch(size);
    //将处理任务加入线程池
    mediaProcessList.forEach(mediaProcess -> {
        threadPool.execute(() -> {
            try {
                //任务id
                Long taskId = mediaProcess.getId();
                //抢占任务
                boolean b = mediaFileProcessService.startTask(taskId);
                if (!b) {
                    return;
                }
                log.debug("开始执行任务:{}", mediaProcess);
                //下边是处理逻辑
                //桶
                String bucket = mediaProcess.getBucket();
                //存储路径
                String filePath = mediaProcess.getFilePath();
                //原始视频的md5值
                String fileId = mediaProcess.getFileId();
                //原始文件名称
                String filename = mediaProcess.getFilename();
                //将要处理的文件下载到服务器上
                File originalFile = mediaFileService.downloadFileFromMinIO(mediaProcess.getBucket(), mediaProcess.getFilePath());
                if (originalFile == null) {
                    log.debug("下载待处理文件失败,originalFile:{}", mediaProcess.getBucket().concat(mediaProcess.getFilePath()));
                    mediaFileProcessService.saveProcessFinishStatus(mediaProcess.getId(), "3", fileId, null, "下载待处理文件失败");
                    return;
                }
                //处理下载的视频文件
                File mp4File = null;
                try {
                    mp4File = File.createTempFile("mp4", ".mp4");
                } catch (IOException e) {
                    log.error("创建mp4临时文件失败");
                    mediaFileProcessService.saveProcessFinishStatus(mediaProcess.getId(), "3", fileId, null, "创建mp4临时文件失败");
                    return;
                }
                //视频处理结果
                String result = "";
                try {
                    //开始处理视频
                    Mp4VideoUtil videoUtil = new Mp4VideoUtil(ffmpegpath, originalFile.getAbsolutePath(), mp4File.getName(), mp4File.getAbsolutePath());
                    //开始视频转换，成功将返回success
                    result = videoUtil.generateMp4();
                } catch (Exception e) {
                    e.printStackTrace();
                    log.error("处理视频文件:{},出错:{}", mediaProcess.getFilePath(), e.getMessage());
                }
                if (!result.equals("success")) {
                    //记录错误信息
                    log.error("处理视频失败,视频地址:{},错误信息:{}", bucket + filePath, result);
                    mediaFileProcessService.saveProcessFinishStatus(mediaProcess.getId(), "3", fileId, null, result);
                    return;
                }
    
                //将mp4上传至minio
                //mp4在minio的存储路径
                String objectName = getFilePath(fileId, ".mp4");
                //访问url
                String url = "/" + bucket + "/" + objectName;
                try {
                    mediaFileService.addMediaFilesToMinIO(mp4File.getAbsolutePath(), "video/mp4", bucket, objectName);
                    //将url存储至数据，并更新状态为成功，并将待处理视频记录删除存入历史
                    mediaFileProcessService.saveProcessFinishStatus(mediaProcess.getId(), "2", fileId, url, null);
                } catch (Exception e) {
                    log.error("上传视频失败或入库失败,视频地址:{},错误信息:{}", bucket + objectName, e.getMessage());
                    //最终还是失败了
                    mediaFileProcessService.saveProcessFinishStatus(mediaProcess.getId(), "3", fileId, null, "处理后视频上传或入库失败");
                }
            }finally {
                countDownLatch.countDown();
            }
        });
    });
    //等待,给一个充裕的超时时间,防止无限等待，到达超时时间还没有处理完成则结束任务
    countDownLatch.await(30, TimeUnit.MINUTES);
    }

    private String getFilePath(String fileMd5,String fileExt){
        return   fileMd5.substring(0,1) + "/" + fileMd5.substring(1,2) + "/" + fileMd5 + "/" +fileMd5 +fileExt;
    }

}
```

## 7.8 测试

### 7.8.1 基本测试

进入xxl-job调度中心添加执行器和视频处理任务

在xxl-job配置任务调度策略：

1）配置阻塞处理策略为：丢弃后续调度。

2）配置视频处理调度时间间隔不用根据视频处理时间去确定，可以配置的小一些，如：5分钟，即使到达调度时间如果视频没有处理完会丢弃调度请求。

配置完成开始测试视频处理：

1、首先上传至少4个视频，非mp4格式。

2、在xxl-job启动视频处理任务

3、观察媒资管理服务后台日志

### 7.8.2 失败测试

1、先停止调度中心的视频处理任务。

2、上传视频，手动修改待处理任务表中file_path字段为一个不存在的文件地址

3、启动任务

观察任务处理失败后是否会重试，并记录失败次数。

### 7.8.3 抢占任务测试

1、修改调度中心中视频处理任务的阻塞处理策略为“覆盖之间的调度”

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421119.png)

2、在抢占任务代码处打断点并选择支持多线程方式

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNhYWE2ZTEzNTI4ZjFkNzkzMDU2NDExYTNmODZjZWRfTjhRamI3dlZOTDMxT3hMVEd5S20wQmllSWFndDkzWjFfVG9rZW46U0NnMmJ5M2lEb1IwYTF4M21EZmNQRm1MbnRkXzE3MzIzNDI4ODA6MTczMjM0NjQ4MF9WNA)

3、在抢占任务代码处的下边两行代码分别打上断点，避免观察时代码继续执行。

4、启动任务

此时多个线程执行都停留在断点处

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421846.png)

依次放行，观察同一个任务只会被一个线程抢占成功。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421436.png)

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231421925.png)

## 7.9 其它问题

### 7.9.1 任务补偿机制

如果有线程抢占了某个视频的处理任务，如果线程处理过程中挂掉了，该视频的状态将会一直是处理中，其它线程将无法处理，这个问题需要用补偿机制。

单独启动一个任务找到待处理任务表中超过执行期限但仍在处理中的任务，将任务的状态改为执行失败。

任务执行期限是处理一个视频的最大时间，比如定为30分钟，通过任务的启动时间去判断任务是否超过执行期限。

大家思考这个sql该如何实现？

大家尝试自己实现此任务补偿机制。

### 7.9.2 达到最大失败次数

当任务达到最大失败次数时一般就说明程序处理此视频存在问题，这种情况就需要人工处理，在页面上会提示失败的信息，人工可手动执行该视频进行处理，或通过其它转码工具进行视频转码，转码后直接上传mp4视频。

### 7.9.3  分块文件清理问题

上传一个文件进行分块上传，上传一半不传了，之前上传到minio的分块文件要清理吗？怎么做的？

1、在数据库中有一张文件表记录minio中存储的文件信息。

2、文件开始上传时会写入文件表，状态为上传中，上传完成会更新状态为上传完成。

3、当一个文件传了一半不再上传了说明该文件没有上传完成，会有定时任务去查询文件表中的记录，如果文件未上传完成则删除minio中没有上传成功的文件目录。







# 6、分布式事务技术方案

### 4.2.1 什么是分布式事务

一次课程发布操作需要向数据库、redis、elasticsearch、MinIO写四份数据，这里存在分布式事务问题。

什么是分布式事务？

首先理解什么是本地事务？

平常我们在程序中通过spring去控制事务是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，此数据库只属于该应用，所以基于本应用自己的关系型数据库的事务又被称为本地事务。 

本地事务具有ACID四大特性，数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作 要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚。 

理解了本地事务，什么是分布式事务？

现在的需求是课程发布操作后将数据写入数据库、redis、elasticsearch、MinIO四个地方，这四个地方已经不限制在一个数据库内，是由四个分散的服务去提供，与这四个服务去通信需要网络通信，而网络存在不可到达性，这种分布式系统环境下，通过与不同的服务进行网络通信去完成事务称之为**分布式事务。**

在分布式系统中分布式事务的场景很多：

例如用户注册送积分，银行转账，创建订单减库存，这些都是分布式事务。

拿转账举例：

我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务： 

```Java
begin transaction； 
//1.本地数据库操作：张三减少金额 
//2.本地数据库操作：李四增加金额 
commit transation; 
```

但是在分布式环境下，会变成下边这样：

```Java
begin transaction； 
//1.本地数据库操作：张三减少金额 
//2.远程调用：让李四增加金额 

commit transation;
```

可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。 

因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应 用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。 

下边的场景都会产生分布式事务：

微服务架构下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQzNjc0N2ViZjFkOGIzZGQxNzgzYzExZjg5ZDNkOWRfN0VpUHB5dUFqTW9SeXBGZFdERnIzTmZWbXZuYzEzZGlfVG9rZW46STdIbmJrNkdEb0NjMlJ4MEw3M2NKb1JwbkJoXzE3MzIzNDMxMjA6MTczMjM0NjcyMF9WNA)

单服务多数据库：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=M2MyYmU4OWJkYmYyMTI4ZGE0OWE4NmFlOTZjNTQxNDVfVGNPWUV0c1B3MGkyeW5KUTRCQVlHZTFoNlJVeGx2UkxfVG9rZW46UTZabmJQS1Qxb2prRHV4UUtBcWNXelJhbndnXzE3MzIzNDMxMjA6MTczMjM0NjcyMF9WNA)

多服务单数据库:

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM1OWU5ZGEwNjc5N2EyMTcxMDkzZWYyZmM3NzIzNzFfVXkxcnFwTWJ5VU8xZzZ3UXZQVmNWbG1TZHlxQ0J1RjFfVG9rZW46VUtSSWJwU1lDb0J1dFB4dmNnaWNNOTJ4blVmXzE3MzIzNDMxMjA6MTczMjM0NjcyMF9WNA)

### 4.2.2 什么是CAP理论

控制分布式事务首先需要理解CAP理论，什么是CAP理论？

CAP是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性。

使用下边的分布式系统结构 进行说明：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjhlOWYwMmMyMzJkZmY4YzNkZWRiNWViZWRiOGZlNDdfM0NlMW50cmRPWjRYNkJqbmY5ZVV3RjdrNUlXRFpaNHVfVG9rZW46UWxLNWJqbXpzb040Vkp4QkZCb2NoM1BrbmxjXzE3MzIzNDMxMjA6MTczMjM0NjcyMF9WNA)

客户端经过网关访问用户服务的两个结点，一致性是指用户不管访问哪一个结点拿到的数据都是最新的，比如查询小明的信息，不能出现在数据没有改变的情况下两次查询结果不一样。

可用性是指任何时候查询用户信息都可以查询到结果，但不保证查询到最新的数据。

分区容忍性也叫分区容错性，当系统采用分布式架构时由于网络通信异常导致请求中断、消息丢失，但系统依然对外提供服务。

CAP理论要强调的是在分布式系统中这三点不可能全部满足，由于是分布式系统就要满足分区容忍性，因为服务之间难免出现网络异常，不能因为局部网络异常导致整个系统不可用。

满足P那么C和A不能同时满足：

比如我们添加一个用户小明的信息，该信息先添加到结点1中，再同步到结点2中，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231425059.png)

如果要满足C一致性，必须等待小明的信息同步完成系统才可用（否则会出现请求到结点2时查询不到数据，违反了一致性），在信息同步过程中系统是不可用的，所以满足C的同时无法满足A。

如果要满足A可用性，要时刻保证系统可用就不用等待信息同步完成，此时系统的一致性无法满足。

所以在分布式系统中进行分布式事务控制，要么保证CP、要么保证AP。

### 4.2.3 分布式事务控制方案

学习了CAP理论该如何控制分布式事务呢？

学习了CAP理论我们知道进行分布式事务控制要在C和A中作出取舍，保证一致性就不要保证可用性，保证可用性就不要保证一致，首先你确认是要CP还是AP，具体要根据应用场景进行判断。

CP的场景：满足C舍弃A，强调一致性。

跨行转账：一次转账请求要等待双方银行系统都完成整个事务才算完成，只要其中一个失败另一方执行回滚操作。

开户操作：在业务系统开户同时要在运营商开户，任何一方开户失败该用户都不可使用，所以要满足CP。

AP的场景：满足A舍弃C，强调可用性。

订单退款，今日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。

注册送积分，注册成功积分在24分到账。

支付短信通信，支付成功发短信，短信发送可以有延迟，甚至没有发送成功。

在实际应用中符合AP的场景较多，其实虽然AP舍弃C一致性，实际上最终数据还是达到了一致，也就满足了最终一致性，所以业界定义了BASE理论。

什么是BASE理论？

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。

基本可用：当系统无法满足全部可用时保证核心服务可用即可，比如一个外卖系统，每到中午12点左右系统并发量很高，此时要保证下单流程涉及的服务可用，其它服务暂时不可用。

软状态：是指可以存在中间状态，比如：打印自己的社保统计情况，该操作不会立即出现结果，而是提示你打印中，请在XXX时间后查收。虽然出现了中间状态，但最终状态是正确的。

最终一致性：退款操作后没有及时到账，经过一定的时间后账户到账，舍弃强一致性，满足最终一致性。

分布式事务控制有哪些常用的技术方案？

实现CP就是要实现强一致性:

使用Seata框架基于AT模式实现

使用Seata框架基于TCC模式实现。

实现AP则要保证最终数据一致性:

使用消息队列通知的方式去实现，通知失败自动重试，达到最大失败次数需要人工处理；

使用任务调度的方案，启动任务调度将课程信息由数据库同步到elasticsearch、MinIO、redis中。

### 4.2.4 课程发布的事务控制方案

学习了这么多的理论，回到课程发布，执行课程发布操作后要向数据库、redis、elasticsearch、MinIO写四份数据，这个场景用哪种方案？

满足CP？

如果要满足CP就表示课程发布操作后向数据库、redis、elasticsearch、MinIO写四份数据，只要有一份写失败其它的全部回滚。

满足AP？

课程发布操作后，先更新数据库中的课程发布状态，更新后向redis、elasticsearch、MinIO写课程信息，只要在一定时间内最终向redis、elasticsearch、MinIO写数据成功即可。

目前我们已经有了任务调度的技术积累，这里选用任务调度的方案去实现分布式事务控制，课程发布满足AP即可。

下图是具体的技术方案：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NmM4NzBiMWE2OTMzNjE3MzljYjdjMmJlOWY2MzRmNmVfamluNDNYNDQ2RlA2cHJ1a1J2bzFpU3dBZWV1TFd6d1JfVG9rZW46VVF6b2JkUHBIb2JWY1J4UUxUbGNPdUJsbk42XzE3MzIzNDMxMjA6MTczMjM0NjcyMF9WNA)

1、在内容管理服务的数据库中添加一个消息表，消息表和课程发布表在同一个数据库。

2、点击课程发布通过本地事务向课程发布表写入课程发布信息，同时向消息表写课程发布的消息。通过数据库进行控制，只要课程发布表插入成功消息表也插入成功，消息表的数据就记录了某门课程发布的任务。

3、启动任务调度系统定时调度内容管理服务去定时扫描消息表的记录。

4、当扫描到课程发布的消息时即开始完成向redis、elasticsearch、MinIO同步数据的操作。

5、同步数据的任务完成后删除消息表记录。

时序图如下：

下图是课程发布操作的流程：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231425230.png)

1、执行发布操作，内容管理服务存储课程发布表的同时向消息表添加一条“课程发布任务”。这里使用本地事务保证课程发布信息保存成功，同时消息表也保存成功。

2、任务调度服务定时调度内容管理服务扫描消息表，由于课程发布操作后向消息表插入一条课程发布任务，此时扫描到一条任务。

3、拿到任务开始执行任务，分别向redis、elasticsearch及文件系统存储数据。

4、任务完成后删除消息表记录。





# 7、消息处理SDK

### 4.4.1 消息模块技术方案

课程发布操作执行后需要扫描消息表的记录，有关消息表处理的有哪些？

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdkNjYxYTFiYjUzMjgxNDJiMjUyOTYxZDM3YzhkNjdfbU9POTFPdUp3QTNkQ1dmdVdSc3RNMVZiZDFpUmNtQUhfVG9rZW46SzI3SWJ3eG9sb0JPM3h4MEY0MmM4OTRPbkRoXzE3MzIzNDMxNTU6MTczMjM0Njc1NV9WNA)

上图中红色框内的都是与消息处理相关的操作：

1、新增消息表

2、扫描消息表。

3、更新消息表。

4、删除消息表。

使用消息表这种方式实现最终事务一致性的地方除了课程发布还有其它业务场景。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ0MjRmM2Q4OGNkZGFiNWI0ODFlN2MwMGY3NDg4NDNfY2E5MFMyM2poNFNCV2dDc1NvSWpyME1KMlVuZlRTVFZfVG9rZW46U2RTNmJ5N285bzF5SHV4Zm1WS2M0dXAwbndmXzE3MzIzNDMxNTU6MTczMjM0Njc1NV9WNA)

如果在每个地方都实现一套针对消息表定时扫描、处理的逻辑基本上都是重复的，软件的可复用性太低，成本太高。

如何解决这个问题？

针对这个问题可以想到将消息处理相关的逻辑做成一个通用的东西。

是做成通用的服务，还是做成通用的代码组件呢？

通用的服务是完成一个通用的独立功能，并提供独立的网络接口，比如：项目中的文件系统服务，提供文件的分布式存储服务。

代码组件也是完成一个通用的独立功能，通常会提供API的方式供外部系统使用，比如：fastjson、Apache commons工具包等。

如果将消息处理做成一个通用的服务，该服务需要连接多个数据库，因为它要扫描微服务数据库下的消息表，并且要提供与微服务通信的网络接口，单就针对当前需求而言开发成本有点高。

如果将消息处理做一个SDK工具包相比通用服务不仅可以解决将消息处理通用化的需求，还可以降低成本。

所以，本项目确定将对消息表相关的处理做成一个SDK组件供各微服务使用,如下图所示：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231425839.png)

下边对消息SDK的设计内容进行说明：

sdk需要提供执行任务的逻辑吗？

拿课程发布任务举例，执行课程发布任务是要向redis、索引库等同步数据，其它任务的执行逻辑是不同的，所以执行任务在sdk中不用实现任务逻辑，只需要提供一个抽象方法由具体的执行任务方去实现。

如何保证任务的幂等性？

在视频处理章节介绍的视频处理的幂等性方案，这里可以采用类似方案，任务执行完成后会从消息表删除，如果消息的状态是完成或不存在消息表中则不用执行。

如何保证任务不重复执行？

采用和视频处理章节一致方案，除了保证任务的幂等性外，任务调度采用分片广播，根据分片参数去获取任务，另外阻塞调度策略为丢弃任务。

注意：这里是信息同步类任务，即使任务重复执行也没有关系，不再使用抢占任务的方式保证任务不重复执行。

还有一个问题，根据消息表记录是否存在或消息表中的任务状态去保证任务的幂等性，如果一个任务有好几个小任务，比如：课程发布任务需要执行三个同步操作：存储课程到redis、存储课程到索引库，存储课程页面到文件系统。如果其中一个小任务已经完成也不应该去重复执行。这里该如何设计？

将小任务作为任务的不同的阶段，在消息表中设计阶段状态。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmI3YWIxODBiNjQ1NmI5ZmRkMTZhMmE0ZmI5NWRhMmRfazdkaWVxY3RlczJHQnBsa2RXbXpKR1ZxTUNRWFpGcE5fVG9rZW46WXRDQ2J3aTZXb1d3RnV4NDNVa2NHUFdlbldnXzE3MzIzNDMxNTU6MTczMjM0Njc1NV9WNA)

每完成一个阶段在相应的阶段状态字段打上完成标记，即使这个大任务没有完成再重新执行时，如果小阶段任务完成了也不会重复执行某个小阶段的任务。

综上所述，除了消息表的基本的增、删、改、查的接口外，消息SDK还具有如下接口功能：

```Java
package com.xuecheng.messagesdk.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.xuecheng.messagesdk.model.po.MqMessage;

import java.util.List;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author Mr.M
 * @since 2022-09-21
 */
public interface MqMessageService extends IService<MqMessage> {

    /**
     * @description 扫描消息表记录，采用与扫描视频处理表相同的思路
     * @param shardIndex 分片序号
     * @param shardTotal 分片总数
     * @param count 扫描记录数
     * @return java.util.List 消息记录
     * @author Mr.M
     * @date 2022/9/21 18:55
     */
    public List<MqMessage> getMessageList(int shardIndex, int shardTotal,  String messageType,int count);

    /**
     * @description 完成任务
     * @param id 消息id
     * @return int 更新成功：1
     * @author Mr.M
     * @date 2022/9/21 20:49
     */
    public int completed(long id);

    /**
     * @description 完成阶段任务
     * @param id 消息id
     * @return int 更新成功：1
     * @author Mr.M
     * @date 2022/9/21 20:49
     */
    public int completedStageOne(long id);
    public int completedStageTwo(long id);
    public int completedStageThree(long id);
    public int completedStageFour(long id);

    /**
     * @description 查询阶段状态
     * @param id
     * @return int
     * @author Mr.M
     * @date 2022/9/21 20:54
    */
    public int getStageOne(long id);
    public int getStageTwo(long id);
    public int getStageThree(long id);
    public int getStageFour(long id);

}
```

消息SDK提供消息处理抽象类，此抽象类供使用方去继承使用，如下：

```Java
package com.xuecheng.messagesdk.service;

import com.xuecheng.messagesdk.model.po.MqMessage;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.concurrent.*;

/**
 * @author Mr.M
 * @version 1.0
 * @description 消息处理抽象类
 * @date 2022/9/21 19:44
 */
@Slf4j
@Data
public abstract class MessageProcessAbstract {

    @Autowired
    MqMessageService mqMessageService;


    /**
     * @param mqMessage 执行任务内容
     * @return boolean true:处理成功，false处理失败
     * @description 任务处理
     * @author Mr.M
     * @date 2022/9/21 19:47
     */
    public abstract boolean execute(MqMessage mqMessage);


    /**
     * @description 扫描消息表多线程执行任务
     * @param shardIndex 分片序号
     * @param shardTotal 分片总数
     * @param messageType  消息类型
     * @param count  一次取出任务总数
     * @param timeout 预估任务执行时间,到此时间如果任务还没有结束则强制结束 单位秒
     * @return void
     * @author Mr.M
     * @date 2022/9/21 20:35
    */
    public void process(int shardIndex, int shardTotal,  String messageType,int count,long timeout) {

        try {
            //扫描消息表获取任务清单
            List<MqMessage> messageList = mqMessageService.getMessageList(shardIndex, shardTotal,messageType, count);
            //任务个数
            int size = messageList.size();
            log.debug("取出待处理消息"+size+"条");
            if(size<=0){
                return ;
            }

            //创建线程池
            ExecutorService threadPool = Executors.newFixedThreadPool(size);
            //计数器
            CountDownLatch countDownLatch = new CountDownLatch(size);
            messageList.forEach(message -> {
                threadPool.execute(() -> {
                    log.debug("开始任务:{}",message);
                    //处理任务
                    try {
                        boolean result = execute(message);
                        if(result){
                            log.debug("任务执行成功:{})",message);
                            //更新任务状态,删除消息表记录,添加到历史表
                            int completed = mqMessageService.completed(message.getId());
                            if (completed>0){
                                log.debug("任务执行成功:{}",message);
                            }else{
                                log.debug("任务执行失败:{}",message);
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                        log.debug("任务出现异常:{},任务:{}",e.getMessage(),message);
                    }
                    //计数
                    countDownLatch.countDown();
                    log.debug("结束任务:{}",message);

                });
            });

            //等待,给一个充裕的超时时间,防止无限等待，到达超时时间还没有处理完成则结束任务
            countDownLatch.await(timeout,TimeUnit.SECONDS);
            System.out.println("结束....");
        } catch (InterruptedException e) {
           e.printStackTrace();

        }

    }

}
```

### 4.4.2 消息模块SDK测试

1、在内容管理数据库创建消息表和消息历史表

2、拷贝课程资料中的xuecheng-plus-message-sdk到工程目录，如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE1NDIyZDFkNmEzNWYxMjE4M2Q0MGVjYjQxNzY3Y2Vfemhibk4zY1BqV1BCdzFiSVlydlh0OUlJbUVwZ05XaTJfVG9rZW46Um43emJOa0Vvb2RkeUR4Y2Nod2NTQTlVbkZlXzE3MzIzNDMxNTU6MTczMjM0Njc1NV9WNA)

3、修改test下的bootstrap.yml中的数据库连接

下边测试消息SDK的接口：

1、继承MessageProcessAbstract 抽象类编写任务执行方法

```Java
package com.xuecheng.messagesdk;

import com.xuecheng.messagesdk.model.po.MqMessage;
import com.xuecheng.messagesdk.service.MessageProcessAbstract;
import com.xuecheng.messagesdk.service.MqMessageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

/**
 * @description 消息处理测试类，继承MessageProcessAbstract
 * @author Mr.M
 * @date 2022/9/21 21:44
 * @version 1.0
 */
@Slf4j
@Component
public class MessageProcessClass extends MessageProcessAbstract {


    @Autowired
    MqMessageService mqMessageService;

    //执行任务
    @Override
    public boolean execute(MqMessage mqMessage) {
        Long id = mqMessage.getId();
        log.debug("开始执行任务:{}",id);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        //取出阶段状态
        int stageOne = mqMessageService.getStageOne(id);
        if(stageOne<1){
            log.debug("开始执行第一阶段任务");
            System.out.println();
            int i = mqMessageService.completedStageOne(id);
            if(i>0){
                log.debug("完成第一阶段任务");
            }

        }else{
            log.debug("无需执行第一阶段任务");
        }

        return true;
    }
}
```

2、编写测试类

```Java
package com.xuecheng.messagesdk;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2022/9/21 21:51
 */
@SpringBootTest
public class MessageProcessClassTest {

    @Autowired
    MessageProcessClass messageProcessClass;

    @Test
    public void test() {

        System.out.println("开始执行-----》" + LocalDateTime.now());
        messageProcessClass.process(0, 1, "test", 5, 30);
        System.out.println("结束执行-----》" + LocalDateTime.now());
        Thread.sleep(9000000);
    }
}
```

3、准备测试数据，在消息表添加消息类型为"test"的消息

4、执行MessageProcessClassTest 类中的test()方法，观察控制台任务执行的日志信息。

### 4.4.3 集成消息SDK

#### 4.4.3.1 添加消息

1、在内容管理数据库创建消息表和消息历史表

2、拷贝课程资料中的xuecheng-plus-message-sdk到工程目录，如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDMyNzcyZmVhYTU4MGNkY2RkM2VlZTFhYzVhN2YwNDJfUEkzUGpJdFRCV1NhZDdISTBaV25UMXhHelpXTkkxaDVfVG9rZW46R1lleWJWV1Zhb01oOVh4M0tHRGNrVGV3bkVmXzE3MzIzNDMxNTU6MTczMjM0Njc1NV9WNA)

3、在内容管理service工程中添加sdk依赖

```XML
<dependency>
    <groupId>com.xuecheng</groupId>
    <artifactId>xuecheng-plus-message-sdk</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

4、课程发布操作使用本地事务保存课程发布信息、添加消息表。

回到当初编写课程发布时的代码，如下：

```Java
@Transactional
@Override
public void publish(Long companyId, Long courseId) {

 //约束校验
 //查询课程预发布表
 CoursePublishPre coursePublishPre = coursePublishPreMapper.selectById(courseId);
 if(coursePublishPre == null){
    XueChengPlusException.cast("请先提交课程审核，审核通过才可以发布");
 }
 //本机构只允许提交本机构的课程
 if(!coursePublishPre.getCompanyId().equals(companyId)){
  XueChengPlusException.cast("不允许提交其它机构的课程。");
 }

 //课程审核状态
 String auditStatus = coursePublishPre.getStatus();
 //审核通过方可发布
 if(!"202004".equals(auditStatus)){
  XueChengPlusException.cast("操作失败，课程审核通过方可发布。");
 }
 //保存课程发布信息
 saveCoursePublish(courseId);

 //保存消息表
 saveCoursePublishMessage(courseId);

//删除课程预发布表对应记录
 coursePublishPreMapper.deleteById(courseId);

}
```

我们要填充的saveCoursePublishMessage(courseId)方法，如下：

```Java
 /**
  * @description 保存消息表记录
  * @param courseId  课程id
  * @return void
  * @author Mr.M
  * @date 2022/9/20 16:32
  */
private void saveCoursePublishMessage(Long courseId){
 MqMessage mqMessage = mqMessageService.addMessage("course_publish", String.valueOf(courseId), null, null);
 if(mqMessage==null){
  XueChengPlusException.cast(CommonError.UNKOWN_ERROR);
 }
}
```

下边进行测试：

发布一门课程，观察消息表是否正常添加消息。

需要手动修改课程审核状态为审核通过执行发布操作，发布后可以修改发布状态为下架重新发布测试。

#### 4.4.3.2 课程发布任务处理

在内容管理服务添加消息处理sdk的依赖即可使用它，实现sdk中的MessageProcessAbstract类，重写execte方法。

实现sdk中的MessageProcessAbstract类：

```Java
package com.xuecheng.content.service.jobhandler;

import com.xuecheng.messagesdk.model.po.MqMessage;
import com.xuecheng.messagesdk.service.MessageProcessAbstract;
import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.handler.annotation.XxlJob;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2022/9/22 10:16
 */
@Slf4j
@Component
public class CoursePublishTask extends MessageProcessAbstract {

    //课程发布任务处理
    @Override
    public boolean execute(MqMessage mqMessage) {
        //获取消息相关的业务信息
        String businessKey1 = mqMessage.getBusinessKey1();
        long courseId = Integer.parseInt(businessKey1);
        //课程静态化
        generateCourseHtml(mqMessage,courseId);
        //课程索引
        saveCourseIndex(mqMessage,courseId);
        //课程缓存
        saveCourseCache(mqMessage,courseId);
        return true;
    }


    //生成课程静态化页面并上传至文件系统
    public void generateCourseHtml(MqMessage mqMessage,long courseId){

        log.debug("开始进行课程静态化,课程id:{}",courseId);
        //消息id
        Long id = mqMessage.getId();
        //消息处理的service
        MqMessageService mqMessageService = this.getMqMessageService();
        //消息幂等性处理
        int stageOne = mqMessageService.getStageOne(id);
        if(stageOne >0){
            log.debug("课程静态化已处理直接返回，课程id:{}",courseId);
            return ;
        }
        try {
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        //保存第一阶段状态
        mqMessageService.completedStageOne(id);

    }

    //将课程信息缓存至redis
    public void saveCourseCache(MqMessage mqMessage,long courseId){
        log.debug("将课程信息缓存至redis,课程id:{}",courseId);
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }


    }
    //保存课程索引信息
    public void saveCourseIndex(MqMessage mqMessage,long courseId){
        log.debug("保存课程索引信息,课程id:{}",courseId);
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

    }

}
```

#### 4.4.3.3 开启任务调度

1、首先在内容管理service工程中添加xxl-job依赖

```XML
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
</dependency>
```

2、配置执行器

在nacos中在content-service-dev.yaml中配置

```YAML
xxl:
  job:
    admin: 
      addresses: http://192.168.101.65:8088/xxl-job-admin
    executor:
      appname: coursepublish-job
      address: 
      ip: 
      port: 8999
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 30
    accessToken: default_token
```

3、从媒资管理服务层工程中拷贝一个XxlJobConfig配置类到内容管理service工程中。

在xxl-job-admin控制台中添加执行器

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I3N2FlMGZiZWQzN2NlMjE2Nzc1YTgwNTJmMGExYWRfRWJ0c3ZtNDJOMW9kWGJ3UXM4V2JYWDJLSnJ4TVVxcExfVG9rZW46UWpMS2JpcXNNb1ZOaDB4WXZHNGNzMkYzblRlXzE3MzIzNDMxNTU6MTczMjM0Njc1NV9WNA)

3、编写任务调度入口

```Java
@Slf4j
@Component
public class CoursePublishTask extends MessageProcessAbstract {

    //任务调度入口
    @XxlJob("CoursePublishJobHandler")
    public void coursePublishJobHandler() throws Exception {
        // 分片参数
        int shardIndex = XxlJobHelper.getShardIndex();
        int shardTotal = XxlJobHelper.getShardTotal();
        log.debug("shardIndex="+shardIndex+",shardTotal="+shardTotal);
        //参数:分片序号、分片总数、消息类型、一次最多取到的任务数量、一次任务调度执行的超时时间
        process(shardIndex,shardTotal,"course_publish",30,60);
    }
    ....
```

4、在xxl-job添加任务

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231426279.png)

任务配置如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231426719.png)

到此SDK开发、集成完成，下一步添加课程发布后页面静态化、课程缓存、课程索引等任务。

#### 4.4.3.4 测试

在消息表添加课程发布的消息，消息类型为course_publish,business_key1为发布课程的ID

1、测试是否可以正常调度执行。

2、测试任务幂等性

在 saveCourseCache(mqMessage,courseId);处打断点，待执行到这里观察数据库第一阶段完成的标记预期标记为1。

结束进程，再重新启动，观察第一阶段的任务预期不再执行。

3、任务执行完成删除消息表记录，插入历史表，state状态字段为1







# 8、熔断降级处理

#### 4.5.4.1 什么是熔断降级

微服务中难免存在服务之间的远程调用，比如：内容管理服务远程调用媒资服务的上传文件接口，当微服务运行不正常会导致无法正常调用微服务，此时会出现异常，如果这种异常不去处理可能导致雪崩效应。

微服务的雪崩效应表现在服务与服务之间调用，当其中一个服务无法提供服务可能导致其它服务也死掉，比如：服务B调用服务A，由于A服务异常导致B服务响应缓慢，最后B、C等服务都不可用，像这样由一个服务所引起的一连串的多个服务无法提供服务即是微服务的雪崩效应，如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTYwYTk1MmFlMTI0ZDVlMDU3OWQwOWRjMzhkN2UzODlfYUZjSnhYMjZxcWlGVWlxclRBSVdSNVVaY1VrRlF5OHZfVG9rZW46QldNZGI5M0ljb1gxOWV4YjJmZ2NSVFNWbkpiXzE3MzIzNDMxODg6MTczMjM0Njc4OF9WNA)

如何解决由于微服务异常引起的雪崩效应呢？

可以采用熔断、降级的方法去解决。

熔断降级的相同点都是为了解决微服务系统崩溃的问题，但它们是两个不同的技术手段，两者又存在联系。

熔断：

当下游服务异常而断开与上游服务的交互，它就相当于保险丝，下游服务异常触发了熔断，从而保证上游服务不受影响。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231426820.png)

降级：

当下游服务异常触发熔断后，上游服务就不再去调用异常的微服务而是执行了降级处理逻辑，这个降级处理逻辑可以是本地一个单独的方法。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTgxOTNhN2M1MWQ4ODJmNzYxYmExMTgzYmQyZWRiOWRfVjlsQUxpWVFobk9jUjl1MTJFeExhMWIyVEpmSHpPODVfVG9rZW46WnNkWmJFNG5Fb2NtWGd4SEp1dWNnR3U0bjhiXzE3MzIzNDMxODg6MTczMjM0Njc4OF9WNA)

两者都是为了保护系统，熔断是当下游服务异常时一种保护系统的手段，降级是熔断后上游服务处理熔断的方法。

#### 4.5.4.2 熔断降级处理

项目使用Hystrix框架实现熔断、降级处理，在feign-dev.yaml中配置。

1、开启Feign熔断保护

```YAML
feign:
  hystrix:
    enabled: true
  circuitbreaker:
    enabled: true
```

2、设置熔断的超时时间，为了防止一次处理时间较长触发熔断这里还需要设置请求和连接的超时时间，如下：

```Bash
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 30000  #熔断超时时间
ribbon:
  ConnectTimeout: 60000 #连接超时时间
  ReadTimeout: 60000 #读超时时间
  MaxAutoRetries: 0 #重试次数
  MaxAutoRetriesNextServer: 1 #切换实例的重试次数
```

3、定义降级逻辑

两种方法：

1）fallback 

```Java
@FeignClient(value = "media-api",configuration = MultipartSupportConfig.class,fallback = MediaServiceClientFallback.class)
@RequestMapping("/media")
public interface MediaServiceClient{
...
```

定义一个fallback类MediaServiceClientFallback，此类实现了MediaServiceClient接口。

第一种方法无法取出熔断所抛出的异常，第二种方法定义MediaServiceClientFallbackFactory 可以解决这个问题。

2）fallbackFactory 

第二种方法在FeignClient中指定fallbackFactory ，如下：

```Java
@FeignClient(value = "media-api",configuration = MultipartSupportConfig.class,fallbackFactory = MediaServiceClientFallbackFactory.class)
```

定义MediaServiceClientFallbackFactory如下：

```Java
@Slf4j
@Component
public class MediaServiceClientFallbackFactory implements FallbackFactory<MediaServiceClient> {
    @Override
    public MediaServiceClient create(Throwable throwable) {
        return new MediaServiceClient(){
            @Override
            public String uploadFile(MultipartFile upload, String objectName) {
                //降级方法
                log.debug("调用媒资管理服务上传文件时发生熔断，异常信息:{}",throwable.toString(),throwable);
                return null;
            }
        };
    }
}
```

降级处理逻辑：

返回一个null对象，上游服务请求接口得到一个null说明执行了降级处理。

测试：

停止媒资管理服务或人为制造异常观察是否执行降级逻辑。







# 9、课程搜索

## 5.1 需求分析

### 5.1.1 模块介绍

搜索功能是一个系统的重要功能，是信息查询的方式。课程搜索是课程展示的渠道，用户通过课程搜索找到课程信息，进一步去查看课程的详细信息，进行选课、支付、学习。

本项目的课程搜索支持全文检索技术，什么是全文检索？

[全文检索](https://baike.baidu.com/item/全文检索/8028630?fromModule=lemma_inlink)是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。

全文检索可以简单理解为通过索引搜索文章。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427316.png)

全文检索的速度非常快，早期应用在搜索引擎技术中，比如：百度、google等，现在通常一些大型网站的搜索功能都是采用全文检索技术。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MGU0NTgwMjcxNjNiMDEzMjY3NjkwMTY0Y2VkMTFkMWZfTFJRaVJBRmZBV0ROMjhlWHc3M240bnFIVlRIV3V5ZUFfVG9rZW46RE5YdWJaNGFub2RURlJ4ZjRYY2NLTGdKbmZmXzE3MzIzNDMyMjE6MTczMjM0NjgyMV9WNA)

课程搜索也要将课程信息建立索引，在课程发布时建立课程索引，索引建立好用户可通过搜索网页去查询课程信息。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MWUwMjQ0YjAzZmEzMGYyOGYwNzdjNjQ3OTYwMGFjYjJfTzQxOFZkWXN1VmtPdHRvbmVrNEZqejNWY25mejA1QW5fVG9rZW46THE1c2JjdHVxbzV6UWt4ZHRRYWNJOUtKblNyXzE3MzIzNDMyMjE6MTczMjM0NjgyMV9WNA)

所以，课程搜索模块包括两部分：课程索引、课程搜索。

课程索引是将课程信息建立索引。

课程搜索是通过前端网页，通过关键字等条件去搜索课程。

### 5.1.2 业务流程

根据模块介绍的内容，课程搜索模块包括课程索引、课程搜索两部分。

1、课程索引

在课程发布操作执行后通过消息处理方式创建课程索引，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427422.png)

本项目使用elasticsearch作为索引及搜索服务。

2、课程搜索

课程索引创建完成，用户才可以通过前端搜索课程信息。

课程搜索可以从首页进入搜索页面。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427530.png)

下图是搜索界面，可以通过课程分类、课程难度等级等条件进行搜索。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhkZTY1ZmNkZDM3YWZhYjZlNDM2YjczYzc2Y2ZiMzVfeGJad1R3MW1TaTVpdGVSdmNrc0JnZm5sODFGRVFUVktfVG9rZW46RzR4TmIyRlFWb2Z4ZlZ4bkVmZGN3SWpRbjhnXzE3MzIzNDMyMjE6MTczMjM0NjgyMV9WNA)

## 5.2 准备环境

### 5.2.1 搭建elasticsearch

在课前下发的虚拟中已经在docker容器中安装了elasticsearch和kibana。

kibana 是 ELK（Elasticsearch , Logstash, Kibana ）之一，kibana 一款开源的数据分析和可视化平台，通过可视化界面访问elasticsearch的索引库，并可以生成一个数据报表。

开发中主要使用kibana通过api对elasticsearch进行索引和搜索操作，通过浏览器访问 http://192.168.101.65:5601/app/dev_tools#/console进入kibana的开发工具界面。

修改虚拟机中的启动脚本restart.sh添加

```Java
docker stop elasticsearch
docker stop kibana

docker start elasticsearch
docker start kibana
```

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NWRjM2M1MzljZWMyODE2YzljMGQ3N2M1MjQxMmE3OGJfTkNZQVVoZEJtWjZlTVg3ODJOVm1CQ3dVNDdTOXdkaW1fVG9rZW46VWtXWWI0RFRMb3NqMUx4STVPd2N0SndwbmtlXzE3MzIzNDMyMjE6MTczMjM0NjgyMV9WNA)

可通过命令：GET /_cat/indices?v  查看所有的索引，通过此命令判断kibana是否正常连接elasticsearch。

索引相当于MySQL中的表，Elasticsearch与MySQL之间概念的对应关系见下表：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427730.png)

要使用elasticsearch需要建立索引，Mapping相当于表结构，Mapping创建后其字段不能删除，如果要删除需要删除整个索引，下边介绍创建索引、查询索引、删除索引的方法：

1、创建索引，并指定Mapping。

PUT /course-publish

```JSON
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 0
  },
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "companyId": {
        "type": "keyword"
      },
      "companyName": {
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart",
        "type": "text"
      },
      "name": {
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart",
        "type": "text"
      },
      "users": {
        "index": false,
        "type": "text"
      },
      "tags": {
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart",
        "type": "text"
      },
      "mt": {
        "type": "keyword"
      },
      "mtName": {
        "type": "keyword"
      },
      "st": {
        "type": "keyword"
      },
      "stName": {
        "type": "keyword"
      },
      "grade": {
        "type": "keyword"
      },
      "teachmode": {
        "type": "keyword"
      },
      "pic": {
        "index": false,
        "type": "text"
      },
      "description": {
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart",
        "type": "text"
      },
      "createDate": {
        "format": "yyyy-MM-dd HH:mm:ss",
        "type": "date"
      },
      "status": {
        "type": "keyword"
      },
      "remark": {
        "index": false,
        "type": "text"
      },
      "charge": {
        "type": "keyword"
      },
      "price": {
        "type": "scaled_float",
        "scaling_factor": 100
      },
      "originalPrice": {
        "type": "scaled_float",
        "scaling_factor": 100
      },
      "validDays": {
        "type": "integer"
      }
    }
  }
}
```

2、查询索引

通过 GET /_cat/indices?v 查询所有的索引，查找course-publish是否创建成功。

通过GET /course-publish/_mapping 查询course-publish的索引结构。

```JSON
{
  "course-publish" : {
    "mappings" : {
      "properties" : {
        "charge" : {
          "type" : "keyword"
        },
        "companyId" : {
          "type" : "keyword"
        },
        "companyName" : {
          "type" : "text",
          "analyzer" : "ik_max_word",
          "search_analyzer" : "ik_smart"
        },
        "createDate" : {
          "type" : "date",
          "format" : "yyyy-MM-dd HH:mm:ss"
        },
        "description" : {
          "type" : "text",
          "analyzer" : "ik_max_word",
          "search_analyzer" : "ik_smart"
        },
        "grade" : {
          "type" : "keyword"
        },
        "id" : {
          "type" : "keyword"
        },
        "mt" : {
          "type" : "keyword"
        },
        "mtName" : {
          "type" : "keyword"
        },
        "name" : {
          "type" : "text",
          "analyzer" : "ik_max_word",
          "search_analyzer" : "ik_smart"
        },
        "originalPrice" : {
          "type" : "scaled_float",
          "scaling_factor" : 100.0
        },
        "pic" : {
          "type" : "text",
          "index" : false
        },
        "price" : {
          "type" : "scaled_float",
          "scaling_factor" : 100.0
        },
        "remark" : {
          "type" : "text",
          "index" : false
        },
        "st" : {
          "type" : "keyword"
        },
        "stName" : {
          "type" : "keyword"
        },
        "status" : {
          "type" : "keyword"
        },
        "tags" : {
          "type" : "text",
          "analyzer" : "ik_max_word",
          "search_analyzer" : "ik_smart"
        },
        "teachmode" : {
          "type" : "keyword"
        },
        "users" : {
          "type" : "text",
          "index" : false
        },
        "validDays" : {
          "type" : "integer"
        }
      }
    }
  }
}
```

3、删除索引

如果发现创建的course-publish不正确可以删除重新创建。

删除索引后当中的文档数据也同时删除，一定要谨慎操作！

删除索引命令：DELETE /course-publish

### 5.2.2 部署搜索工程

拷贝课程资料中的xuecheng-plus-search搜索工程到自己的工程目录。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427935.png)

修改bootstrap.xml中nacos的namespace为自己的命名空间。

启动网关、搜索服务。

部署完成通过httpclient进行测试

```Java
### 添加课程索引
POST {{search_host}}/search/index/course
Content-Type: application/json

{
  "charge" : "201000",
  "companyId" : 100000,
  "companyName" : "北京黑马程序",
  "createDate" : "2022-09-25 09:36:11",
  "description" : "《Spring编程思想》是2007年6月1日机械工业出版社出版的图书，作者是埃克尔，译者是陈昊鹏。主要内容本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作",
  "grade" : "204001",
  "id" : 102,
  "mt" : "1-3",
  "mtName" : "编程开发",
  "name" : "Spring编程思想",
  "originalPrice" : 200.0,
  "pic" : "/mediafiles/2022/09/20/1d0f0e6ed8a0c4a89bfd304b84599d9c.png",
  "price" : 100.0,
  "remark" : "没有备注",
  "st" : "1-3-2",
  "stName" : "Java语言",
  "status" : "203002",
  "tags" : "没有标签",
  "teachmode" : "200002",
  "validDays" : 222
}



### 搜索课程
GET {{search_host}}/search/course/list?pageNo=1&keywords=spring
Content-Type: application/json
```

进入前端搜索界面http://www.51xuecheng.cn/course/search.html

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=N2NmN2NiYjk5ODEyMGUzZWMyYzc3ZGQzMGUyYTJmNWVfazYxMXdpbTRKTjhSTlc0akNqWG5mVnQxellaYWprWTRfVG9rZW46R1dnV2IxQUhSb3ZaZFR4RzhabWN4S1Bmbk5QXzE3MzIzNDMyMjE6MTczMjM0NjgyMV9WNA)

## 5.3 索引管理

### 5.3.1 REST API

#### 5.3.1.1 添加文档

索引创建好就可以向其中添加文档，此时elasticsearch会根据索引的mapping配置对有些字段进行分词。

这里我们要向course_publish中添加课程信息。

使用rest api进行测试，如下：

使用post请求，/course-publish/_doc/103  第一部分为索引名称，_doc固定，103为文档的主键id，这里为课程id。

课程内容使用json表示。

```JSON
POST /course-publish/_doc/103
{
  "charge" : "201001",
  "companyId" : 100000,
  "companyName" : "北京黑马程序",
  "createDate" : "2022-09-25 09:36:11",
  "description" : "HTML/CSS",
  "grade" : "204001",
  "id" : 102,
  "mt" : "1-1",
  "mtName" : "前端开发",
  "name" : "Html参考大全",
  "originalPrice" : 200.0,
  "pic" : "/mediafiles/2022/09/20/e726b71ba99c70e8c9d2850c2a7019d7.jpg",
  "price" : 100.0,
  "remark" : "没有备注",
  "st" : "1-1-1",
  "stName" : "HTML/CSS",
  "status" : "203002",
  "tags" : "没有标签",
  "teachmode" : "200002",
  "validDays" : 222
}
```

如果要修改文档的内容可以使用上边相同的方法，如果没有则添加，如果存在则更新。

#### 5.3.1.2 查询文档

添加文档成功后可以通过主键id查询该文档的信息。

语法如下：

```JSON
GET /{索引库名称}/_doc/{id}
```

#### 5.3.1.3 更新文档

更新文档分为全量更新和局部更新。

全量更新是指先删除再更新，语法如下：

```JSON
PUT /{索引库名}/_doc/文档id
{
    "字段1": "值1",
    "字段2": "值2",
    // ... 略
}
```

局部更新语法如下：

```JSON
POST /{索引库名}/_update/文档id
{
    "doc": {
         "字段名": "新的值",
    }
}
```

#### 5.3.1.4 删除文档

删除文档将从索引中删除文档的记录。

语法如下：

```JSON
DELETE /{索引库名}/_doc/id值
```

### 5.3.2 接口定义

当课程发布时请求添加课程接口添加课程信息到索引，当课程下架时请求删除课程接口从索引中删除课程信息，这里先实现添加课程接口。

根据索引的mapping结构创建po类：

```Java
package com.xuecheng.search.po;

import com.alibaba.fastjson.annotation.JSONField;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * <p>
 * 课程索引信息
 * </p>
 *
 * @author itcast
 */
@Data
public class CourseIndex implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    private Long id;

    /**
     * 机构ID
     */
    private Long companyId;

    /**
     * 公司名称
     */
    private String companyName;

    /**
     * 课程名称
     */
    private String name;

    /**
     * 适用人群
     */
    private String users;

    /**
     * 标签
     */
    private String tags;


    /**
     * 大分类
     */
    private String mt;

    /**
     * 大分类名称
     */
    private String mtName;

    /**
     * 小分类
     */
    private String st;

    /**
     * 小分类名称
     */
    private String stName;



    /**
     * 课程等级
     */
    private String grade;

    /**
     * 教育模式
     */
    private String teachmode;
    /**
     * 课程图片
     */
    private String pic;

    /**
     * 课程介绍
     */
    private String description;


    /**
     * 发布时间
     */
    @JSONField(format="yyyy-MM-dd HH:mm:ss")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createDate;

    /**
     * 状态
     */
    private String status;

    /**
     * 备注
     */
    private String remark;

    /**
     * 收费规则，对应数据字典--203
     */
    private String charge;

    /**
     * 现价
     */
    private Float price;
    /**
     * 原价
     */
    private Float originalPrice;

    /**
     * 课程有效期天数
     */
    private Integer validDays;


}
```

创建索引接口如下：

```Java
package com.xuecheng.search.controller;

import com.xuecheng.base.execption.XueChengPlusException;
import com.xuecheng.search.po.CourseIndex;
import com.xuecheng.search.service.IndexService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author Mr.M
 * @version 1.0
 * @description 课程索引接口
 * @date 2022/9/24 22:31
 */
@Api(value = "课程信息索引接口", tags = "课程信息索引接口")
@RestController
@RequestMapping("/index")
public class CourseIndexController {

    @ApiOperation("添加课程索引")
    @PostMapping("course")
    public Boolean add(@RequestBody CourseIndex courseIndex) {


    }
}
```

### 5.3.3 接口开发

定义service接口，请求elasticsearch添加课程信息。

注意：为了适应其它文档信息，将添加文档定义为通用的添加文档接口，此接口不仅适应添加课程还适应添加其它信息。

```Java
package com.xuecheng.search.service;

import com.xuecheng.search.po.CourseIndex;

/**
 * @author Mr.M
 * @version 1.0
 * @description 课程索引service
 * @date 2022/9/24 22:40
 */
public interface IndexService {

    /**
     * @param indexName 索引名称
     * @param id 主键
     * @param object 索引对象
     * @return Boolean true表示成功,false失败
     * @description 添加索引
     * @author Mr.M
     * @date 2022/9/24 22:57
     */
    public Boolean addCourseIndex(String indexName,String id,Object object);



}
```

接口实现如下：

```Java
package com.xuecheng.search.service.impl;

import com.alibaba.fastjson.JSON;
import com.xuecheng.base.execption.XueChengPlusException;
import com.xuecheng.search.po.CourseIndex;
import com.xuecheng.search.service.IndexService;
import lombok.extern.slf4j.Slf4j;
import org.elasticsearch.action.DocWriteResponse;
import org.elasticsearch.action.delete.DeleteRequest;
import org.elasticsearch.action.delete.DeleteResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.xcontent.XContentType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.IOException;

/**
 * @description 课程索引管理接口实现
 * @author Mr.M
 * @date 2022/9/25 7:23
 * @version 1.0
 */
@Slf4j
@Service
public class IndexServiceImpl implements IndexService {



 @Autowired
 RestHighLevelClient client;

 @Override
 public Boolean addCourseIndex(String indexName,String id,Object object) {
  String jsonString = JSON.toJSONString(object);
  IndexRequest indexRequest = new IndexRequest(indexName).id(id);
  //指定索引文档内容
  indexRequest.source(jsonString,XContentType.JSON);
  //索引响应对象
  IndexResponse indexResponse = null;
  try {
   indexResponse = client.index(indexRequest, RequestOptions.DEFAULT);
  } catch (IOException e) {
   log.error("添加索引出错:{}",e.getMessage());
   e.printStackTrace();
   XueChengPlusException.cast("添加索引出错");
  }
  String name = indexResponse.getResult().name();
  System.out.println(name);
  return name.equalsIgnoreCase("created") || name.equalsIgnoreCase("updated");

 }

 
}
```

### 5.3.4 接口完善

完善接口：

```Java
package com.xuecheng.search.controller;

import com.xuecheng.base.execption.XueChengPlusException;
import com.xuecheng.search.po.CourseIndex;
import com.xuecheng.search.service.IndexService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author Mr.M
 * @version 1.0
 * @description 课程索引接口
 * @date 2022/9/24 22:31
 */
@Api(value = "课程信息索引接口", tags = "课程信息索引接口")
@RestController
@RequestMapping("/index")
public class CourseIndexController {

    @Value("${elasticsearch.course.index}")
    private String courseIndexStore;

    @Autowired
    IndexService indexService;

    @ApiOperation("添加课程索引")
    @PostMapping("course")
    public Boolean add(@RequestBody CourseIndex courseIndex) {
    
        Long id = courseIndex.getId();
        if(id==null){
            XueChengPlusException.cast("课程id为空");
        }
        Boolean result = indexService.addCourseIndex(courseIndexStore, String.valueOf(id), courseIndex);
        if(!result){
            XueChengPlusException.cast("添加课程索引失败");
        }
        return result;
    
    }
}
```

### 5.3.5 接口测试

使用httpclient进行测试

```JSON
### 添加课程索引
POST {{search_host}}/search/index/course
Content-Type: application/json

{
  "charge" : "201000",
  "companyId" : 100000,
  "companyName" : "北京黑马程序员",
  "createDate" : "2022-09-25 09:36:11",
  "description" : "《Java编程思想》是2007年6月1日机械工业出版社出版的图书，作者是埃克尔，译者是陈昊鹏。主要内容本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作",
  "grade" : "204001",
  "id" : 102,
  "mt" : "1-3",
  "mtName" : "编程开发",
  "name" : "Java编程思想",
  "originalPrice" : 200.0,
  "pic" : "/mediafiles/2022/09/20/1d0f0e6ed8a0c4a89bfd304b84599d9c.png",
  "price" : 100.0,
  "remark" : "没有备注",
  "st" : "1-3-2",
  "stName" : "Java语言",
  "status" : "203002",
  "tags" : "没有标签",
  "teachmode" : "200002",
  "validDays" : 222
}
```

## 5.4  搜索

### 5.4.1 需求分析

索引信息维护完成下一步定义搜索接口搜索课程信息，首先需要搞清楚搜索功能的需求。

进入搜索界面，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427118.png)

根据搜索界面可知需求如下：

1、根据一级分类、二级分类搜索课程信息。

2、根据关键字搜索课程信息，搜索方式为全文检索，关键字需要匹配课程的名称、 课程内容。

3、根据难度等级搜索课程。

4、搜索结点分页显示。

技术点：

1、整体采用布尔查询。

2、根据关键字搜索，采用MultiMatchQuery，搜索name、description字段。

3、根据分类、课程等级搜索采用过滤器实现。

4、分页查询。

5、高亮显示。

为什么课程分类、课程等级等查询使用过滤器方式？

使用关键字查询需要计算相关度得分，根据课程分类、课程等级去查询不需要计算相关度得分，使用过滤器实现根据课程分类、课程等级查询的过程不会计算相关度得分，效率更高。

### 5.4.2 接口定义

1、定义搜索条件DTO类

```Java
package com.xuecheng.search.dto;

import lombok.Data;
import lombok.ToString;

/**
 * @description 搜索课程参数dtl
 * @author Mr.M
 * @date 2022/9/24 22:36
 * @version 1.0
 */
 @Data
 @ToString
public class SearchCourseParamDto {

  //关键字
  private String keywords;

  //大分类
  private String mt;

  //小分类
  private String st;
  //难度等级
  private String grade;


}
```

2、为了适应后期的扩展，定义搜索结果类，让它继承PageResult

```Java
package com.xuecheng.search.dto;

import com.xuecheng.base.model.PageResult;
import lombok.Data;
import lombok.ToString;

import java.util.List;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2022/9/25 17:51
 */
@Data
@ToString
public class SearchPageResultDto<T> extends PageResult {

    public SearchPageResultDto(List<T> items, long counts, long page, long pageSize) {
        super(items, counts, page, pageSize);
    }

}
```

接口定义如下：

```Java
package com.xuecheng.search.controller;

import com.xuecheng.base.model.PageParams;
import com.xuecheng.base.model.PageResult;
import com.xuecheng.search.dto.SearchCourseParamDto;
import com.xuecheng.search.po.CourseIndex;
import com.xuecheng.search.service.CourseSearchService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * @description 课程搜索接口
 * @author Mr.M
 * @date 2022/9/24 22:31
 * @version 1.0
 */
@Api(value = "课程搜索接口",tags = "课程搜索接口")
 @RestController
 @RequestMapping("/course")
public class CourseSearchController {



 @ApiOperation("课程搜索列表")
  @GetMapping("/list")
 public PageResult<CourseIndex> list(PageParams pageParams, SearchCourseParamDto searchCourseParamDto){

    
   
  }
}
```

### 5.4.3 基本功能实现

定义service接口，如下：

```Java
package com.xuecheng.search.service;

import com.xuecheng.base.model.PageParams;
import com.xuecheng.base.model.PageResult;
import com.xuecheng.search.dto.SearchCourseParamDto;
import com.xuecheng.search.dto.SearchPageResultDto;
import com.xuecheng.search.po.CourseIndex;

/**
 * @description 课程搜索service
 * @author Mr.M
 * @date 2022/9/24 22:40
 * @version 1.0
 */
public interface CourseSearchService {


    /**
     * @description 搜索课程列表
     * @param pageParams 分页参数
     * @param searchCourseParamDto 搜索条件
     * @return com.xuecheng.base.model.PageResult<com.xuecheng.search.po.CourseIndex> 课程列表
     * @author Mr.M
     * @date 2022/9/24 22:45
    */
    SearchPageResultDto<CourseIndex> queryCoursePubIndex(PageParams pageParams, SearchCourseParamDto searchCourseParamDto);

 }
```

搜索接口的内容较多，我们分几步实现，首先实现根据分页搜索，接口实现如下：

```Java
package com.xuecheng.search.service.impl;

import com.alibaba.fastjson.JSON;
import com.xuecheng.base.model.PageParams;
import com.xuecheng.base.model.PageResult;
import com.xuecheng.search.dto.SearchCourseParamDto;
import com.xuecheng.search.dto.SearchPageResultDto;
import com.xuecheng.search.po.CourseIndex;
import com.xuecheng.search.service.CourseSearchService;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.lucene.search.TotalHits;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.text.Text;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.MultiMatchQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.Aggregations;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * @author Mr.M
 * @version 1.0
 * @description 课程搜索service实现类
 * @date 2022/9/24 22:48
 */
@Slf4j
@Service
public class CourseSearchServiceImpl implements CourseSearchService {

    @Value("${elasticsearch.course.index}")
    private String courseIndexStore;
    @Value("${elasticsearch.course.source_fields}")
    private String sourceFields;

    @Autowired
    RestHighLevelClient client;

    @Override
    public SearchPageResultDto<CourseIndex> queryCoursePubIndex(PageParams pageParams, SearchCourseParamDto courseSearchParam) {

        //设置索引
        SearchRequest searchRequest = new SearchRequest(courseIndexStore);

        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
        //source源字段过虑
        String[] sourceFieldsArray = sourceFields.split(",");
        searchSourceBuilder.fetchSource(sourceFieldsArray, new String[]{});
        
        //分页
        Long pageNo = pageParams.getPageNo();
        Long pageSize = pageParams.getPageSize();
        int start = (int) ((pageNo-1)*pageSize);
        searchSourceBuilder.from(start);
        searchSourceBuilder.size(Math.toIntExact(pageSize));
       //布尔查询
        searchSourceBuilder.query(boolQueryBuilder);
        
        //请求搜索
        searchRequest.source(searchSourceBuilder);
       
        
        SearchResponse searchResponse = null;
        try {
            searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
        } catch (IOException e) {
            e.printStackTrace();
            log.error("课程搜索异常：{}",e.getMessage());
            return new SearchPageResultDto<CourseIndex>(new ArrayList(),0,0,0);
        }

        //结果集处理
        SearchHits hits = searchResponse.getHits();
        SearchHit[] searchHits = hits.getHits();
        //记录总数
        TotalHits totalHits = hits.getTotalHits();
        //数据列表
        List<CourseIndex> list = new ArrayList<>();

        for (SearchHit hit : searchHits) {

            String sourceAsString = hit.getSourceAsString();
            CourseIndex courseIndex = JSON.parseObject(sourceAsString, CourseIndex.class);
            list.add(courseIndex);

        }
        SearchPageResultDto<CourseIndex> pageResult = new SearchPageResultDto<>(list, totalHits.value,pageNo,pageSize);

        

        return pageResult;
    }


}
```

### 5.4.4 基本功能测试

当输入查询条件时会查询全部课程信息并支持分页查询。

1、准备测试

启动nginx、网关、搜索服务。

使用kibana通过rest api向索引库添加课程信息，或通过httpclient添加课程信息，至少添加两条信息。

2、进入搜索界面

默认查询出刚才添加的课程信息。

3、修改分页参数测试分页

打开course/ search.html页面 ，找到如下图所示位置：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427431.png)

修改pageSize为1,即一页显示一条记录。

刷新搜索界面，每页显示一条记录，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427160.png)

### 5.4.5 根据条件搜索

下边实现根据关键、一级分类、二级分类、难度等级搜索。

```Java
@Override
public SearchPageResultDto<CourseIndex> queryCoursePubIndex(PageParams pageParams, SearchCourseParamDto courseSearchParam) {

    //设置索引
    SearchRequest searchRequest = new SearchRequest(courseIndexStore);

    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
    //source源字段过虑
    String[] sourceFieldsArray = sourceFields.split(",");
    searchSourceBuilder.fetchSource(sourceFieldsArray, new String[]{});
    if(courseSearchParam==null){
        courseSearchParam = new SearchCourseParamDto();
    }
    //关键字
    if(StringUtils.isNotEmpty(courseSearchParam.getKeywords())){
        //匹配关键字
        MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeywords(), "name", "description");
        //设置匹配占比
        multiMatchQueryBuilder.minimumShouldMatch("70%");
        //提升另个字段的Boost值
        multiMatchQueryBuilder.field("name",10);
        boolQueryBuilder.must(multiMatchQueryBuilder);
    }
    //过虑
    if(StringUtils.isNotEmpty(courseSearchParam.getMt())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("mtName",courseSearchParam.getMt()));
    }
    if(StringUtils.isNotEmpty(courseSearchParam.getSt())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("stName",courseSearchParam.getSt()));
    }
    if(StringUtils.isNotEmpty(courseSearchParam.getGrade())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("grade",courseSearchParam.getGrade()));
    }
    //分页
    Long pageNo = pageParams.getPageNo();
    Long pageSize = pageParams.getPageSize();
    int start = (int) ((pageNo-1)*pageSize);
    searchSourceBuilder.from(start);
    searchSourceBuilder.size(Math.toIntExact(pageSize));
    //布尔查询
    searchSourceBuilder.query(boolQueryBuilder);
    
    //请求搜索
    searchRequest.source(searchSourceBuilder);
   
    SearchResponse searchResponse = null;
    try {
        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    } catch (IOException e) {
        e.printStackTrace();
        log.error("课程搜索异常：{}",e.getMessage());
        return new SearchPageResultDto<CourseIndex>(new ArrayList(),0,0,0);
    }

    //结果集处理
    SearchHits hits = searchResponse.getHits();
    SearchHit[] searchHits = hits.getHits();
    //记录总数
    TotalHits totalHits = hits.getTotalHits();
    //数据列表
    List<CourseIndex> list = new ArrayList<>();

    for (SearchHit hit : searchHits) {

        String sourceAsString = hit.getSourceAsString();
        CourseIndex courseIndex = JSON.parseObject(sourceAsString, CourseIndex.class);

        
        list.add(courseIndex);

    }
    SearchPageResultDto<CourseIndex> pageResult = new SearchPageResultDto<>(list, totalHits.value,pageNo,pageSize);

    

    return pageResult;
}
```

### 5.4.6 条件搜索测试

进入搜索界面，输入关键字进行测试。

一级分类、二级分类在下边的聚合搜索中测试。

### 5.4.7 聚合搜索

搜索界面上显示的一级分类、二级分类来源于搜索结果，使用聚合搜索实现找到搜索结果中的一级分类、二级分类。

1、首先在搜索结构DTO中添加一级分类、二级分类列表

```Java
package com.xuecheng.search.dto;

import com.xuecheng.base.model.PageResult;
import lombok.Data;
import lombok.ToString;

import java.util.List;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2022/9/25 17:51
 */
@Data
@ToString
public class SearchPageResultDto<T> extends PageResult {

    //大分类列表
    List<String> mtList;
    //小分类列表
    List<String> stList;

    public SearchPageResultDto(List<T> items, long counts, long page, long pageSize) {
        super(items, counts, page, pageSize);
    }

}
```

2、搜索方法如下：

```Java
@Override
public SearchPageResultDto<CourseIndex> queryCoursePubIndex(PageParams pageParams, SearchCourseParamDto courseSearchParam) {

    //设置索引
    SearchRequest searchRequest = new SearchRequest(courseIndexStore);

    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
    //source源字段过虑
    String[] sourceFieldsArray = sourceFields.split(",");
    searchSourceBuilder.fetchSource(sourceFieldsArray, new String[]{});
    if(courseSearchParam==null){
        courseSearchParam = new SearchCourseParamDto();
    }
    //关键字
    if(StringUtils.isNotEmpty(courseSearchParam.getKeywords())){
        //匹配关键字
        MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeywords(), "name", "description");
        //设置匹配占比
        multiMatchQueryBuilder.minimumShouldMatch("70%");
        //提升另个字段的Boost值
        multiMatchQueryBuilder.field("name",10);
        boolQueryBuilder.must(multiMatchQueryBuilder);
    }
    //过虑
    if(StringUtils.isNotEmpty(courseSearchParam.getMt())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("mtName",courseSearchParam.getMt()));
    }
    if(StringUtils.isNotEmpty(courseSearchParam.getSt())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("stName",courseSearchParam.getSt()));
    }
    if(StringUtils.isNotEmpty(courseSearchParam.getGrade())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("grade",courseSearchParam.getGrade()));
    }
    //分页
    Long pageNo = pageParams.getPageNo();
    Long pageSize = pageParams.getPageSize();
    int start = (int) ((pageNo-1)*pageSize);
    searchSourceBuilder.from(start);
    searchSourceBuilder.size(Math.toIntExact(pageSize));
    //布尔查询
    searchSourceBuilder.query(boolQueryBuilder);
   
   
    //请求搜索
    searchRequest.source(searchSourceBuilder);
    //聚合设置
    buildAggregation(searchRequest);
    SearchResponse searchResponse = null;
    try {
        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    } catch (IOException e) {
        e.printStackTrace();
        log.error("课程搜索异常：{}",e.getMessage());
        return new SearchPageResultDto<CourseIndex>(new ArrayList(),0,0,0);
    }

    //结果集处理
    SearchHits hits = searchResponse.getHits();
    SearchHit[] searchHits = hits.getHits();
    //记录总数
    TotalHits totalHits = hits.getTotalHits();
    //数据列表
    List<CourseIndex> list = new ArrayList<>();

    for (SearchHit hit : searchHits) {

        String sourceAsString = hit.getSourceAsString();
        CourseIndex courseIndex = JSON.parseObject(sourceAsString, CourseIndex.class);

        

        list.add(courseIndex);

    }
    SearchPageResultDto<CourseIndex> pageResult = new SearchPageResultDto<>(list, totalHits.value,pageNo,pageSize);

    //获取聚合结果
    List<String> mtList= getAggregation(searchResponse.getAggregations(), "mtAgg");
    List<String> stList = getAggregation(searchResponse.getAggregations(), "stAgg");

    pageResult.setMtList(mtList);
    pageResult.setStList(stList);

    return pageResult;
}
```

### 5.4.8 聚合搜索测试

进入搜索界面，观察搜索请求的响应内容中是否存在mtList和stList.

观察页面一级分类、二级分类是否有分类信息。

注意：当选中一个一级分类时才会显示二级分类。

### 5.4.9 高亮设置

最后实现关键词在课程名称中高亮显示。

```Java
@Override
public SearchPageResultDto<CourseIndex> queryCoursePubIndex(PageParams pageParams, SearchCourseParamDto courseSearchParam) {

    //设置索引
    SearchRequest searchRequest = new SearchRequest(courseIndexStore);

    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
    //source源字段过虑
    String[] sourceFieldsArray = sourceFields.split(",");
    searchSourceBuilder.fetchSource(sourceFieldsArray, new String[]{});
    if(courseSearchParam==null){
        courseSearchParam = new SearchCourseParamDto();
    }
    //关键字
    if(StringUtils.isNotEmpty(courseSearchParam.getKeywords())){
        //匹配关键字
        MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeywords(), "name", "description");
        //设置匹配占比
        multiMatchQueryBuilder.minimumShouldMatch("70%");
        //提升另个字段的Boost值
        multiMatchQueryBuilder.field("name",10);
        boolQueryBuilder.must(multiMatchQueryBuilder);
    }
    //过虑
    if(StringUtils.isNotEmpty(courseSearchParam.getMt())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("mtName",courseSearchParam.getMt()));
    }
    if(StringUtils.isNotEmpty(courseSearchParam.getSt())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("stName",courseSearchParam.getSt()));
    }
    if(StringUtils.isNotEmpty(courseSearchParam.getGrade())){
        boolQueryBuilder.filter(QueryBuilders.termQuery("grade",courseSearchParam.getGrade()));
    }
    //分页
    Long pageNo = pageParams.getPageNo();
    Long pageSize = pageParams.getPageSize();
    int start = (int) ((pageNo-1)*pageSize);
    searchSourceBuilder.from(start);
    searchSourceBuilder.size(Math.toIntExact(pageSize));
    //布尔查询
    searchSourceBuilder.query(boolQueryBuilder);
    //高亮设置
    HighlightBuilder highlightBuilder = new HighlightBuilder();
    highlightBuilder.preTags("<font class='eslight'>");
    highlightBuilder.postTags("</font>");
    //设置高亮字段
    highlightBuilder.fields().add(new HighlightBuilder.Field("name"));
    searchSourceBuilder.highlighter(highlightBuilder);
    //请求搜索
    searchRequest.source(searchSourceBuilder);
    //聚合设置
    buildAggregation(searchRequest);
    SearchResponse searchResponse = null;
    try {
        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    } catch (IOException e) {
        e.printStackTrace();
        log.error("课程搜索异常：{}",e.getMessage());
        return new SearchPageResultDto<CourseIndex>(new ArrayList(),0,0,0);
    }

    //结果集处理
    SearchHits hits = searchResponse.getHits();
    SearchHit[] searchHits = hits.getHits();
    //记录总数
    TotalHits totalHits = hits.getTotalHits();
    //数据列表
    List<CourseIndex> list = new ArrayList<>();

    for (SearchHit hit : searchHits) {

        String sourceAsString = hit.getSourceAsString();
        CourseIndex courseIndex = JSON.parseObject(sourceAsString, CourseIndex.class);

        //取出source
        Map<String, Object> sourceAsMap = hit.getSourceAsMap();

        //课程id
        Long id = courseIndex.getId();
        //取出名称
        String name = courseIndex.getName();
        //取出高亮字段内容
        Map<String, HighlightField> highlightFields = hit.getHighlightFields();
        if(highlightFields!=null){
            HighlightField nameField = highlightFields.get("name");
            if(nameField!=null){
                Text[] fragments = nameField.getFragments();
                StringBuffer stringBuffer = new StringBuffer();
                for (Text str : fragments) {
                    stringBuffer.append(str.string());
                }
                name = stringBuffer.toString();

            }
        }
        courseIndex.setId(id);
        courseIndex.setName(name);

        list.add(courseIndex);

    }
    SearchPageResultDto<CourseIndex> pageResult = new SearchPageResultDto<>(list, totalHits.value,pageNo,pageSize);

    //获取聚合结果
    List<String> mtList= getAggregation(searchResponse.getAggregations(), "mtAgg");
    List<String> stList = getAggregation(searchResponse.getAggregations(), "stAgg");

    pageResult.setMtList(mtList);
    pageResult.setStList(stList);

    return pageResult;
}
```

### 5.4.10 高亮设置测试

输入关键字，观察搜索结果，标题中是否对关键字信息进行高亮显示。

## 5.5 课程信息索引同步

### 5.5.1 技术方案1

通过向索引中添加课程信息最终实现了课程的搜索，我们发现课程信息是先保存在关系数据库中，而后再写入索引，这个过程是将关系数据中的数据同步到elasticsearch索引中的过程，可以简单成为索引同步。

通常项目中使用elasticsearch需要完成索引同步，索引同步的方法很多：

1、针对实时性非常高的场景需要满足数据的及时同步，可以同步调用，或使用Canal去实现。

1）同步调用即在向MySQL写数据后远程调用搜索服务的接口写入索引，此方法简单但是耦合代码太高。

2）可以使用一个中间的软件canal解决耦合性的问题，但存在学习与维护成本。

canal主要用途是基于 MySQL 数据库增量日志解析，并能提供增量数据订阅和消费，实现将MySQL的数据同步到消息队列、Elasticsearch、其它数据库等，应用场景十分丰富。 

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427478.png)

它的地址：

github地址：https://github.com/alibaba/canal 

版本下载地址：https://github.com/alibaba/canal/releases 

文档地址：https://github.com/alibaba/canal/wiki/Docker-QuickStart 

Canal基于mysql的binlog技术实现数据同步，什么是binlog，它是一个文件，二进制格式，记录了对数据库更新的SQL语句，向数据库写数据的同时向binlog文件里记录对应的sql语句。当数据库服务器发生了故障就可以使用binlog文件对数据库进行恢复。

所以，使用canal是需要开启mysql的binlog写入功能，Canal工作原理如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427170.png)

1、canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 

协议 

2、MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) 

3、canal 解析 binary log 对象(原始为 byte 流)

详细使用Canal进行索引同步的步骤参考：Canal实现索引同步.pdf

2、当索引同步的实时性要求不高时可用的技术比较多，比如：MQ、Logstash、任务调度等。

MQ：向mysql写数据的时候向mq写入消息，搜索服务监听MQ，收到消息后写入索引。使用MQ的优势是代码解耦，但是需要处理消息可靠性的问题有一定的技术成本，做到消息可靠性需要做到生产者投递成功、消息持久化以及消费者消费成功三个方面，另外还要做好消息幂等性问题。

Logstash： 开源实时日志分析平台 ELK包括Elasticsearch、Kibana、Logstash，Logstash负责收集、解析和转换日志信息，可以实现MySQL与Elasticsearch之间的数据同步。也可以实现解耦合并且是官方推荐，但需要增加学习与维护成本。

任务调度：向mysql写数据的时候记录修改记录，开启一个定时任务根据修改记录将数据同步到Elasticsearch。

根据本项目的需求，课程发布后信息同步的实时性要求不高，从提交审核到发布成功一般两个工作日完成。综合比较以上技术方案本项目的索引同步技术使用任务调度的方法。

如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231427877.png)

1、课程发布向消息表插入记录。

2、由任务调度程序通过消息处理SDK对消息记录进行处理。

3、向elasticsearch索引中保存课程信息。

如何向向elasticsearch索引中保存课程信息？

执行流程如下：

由内容管理服务远程调用搜索服务添加课程信息索引，搜索服务再请求elasticsearch向课程索引中添加文档。

### 5.5.2 课程索引任务开发

1、拷贝CourseIndex 模型类到内容管理model 工程的dto包下。

2、在内容管理服务中添加FeignClient

```Java
package com.xuecheng.content.feignclient;

import com.xuecheng.content.model.dto.CourseIndex;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * @description 搜索服务远程接口
 * @author Mr.M
 * @date 2022/9/20 20:29
 * @version 1.0
 */
@FeignClient(value = "search",fallbackFactory = SearchServiceClientFallbackFactory.class)
public interface SearchServiceClient {

 @PostMapping("/search/index/course")
 public Boolean add(@RequestBody CourseIndex courseIndex);
}
```

定义SearchServiceClientFallbackFactory ：

```Java
@Slf4j
@Component
public class SearchServiceClientFallbackFactory implements FallbackFactory<SearchServiceClient> {
    @Override
    public SearchServiceClient create(Throwable throwable) {

        return new SearchServiceClient() {

            @Override
            public Boolean add(CourseIndex courseIndex) {
                throwable.printStackTrace();
                log.debug("调用搜索发生熔断走降级方法,熔断异常:", throwable.getMessage());

                return false;
            }
        };
    }
}
```

3、编写课程索引任务执行方法

完善CoursePublishTask类中的saveCourseIndex方法

```Java
//保存课程索引信息
public void saveCourseIndex(MqMessage mqMessage,long courseId){
    log.debug("保存课程索引信息,课程id:{}",courseId);

    //消息id
    Long id = mqMessage.getId();
    //消息处理的service
    MqMessageService mqMessageService = this.getMqMessageService();
    //消息幂等性处理
    int stageTwo = mqMessageService.getStageTwo(id);
    if(stageTwo > 0){
        log.debug("课程索引已处理直接返回，课程id:{}",courseId);
        return ;
    }

    //取出课程发布信息
    CoursePublish coursePublish = coursePublishMapper.selectById(courseId);
    //拷贝至课程索引对象
    CourseIndex courseIndex = new CourseIndex();
    BeanUtils.copyProperties(coursePublish,courseIndex);
    //远程调用搜索服务api添加课程信息到索引
    Boolean add = searchServiceClient.add(courseIndex);
    if(!add){
        XueChengPlusException.cast("添加索引失败");
    }
  //保存第一阶段状态
   mqMessageService.completedStageTwo(id);
}
```

### 5.5.3 测试

测试流程如下：

1、启动elasticsearch、kibana。

2、启动网关、内容管理、搜索服务、nginx。

3、启动xxl-job调度中心。

4、在任务调度中心开始课程发布任务。

5、发布一门课程，页面提示操作成功，查看发布课程任务是否写到任务表。

6、经过任务调度将课程信息写入索引。

7、通过门户进入搜索页面，查看课程信息是否展示。







# 10、认证授权模块

## 10.1 模块需求分析

### 1.1 什么是认证授权

截至目前，项目已经完成了课程发布功能，课程发布后用户通过在线学习页面点播视频进行学习。如何去记录学生的学习过程呢？要想掌握学生的学习情况就需要知道用户的身份信息，记录哪个用户在什么时间学习什么课程，如果用户要购买课程也需要知道用户的身份信息。所以，去管理学生的学习过程最基本的要实现用户的身份认证。

认证授权模块实现平台所有用户的身份认证与用户授权功能。

什么是用户身份认证？

        用户身份认证即用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证的表现形式有：用户名密码登录，微信扫码等方式。

项目包括学生、学习机构的老师、平台运营人员三类用户，不管哪一类用户在访问项目受保护资源时都需要进行身份认证。比如：发布课程操作，需要学习机构的老师首先登录系统成功，然后再执行发布课程操作。创建订单，需要学生用户首先登录系统，才可以创建订单。如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FmMzAyMGFhOWQ0Mjg5NDFmOWExMjJlODA3NDEzOWJfU0FYUTRtSXF2Vm5GYUlpQ09xVW0xOHZTR1Q2czRITXRfVG9rZW46R0xmdGJOUEM0b01QdW94NTNkS2NiM1FpblZkXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

什么是用户授权？

        用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。比如：用户去发布课程，系统首先进行用户身份认证，认证通过后继续判断用户是否有发布课程的权限，如果没有权限则拒绝继续访问系统，如果有权限则继续发布课程。如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500382.png)

### 1.2 业务流程

#### 1.2.1 统一认证

项目包括学生、学习机构的老师、平台运营人员三类用户，三类用户将使用统一的认证入口，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500964.png)

用户输入账号和密码提交认证，认证通过则继续操作。

项目由统一认证服务受理用户的认证请求，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231428407.png)

认证通过由认证服务向给用户颁发令牌，相当于访问系统的通行证，用户拿着令牌去访问系统的资源。

#### 1.2.2 单点登录

本项目基于微服务架构构建，微服务包括：内容管理服务、媒资管理服务、学习中心服务、系统管理服务等，为了提高用户体验性，用户只需要认证一次便可以在多个拥有访问权限的系统中访问，这个功能叫做单点登录。

引用百度百科：单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

如下图，用户只需要认证一次，便可以在多个拥有访问权限的系统中访问。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500076.png)

#### 1.2.3 第三方认证

为了提高用户体验，很多网站有扫码登录的功能，如：微信扫码登录、QQ扫码登录等。扫码登录的好处是用户不用输入账号和密码，操作简便，另外一个好处就是有利于用户信息的共享，互联网的优势就是资源共享，用户也是一种资源，对于一个新网站如果让用户去注册是很困难的，如果提供了微信扫码登录将省去用户注册的成本，是一种非常有效的推广手段。

微信扫码登录其中的原理正是使用了第三方认证，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500009.png)

## 10.2 Spring Security 认证研究

### 2.1 Spring Security介绍

认证功能几乎是每个项目都要具备的功能，并且它与业务无关，市面上有很多认证框架，如：Apache Shiro、CAS、Spring Security等。由于本项目基于Spring Cloud技术构建，Spring Security是spring家族的一份子且和Spring Cloud集成的很好，所以本项目选用Spring Security作为认证服务的技术框架。

Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架，它是一个专注于为 Java 应用程序提供身份验证和授权的框架。

项目主页：https://spring.io/projects/spring-security

Spring cloud Security： https://spring.io/projects/spring-cloud-security

### 2.2 认证授权入门

#### 2.2.1 创建认证服务工程

下边我们使用Spring Security框架快速构建认证授权功能体系。

1、部署认证服务工程

从课程资料中拷贝xuecheng-plus-auth工程到自己的工程目录下。

此工程是一个普通的spring boot工程，可以连接数据库。

此工程不具备认证授权的功能。

2、创建数据库

创建xc_users数据库

导入课程资料中的xcplus_users.sql脚本。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500740.png)

在nacos中新增auth-service-dev.yaml：

```YAML
server:
  servlet:
    context-path: /auth
  port: 63070
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://192.168.101.65:3306/xc1010_users?serverTimezone=UTC&userUnicode=true&useSSL=false&
    username: root
    password: mysql
```

初始工程自带了一个Controller类，如下：

```Java
package com.xuecheng.auth.controller;


/**
 * @author Mr.M
 * @version 1.0
 * @description 测试controller
 * @date 2022/9/27 17:25
 */
@Slf4j
@RestController
public class LoginController {

  @Autowired
  XcUserMapper userMapper;

  @RequestMapping("/login-success")
  public String loginSuccess(){

      return "登录成功";
  }


  @RequestMapping("/user/{id}")
  public XcUser getuser(@PathVariable("id") String id){
    XcUser xcUser = userMapper.selectById(id);
    return xcUser;
  }

  @RequestMapping("/r/r1")
  public String r1(){
    return "访问r1资源";
  }

  @RequestMapping("/r/r2")
  public String r2(){
    return "访问r2资源";
  }



}
```

启动工程，尝试访问http://localhost:63070/auth/r/r1 :

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231428574.png)

访问用户信息：http://localhost:63070/auth/user/52 

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500556.png)

以上测试一切正常说明此工程部署成功。

#### 2.2.2 认证测试

下边向auth认证工程集成Spring security，向pom.xml加入Spring Security所需要的依赖

```XML
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>
```

重启工程，访问http://localhost:63070/auth/r/r1

自动进入/login登录页面，/login是spring security提供的,此页面有几个css样式加载会稍微慢点，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500692.png)

账号和密码是多少呢？下一步需要进行安全配置。

拷贝课程资料下的WebSecurityConfig.java到config下需要三部分内容：

1、用户信息

在内存配置两个用户：zhangsan、lisi

zhangsan用户拥有的权限为p1

lisi用户拥有的权限为p2

2、密码方式

暂时采用明文方式

3、安全拦截机制

/r/**开头的请求需要认证

登录成功到成功页面

代码如下：

```Java
//配置用户信息服务
@Bean
public UserDetailsService userDetailsService() {
    //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
            manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
    manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
    return manager;
}

    @Bean
    public PasswordEncoder passwordEncoder() {
        //密码为明文方式
        return NoOpPasswordEncoder.getInstance();
    }

    //配置安全拦截机制
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                .antMatchers("/r/**").authenticated()//访问/r开始的请求需要认证通过
                .anyRequest().permitAll()//其它请求全部放行
                .and()
                .formLogin().successForwardUrl("/login-success");//登录成功跳转到/login-success
                http.logout().logoutUrl("/logout");//退出地址
    }
```

重启工程

1、访问http://localhost:63070/auth/user/52  可以正常访问

2、访问http://localhost:63070/auth/r/r1 显示登录页面

账号zhangsan，密码为123，如果输入的密码不正确会认证失败，输入正确显示登录成功。

为什么http://localhost:63070/auth/user/52  可以正常访问，访问http://localhost:63070/auth/r/r1 显示登录页面？

http.logout().logoutUrl("/logout");配置了退出页面，认证成功后访问/logout可退出登录。

#### 2.2.3 授权测试

用户认证通过去访问系统资源时spring security进行授权控制，判断用户是否有该资源的访问权限，如果有则继续访问，如果没有则拒绝访问。

下边测试授权功能：

1、配置用户拥有哪些权限。

在WebSecurityConfig类配置zhangsan拥有p1权限，lisi拥有p2权限。

```Java
    @Bean
    public UserDetailsService userDetailsService() {
        //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
        manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
        return manager;
    }
```

2、指定资源与权限的关系。

什么是系统的资源？

比如：查询一个用户的信息，用户信息就是系统的资源，要访问资源需要通过URL，所以我们在controller中定义的每个http的接口就是访问资源的接口。

下边在controller中配置/r/r1需要p1权限，/r/r2需要p2权限。

hasAuthority('p1')表示拥有p1权限方可访问。

代码如下：

```Java
@RestController
public class LoginController {
    ....
    @RequestMapping("/r/r1")
    @PreAuthorize("hasAuthority('p1')")//拥有p1权限方可访问
    public String r1(){
      return "访问r1资源";
    }
    
    @RequestMapping("/r/r2")
    @PreAuthorize("hasAuthority('p2')")//拥有p2权限方可访问
    public String r2(){
      return "访问r2资源";
    }
    ...
```

现在重启工程。

当访问以/r/开头的url时会判断用户是否认证，如果没有认证则跳转到登录页面，如果已经认证则判断用户是否具有该URL的访问权限，如果具有该URL的访问权限则继续，否则拒绝访问。

例如：

访问/r/r1，使用zhangsan登录可以正常访问，因为在/r/r1的方法上指定了权限p1，zhangsan用户拥有权限p1,所以可以正常访问。

访问/r/r1，使用lisi登录则拒绝访问，由于lisi用户不具有权限p1需要拒绝访问

注意：如果访问上不加@PreAuthorize，此方法没有授权控制。

整理授权的过程见下图所示：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500943.png)

#### 2.2.4 工作原理

通过测试认证和授权两个功能，我们了解了Spring Security的基本使用方法，下边了解它的工作流程。

Spring Security所解决的问题就是**安全访问控制**，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的，所以从这个Filter来入手，逐步深入Spring Security原理。

        当初始化Spring Security时，会创建一个名为`SpringSecurityFilterChain`的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此类，下图是Spring Security过虑器链结构图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFlNDNmMmJkNTBhOGE3MzI0NDNhODMzYjQ2NTNhMDhfWW5iUWlMTkVqNlJxTW16Ukp1eEJxUnVUSUpnelUydFNfVG9rZW46SFZMbmJrTmVWbzdSMk94ZGxFamM4TERIbmtjXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的**认证**，也不直接处理用户的**授权**，而是把它们交给了认证管理器（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理。

spring Security功能的实现主要是由一系列过滤器链相互配合完成。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500880.png)

下面介绍过滤器链中主要的几个过滤器及其作用：

**SecurityContextPersistenceFilter** 这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给 SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext；

**UsernamePasswordAuthenticationFilter** 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；

**FilterSecurityInterceptor** 是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问，前面已经详细介绍过了；

**ExceptionTranslationFilter** 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。

Spring Security的执行流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500919.png)

1. 用户提交用户名、密码被SecurityFilterChain中的`UsernamePasswordAuthenticationFilter`过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。
2. 然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证
3. 认证成功后，`AuthenticationManager`身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）`Authentication`实例。
4. `SecurityContextHolder`安全上下文容器将第3步填充了信息的`Authentication`，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。
5.         可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个`List<AuthenticationProvider>`列表，存放多种认证方式，最终实际的认证工作是由AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。

### 2.3 什么是OAuth2

#### 2.3.1 OAuth2认证流程

在前边我们提到微信扫码认证，这是一种第三方认证的方式，这种认证方式是基于OAuth2协议实现，

OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。

        Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。

参考：https://baike.baidu.com/item/oAuth/7153134?fr=aladdin

Oauth协议：https://tools.ietf.org/html/rfc6749

下边分析一个Oauth2认证的例子，黑马程序员网站使用微信认证扫码登录的过程：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429357.png)

具体流程如下：

1、用户点击微信扫码

用户进入黑马程序的登录页面，点击微信的图标开打微信扫码界面。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500384.png)

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500272.png)

微信扫码的目的是通过微信认证登录黑马程序员官网，黑马程序员网站需要从微信获取当前用户的身份信息才会让当前用户在黑马网站登录成功。

现在搞清楚几个概念：

资源：用户信息，在微信中存储。

资源拥有者：用户是用户信息资源的拥有者。

认证服务：微信负责认证当前用户的身份，负责为客户端颁发令牌。

客户端：客户端会携带令牌请求微信获取用户信息，黑马程序员网站即客户端，黑马网站需要在浏览器打开。

2、用户授权黑马网站访问用户信息

资源拥有者扫描二维码表示资源拥有者请求微信进行认证，微信认证通过向用户手机返回授权页面，如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg1MTk5ODg1OGJlZDExZWQxNjE5NzZhM2I3MzA2YzlfNlo4RXl1UklrNUNmMVJjQUZyVDlqTTJnQjMxTXBVMVZfVG9rZW46V1JVM2JxYmtYb3Zwc0J4d052dGN6VVZqbnY1XzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

询问用户是否授权黑马程序员访问自己在微信的用户信息，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码给黑马程序员的网站。

只有资源拥有者同意微信才允许黑马网站访问资源。

3、黑马程序员的网站获取到授权码

4、携带授权码请求微信认证服务器申请令牌

此交互过程用户看不到。

5、微信认证服务器向黑马程序员的网站响应令牌

此交互过程用户看不到。

6、黑马程序员网站请求微信资源服务器获取资源即用户信息。

黑马程序员网站携带令牌请求访问微信服务器获取用户的基本信息。

7、资源服务器返回受保护资源即用户信息

8、黑马网站接收到用户信息，此时用户在黑马网站登录成功。

理解了微信扫码登录黑马网站的流程，接下来认识Oauth2.0的认证流程，如下：

引自Oauth2.0协议rfc6749 https://tools.ietf.org/html/rfc6749

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500014.png)

Oauth2包括以下角色：

1、客户端

本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：手机客户端、浏览器等。

上边示例中黑马网站即为客户端，它需要通过浏览器打开。

2、资源拥有者

通常为用户，也可以是应用程序，即该资源的拥有者。

A表示 客户端请求资源拥有者授权。

B表示 资源拥有者授权客户端即黑马网站访问自己的用户信息。

3、授权服务器（也称认证服务器）

认证服务器对资源拥有者进行认证，还会对客户端进行认证并颁发令牌。

C 客户端即黑马网站携带授权码请求认证。

D认证通过颁发令牌。

4、资源服务器

存储资源的服务器。

E表示客户端即黑马网站携带令牌请求资源服务器获取资源。

F表示资源服务器校验令牌通过后提供受保护资源。

#### 2.3.2 OAuth2在本项目的应用

Oauth2是一个标准的开放的授权协议，应用程序可以根据自己的要求去使用Oauth2，本项目使用Oauth2实现如下目标：

1、学成在线访问第三方系统的资源。

本项目要接入微信扫码登录所以本项目要使用OAuth2协议访问微信中的用户信息。

2、外部系统访问学成在线的资源  。

同样当第三方系统想要访问学成在线网站的资源也可以基于OAuth2协议。

3、学成在线前端（客户端） 访问学成在线微服务的资源。

本项目是前后端分离架构，前端访问微服务资源也可以基于OAuth2协议进行认证。

#### 2.3.3 OAuth2的授权模式

Spring Security支持OAuth2认证，OAuth2提供授权码模式、密码模式、简化模式、客户端模式等四种授权模式，前边举的微信扫码登录的例子就是基于授权码模式，这四种模式中授权码模式和密码模式应用较多，本节使用Spring Security演示授权码模式、密码模式，其余两种请自行查阅相关资料。

##### 2.3.3.1 授权码模式

OAuth2的几个授权模式是根据不同的应用场景以不同的方式去获取令牌，最终目的是要获取认证服务颁发的令牌，最终通过令牌去获取资源。

授权码模式简单理解是使用授权码去获取令牌，要想获取令牌先要获取授权码，授权码的获取需要资源拥有者亲自授权同意才可以获取。

下图是授权码模式的交互图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDAzNDU3Nzc0YWIzOGMwZTk3ZmVjZGM5MmNlYjgxY2VfQVh5R3VTaXZ5V3M0eEc3Y3FibzNZRGVMdXpmZEhROU1fVG9rZW46SmdidmJPZlVab2NiZ0R4S2NUaGNHM1VqbmViXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

还以黑马网站微信扫码登录为例进行说明：

1、用户打开浏览器。

2、通过浏览器访问客户端即黑马网站。

3、用户通过浏览器向认证服务请求授权，请求授权时会携带客户端的URL，此URL为下发授权码的重定向地址。

4、认证服务向资源拥有者返回授权页面。

5、资源拥有者亲自授权同意。

6、通过浏览器向认证服务发送授权同意。

7、认证服务向客户端地址重定向并携带授权码。

8、客户端即黑马网站收到授权码。

9、客户端携带授权码向认证服务申请令牌。

10、认证服务向客户端颁发令牌。

##### 2.3.3.2授权码模式测试

要想测试授权模式首先要配置授权服务器即上图中的认证服务器，需要配置授权服务及令牌策略。

1、从课程资料中拷贝 AuthorizationServer.java、TokenConfig.java到认证服务的config包下。

说明“：AuthorizationServer用 @EnableAuthorizationServer 注解标识并继承AuthorizationServerConfigurerAdapter来配置OAuth2.0 授权服务器。

```Java
package com.xuecheng.auth.config;
*/
 @Configuration
 @EnableAuthorizationServer
 public class AuthorizationServer extends AuthorizationServerConfigurerAdapter {
 ...
 
```

AuthorizationServerConfigurerAdapter要求配置以下几个类：

```Java
public class AuthorizationServerConfigurerAdapter implements AuthorizationServerConfigurer {
    public AuthorizationServerConfigurerAdapter() {}
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {}
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {}
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {}
}
```

**1）ClientDetailsServiceConfigurer**：用来配置客户端详情服务（ClientDetailsService），

随便一个客户端都可以随便接入到它的认证服务吗？答案是否定的，服务提供商会给批准接入的客户端一个身份，用于接入时的凭据，有客户端标识和客户端秘钥，在这里配置批准接入的客户端的详细信息。

**2）AuthorizationServerEndpointsConfigurer**：用来配置令牌（token）的访问端点和令牌服务(token services)。

**3）AuthorizationServerSecurityConfigurer**：用来配置令牌端点的安全约束.

2、TokenConfig为令牌策略配置类

暂时先使用InMemoryTokenStore在内存存储令牌，令牌的有效期等信息配置如下：

```Java
    //令牌管理服务
    @Bean(name="authorizationServerTokenServicesCustom")
    public AuthorizationServerTokenServices tokenService() {
        DefaultTokenServices service=new DefaultTokenServices();
        service.setSupportRefreshToken(true);//支持刷新令牌
        service.setTokenStore(tokenStore);//令牌存储策略
        service.setAccessTokenValiditySeconds(7200); // 令牌默认有效期2小时
        service.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天
        return service;
    }
```

3、配置认证管理bean

```Java
@EnableWebSecurity
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
    ....
```

重启认证服务

1、get请求获取授权码

地址: http://localhost:63070/auth/oauth/authorize?client_id=XcWebApp&response_type=code&scope=all&redirect_uri=http://www.51xuecheng.cn

参数列表如下：

- client_id：客户端准入标识。
- response_type：授权码模式固定为code。
- scope：客户端权限。
- redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）。

输入账号zhangsan、密码123登录成功，输入/oauth/authorize?client_id=XcWebApp&response_type=code&scope=all&redirect_uri=http://www.51xuecheng.cn

显示授权页面

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OGE0NjRkNjE3MmU0NWY0NDZkMDcyMzQxZDk0OTc3YmVfWUdzdkh3THBYVXVHYjdrbXhwaVBneGFzcDlXOEkybDZfVG9rZW46T3pKb2JzVUxYb0szTk54TnVvWWM5NlNubnJiXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

授权“XcWebApp”访问自己的受保护资源?

选择同意。

2、请求成功，重定向至http://www.51xuecheng.cn/?code=授权码，比如：http://www.51xuecheng.cn/?code=Wqjb5H

3、使用httpclient工具post申请令牌

/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=authorization_code&code=授权码&redirect_uri=http://www.51xuecheng.cn/

参数列表如下

- client_id：客户端准入标识。
- client_secret：客户端秘钥。
- grant_type：授权类型，填写authorization_code，表示授权码模式
- code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。
- redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。

httpclient脚本如下：

```Plain
#### 授权码模式
#### 第一步申请授权码(浏览器请求)/oauth/authorize?client_id=c1&response_type=code&scope=all&redirect_uri=http://www.51xuecheng.cn
#### 第二步申请令牌
POST {{auth_host}}/auth/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=authorization_code&code=CTvCrB&redirect_uri=http://www.51xuecheng.cn
```

申请令牌成功如下所示：

```JSON
{
  "access_token": "368b1ee7-a9ee-4e9a-aae6-0fcab243aad2",
  "token_type": "bearer",
  "refresh_token": "3d56e139-0ee6-4ace-8cbe-1311dfaa991f",
  "expires_in": 7199,
  "scope": "all"
}
```

说明：

1、access_token，访问令牌，用于访问资源使用。

2、token_type，bearer是在RFC6750中定义的一种token类型，在携带令牌访问资源时需要在head中加入bearer 空格 令牌内容

3、refresh_token，当令牌快过期时使用刷新令牌可以再次生成令牌。

4、expires_in：过期时间（秒）

5、scope，令牌的权限范围，服务端可以根据令牌的权限范围去对令牌授权。

##### 2.3.3.3 密码模式

密码模式相对授权码模式简单，授权码模式需要借助浏览器供用户亲自授权，密码模式不用借助浏览器，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500684.png)

1、资源拥有者提供账号和密码

2、客户端向认证服务申请令牌，请求中携带账号和密码

3、认证服务校验账号和密码正确颁发令牌。

开始测试：

1、POST请求获取令牌

/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username=shangsan&password=123

参数列表如下：

- client_id：客户端准入标识。
- client_secret：客户端秘钥。
- grant_type：授权类型，填写password表示密码模式
- username：资源拥有者用户名。
- password：资源拥有者密码。

2、授权服务器将令牌（access_token）发送给client

使用httpclient进行测试

```Java
#### 密码模式
POST {{auth_host}}/auth/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username=zhangsan&password=123
```

返回示例：

```JSON
{
  "access_token": "368b1ee7-a9ee-4e9a-aae6-0fcab243aad2",
  "token_type": "bearer",
  "refresh_token": "3d56e139-0ee6-4ace-8cbe-1311dfaa991f",
  "expires_in": 6806,
  "scope": "all"
}
```

        这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下。

##### 2.3.3.4 本项目的应用方式

通过演示授权码模式和密码模式，授权码模式适合客户端和认证服务非同一个系统的情况，所以本项目使用授权码模式完成微信扫码认证。本项目采用密码模式作为前端请求微服务的认证方式。

### 2.4 JWT

#### 2.4.1 普通令牌的问题

客户端申请到令牌，接下来客户端携带令牌去访问资源，到资源服务器将会校验令牌的合法性。

资源服务器如何校验令牌的合法性？

我们以OAuth2的密码模式为例进行说明：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MzhkYzZiYjY4M2Y5MDkzZTZlNTgzMDllY2ZhYzZkMTZfU2xRRldLMWJOZDJuSmtuRGJSS3JvZlRBM2RWZmRQS1NfVG9rZW46SGNBdWI1UU5nbzJhME14ZEQxTmN2NHhpbnNmXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

从第4步开始说明：

1、客户端携带令牌访问资源服务获取资源。

2、资源服务远程请求认证服务校验令牌的合法性

3、如果令牌合法资源服务向客户端返回资源。

这里存在一个问题：

就是校验令牌需要远程请求认证服务，客户端的每次访问都会远程校验，执行性能低。

如果能够让资源服务自己校验令牌的合法性将省去远程请求认证服务的成本，提高了性能。如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500192.png)

如何解决上边的问题，实现资源服务自行校验令牌。

令牌采用JWT格式即可解决上边的问题，用户认证通过后会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。

#### 2.4.2 什么是JWT

什么是JWT？

JSON Web Token（JWT）是一种使用JSON格式传递数据的网络令牌技术，它是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任，它可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止内容篡改。官网：https://jwt.io/

使用JWT可以实现无状态认证，什么是无状态认证？

传统的基于session的方式是有状态认证，用户登录成功将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用。

如下图，当用户访问应用服务，每个应用服务都会去服务器查看session信息，如果session中没有该用户则说明用户没有登录，此时就会重新认证，而解决这个问题的方法是Session复制、Session黏贴。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZkNTZhNWRjNzMwOTRlZTAzNTZmMzBiNjUzZWE5MGVfSHhveDB2WmEyWVlTMnNYUWRRNXNxTnBuQW9IVXFDVXVfVG9rZW46RnFIVGJUWnZGb0w5cnl4b0c5Y2NWODJobmllXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

如果是基于令牌技术在分布式系统中实现认证则服务端不用存储session，可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。这个过程就是无状态认证。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500479.png)

JWT令牌的优点：

1、jwt基于json，非常方便解析。

2、可以在令牌中自定义丰富的内容，易扩展。

3、通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。

4、资源服务使用JWT可不依赖认证服务即可完成授权。

缺点：

１、JWT令牌较长，占存储空间比较大。

下边是一个JWT令牌的示例：

```Plain
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQyNTQ2NzIsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6Ijg4OTEyYjJkLTVkMDUtNGMxNC1iYmMzLWZkZTk5NzdmZWJjNiIsImNsaWVudF9pZCI6ImMxIn0.wkDBL7roLrvdBG2oGnXeoXq-zZRgE9IVV2nxd-ez_oA
```

JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz

1. Header        

  头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）

  一个例子如下：

  下边是Header部分的内容

```JSON
   {
    "alg": "HS256",
    "typ": "JWT"
  }
```

  将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。

1.  Payload

  第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的信息字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。

  此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。

  最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。

  一个例子：

```JSON
  {
    "sub": "1234567890",
    "name": "456",
    "admin": true
  }
```

1.  Signature

  第三部分是签名，此部分用于防止jwt内容被篡改。

  这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明的签名算法进行签名。

  一个例子：

```JSON
  HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    secret)
```

base64UrlEncode(header)：jwt令牌的第一部分。

base64UrlEncode(payload)：jwt令牌的第二部分。

secret：签名所使用的密钥。

为什么JWT可以防止篡改？

第三部分使用签名算法对第一部分和第二部分的内容进行签名，常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法需要使用密钥进行签名，密钥不对外公开，并且签名是不可逆的，如果第三方更改了内容那么服务器验证签名就会失败，要想保证验证签名正确必须保证内容、密钥与签名前一致。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500836.png)

从上图可以看出认证服务和资源服务使用相同的密钥，这叫对称加密，对称加密效率高，如果一旦密钥泄露可以伪造jwt令牌。

JWT还可以使用非对称加密，认证服务自己保留私钥，将公钥下发给受信任的客户端、资源服务，公钥和私钥是配对的，成对的公钥和私钥才可以正常加密和解密，非对称加密效率低但相比对称加密非对称加密更安全一些。

#### 2.4.3 测试生成JWT令牌

在认证服务中配置jwt令牌服务，即可实现生成jwt格式的令牌,  

```Java
package com.xuecheng.auth.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;

import java.util.Arrays;

/**
 * @author Administrator
 * @version 1.0
 **/
@Configuration
public class TokenConfig {

    private String SIGNING_KEY = "mq123";

    @Autowired
    TokenStore tokenStore;

//    @Bean
//    public TokenStore tokenStore() {
//        //使用内存存储令牌（普通令牌）
//        return new InMemoryTokenStore();
//    }

    @Autowired
    private JwtAccessTokenConverter accessTokenConverter;

    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }

    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey(SIGNING_KEY);
        return converter;
    }

    //令牌管理服务
    @Bean(name="authorizationServerTokenServicesCustom")
    public AuthorizationServerTokenServices tokenService() {
        DefaultTokenServices service=new DefaultTokenServices();
        service.setSupportRefreshToken(true);//支持刷新令牌
        service.setTokenStore(tokenStore);//令牌存储策略

        TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));
        service.setTokenEnhancer(tokenEnhancerChain);

        service.setAccessTokenValiditySeconds(7200); // 令牌默认有效期2小时
        service.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天
        return service;
    }
}
```

重启认证服务。

使用httpclient通过密码模式申请令牌

```Java
#### 密码模式
POST {{auth_host}}/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username=zhangsan&password=123
```

生成jwt的示例如下：

```JSON
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzMzE2OTUsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImU5ZDNkMGZkLTI0Y2ItNDRjOC04YzEwLTI1NmIzNGY4ZGZjYyIsImNsaWVudF9pZCI6ImMxIn0.-9SKI-qUqKhKcs8Gb80Rascx-JxqsNZxxXoPo82d8SM",
  "token_type": "bearer",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiJlOWQzZDBmZC0yNGNiLTQ0YzgtOGMxMC0yNTZiMzRmOGRmY2MiLCJleHAiOjE2NjQ1ODM2OTUsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImRjNTRjNTRkLTA0YTMtNDIzNS04MmY3LTFkOWZkMmFjM2VmNSIsImNsaWVudF9pZCI6ImMxIn0.Wsw1Jc-Kd_GFqEugzdfoSsMY6inC8OQsraA21WjWtT8",
  "expires_in": 7199,
  "scope": "all",
  "jti": "e9d3d0fd-24cb-44c8-8c10-256b34f8dfcc"
}
```

1、access_token，生成的jwt令牌，用于访问资源使用。

2、token_type，bearer是在RFC6750中定义的一种token类型，在携带jwt访问资源时需要在head中加入bearer jwt令牌内容

3、refresh_token，当jwt令牌快过期时使用刷新令牌可以再次生成jwt令牌。

4、expires_in：过期时间（秒）

5、scope，令牌的权限范围，服务端可以根据令牌的权限范围去对令牌授权。

6、jti：令牌的唯一标识。

我们可以通过check_token接口校验jwt令牌

```Plain
####校验jwt令牌
POST {{auth_host}}/oauth/check_token?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJzdHUxIiwic2NvcGUiOlsiYWxsIl0sImV4cCI6MTY2NDM3MTc4MCwiYXV0aG9yaXRpZXMiOlsicDEiXSwianRpIjoiZjBhM2NkZWItMzk5ZC00OGYwLTg4MDQtZWNhNjM4YWQ4ODU3IiwiY2xpZW50X2lkIjoiYzEifQ.qy46CSCJsH3eXWTHgdcntZhzcSzfRQlBU0dxAjZcsUw
```

响应示例如下：

```JSON
{
  "aud": [
    "res1"
  ],
  "user_name": "zhangsan",
  "scope": [
    "all"
  ],
  "active": true,
  "exp": 1664371780,
  "authorities": [
    "p1"
  ],
  "jti": "f0a3cdeb-399d-48f0-8804-eca638ad8857",
  "client_id": "c1"
}
```

#### 2.4.4 携带令牌访问资源服务

拿到了jwt令牌下一步就要携带令牌去访问资源服务中的资源，本项目各个微服务就是资源服务，比如：内容管理服务，客户端申请到jwt令牌，携带jwt去内容管理服务查询课程信息，此时内容管理服务要对jwt进行校验，只有jwt合法才可以继续访问。如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MzAxODUxY2UyMjhlNjljNjgxOGJjMTQzYWE2ZTE0MTFfdUtSZHgxYmdkc1lkazV1S3FLS2Jrd09mdnQxeVpocWFfVG9rZW46UDZ1bWJIMFpxb2hsbFZ4REhucmNSaXhFbmNnXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

1、在内容管理服务的content-api工程中添加依赖

```XML
<!--认证相关-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>
```

2、从资料中拷贝 资源服务配置类 中的 TokenConfig和ResouceServerConfig 到内容管理的api工程的config包下。

可以在ResouceServerConfig类中配置需要认证的url。

```Java
@Override
public void configure(HttpSecurity http) throws Exception {
 http.csrf().disable()
         .authorizeRequests()
               .antMatchers("/r/**","/course/**").authenticated()//所有/r/**的请求必须认证通过
         .anyRequest().permitAll()
 ;
}
```

重启内容管理服务

使用httpclient测试：

1、访问根据课程id查询课程接口

```Plain
#### 查询课程信息
GET http://localhost:63040/content/course/2
```

返回：

```JSON
{
  "error": "unauthorized",
  "error_description": "Full authentication is required to access this resource"
}
```

从返回信息可知当前没有认证。

下边携带JWT令牌访问接口：

1、申请jwt令牌

采用密码模式申请令牌。

2、携带jwt令牌访问资源服务地址

```Plain
#### 携带token访问资源服务
GET http://localhost:63040/content/course/2
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzMzM0OTgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6IjhhM2M2OTk1LWU1ZGEtNDQ1Yy05ZDAyLTEwNDFlYzk3NTkwOSIsImNsaWVudF9pZCI6ImMxIn0.73eNDxTX5ifttGCjwc7xrd-Sbp_mCfcIerI3lGetZto
```

在请求头中添加Authorization，内容为Bearer 令牌，Bearer用于通过oauth2.0协议访问资源。

如果携带jwt令牌且jwt正确则正常访问资源服务的内容。

如果不正确则报令牌无效的错误：

```JSON
{
  "error": "invalid_token",
  "error_description": "Cannot convert access token to JSON"
}
```

#### 2.4.5 测试获取用户身份

jwt令牌中记录了用户身份信息，当客户端携带jwt访问资源服务，资源服务验签通过后将前两部分的内容还原即可取出用户的身份信息，并将用户身份信息放在了SecurityContextHolder上下文，SecurityContext与当前线程进行绑定，方便获取用户身份。

还以查询课程接口为例，进入查询课程接口的代码中，添加获取用户身份的代码

```Java
@ApiOperation("根据课程id查询课程基础信息")
@GetMapping("/course/{courseId}")
public CourseBaseInfoDto getCourseBaseById(@PathVariable("courseId") Long courseId){
    //取出当前用户身份
    Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    System.out.println(principal);
    return courseBaseInfoService.getCourseBaseInfo(courseId);
}
```

测试时需要注意：

1、首先在资源服务配置中指定安全拦截机制 /course/开头的请求需要认证，即请求/course/{courseId}接口需要携带jwt令牌且签证通过。

2、认证服务生成jwt令牌将用户身份信息写入令牌，目前还是将用户信息硬编码并暂放在内存中。

如下：

```Java
@Bean
public UserDetailsService userDetailsService() {
    //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
    manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
    return manager;
}
```

3、我们在使用密码模式生成jwt令牌时用的是zhangsan的信息，所以jwt令牌中存储了zhangsan的信息，那么在资源服务中应该取出zhangsan的信息才对。

清楚了以上内容，下边重启内容管理服务，跟踪取到的用户身份是否正确。

### 2.5 网关认证

#### 2.5.1 技术方案

到目前为止，测试通过了认证服务颁发jwt令牌，客户端携带jwt访问资源服务，资源服务对jwt的合法性进行验证。如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500099.png)

仔细观察此图，遗漏了本项目架构中非常重要的组件：网关，加上网关并完善后如下图所示：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500671.png)

所有访问微服务的请求都要经过网关，在网关进行用户身份的认证可以将很多非法的请求拦截到微服务以外，这叫做网关认证。

下边需要明确网关的职责：

1、网站白名单维护

针对不用认证的URL全部放行。

2、校验jwt的合法性。

除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。

网关负责授权吗？

网关不负责授权，对请求的授权操作在各个微服务进行，因为微服务最清楚用户有哪些权限访问哪些接口。

#### 2.5.2 实现网关认证

下边实现网关认证，实现以下职责：

1、网站白名单维护

针对不用认证的URL全部放行。

2、校验jwt的合法性。

除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。

1、在网关工程添加依赖

```XML
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
</dependency>
```

2、拷贝课程资料下网关认证配置类到网关工程的config包下。

3、配置白名单文件security-whitelist.properties

内容如下（持续补充）

```Plain
/auth/**=认证地址
/content/open/**=内容管理公开访问接口
/media/open/**=媒资管理公开访问接口
```

重启网关工程，进行测试

1、申请令牌

2、通过网关访问资源服务

这里访问内容管理服务

```Plain
#### 通过网关访问资源服务
GET http://localhost:63010/content/course/2
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzNjIzMTAsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6Ijc2OTkwMGNiLWM1ZjItNGRiNC1hZWJmLWY1MzgxZDQxZWMyZCIsImNsaWVudF9pZCI6ImMxIn0.lOITjUgYg2HCh5mDPK9EvJJqz-tIupKVfmP8yWJQIKs
```

当token正确时可以正常访问资源服务，token验证失败返回token无效：

```JSON
{
  "errMessage": "认证令牌无效"
}
```

注意：网关鉴权功能调试通过后，由于目前还没有开发认证功能，前端请求网关的URL不在白名单中间时会“没有认证”的错误，暂时在白名单中添加 全部放行配置，待认证功能开发完成再屏蔽全部放行配置，

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429180.png)

由于是在网关处进行令牌校验，所以在微服务处不再校验令牌的合法性，修改内容管理服务的ResouceServerConfig类，屏蔽authenticated()。

```Java
 @Override
 public void configure(HttpSecurity http) throws Exception {
  http.csrf().disable()
          .authorizeRequests()
//          .antMatchers("/r/**","/course/**").authenticated()//所有/r/**的请求必须认证通过
          .anyRequest().permitAll()
  ;
 }
```

## 10.3 用户认证

### 3.1 需求分析

至此我们了解了使用Spring Security进行认证授权的过程，本节实现用户认证功能。

目前各大网站的认证方式非常丰富：账号密码认证、手机验证码认证、扫码登录等。

本项目也要支持多种认证试。

### 3.2 连接用户中心数据库

#### 3.2.1 连接数据库认证

基于的认证流程在研究Spring Security过程中已经测试通过，到目前为止用户认证流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500057.png)

认证所需要的用户信息存储在用户中心数据库，现在需要将认证服务连接数据库查询用户信息。

在研究Spring Security的过程中是将用户信息硬编码，如下：

```Java
@Bean
public UserDetailsService userDetailsService() {
    //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
    manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
    return manager;
}
```

我们要认证服务中连接用户中心数据库查询用户信息。

如何使用Spring Security连接数据库认证吗？

前边学习Spring Security工作原理时有一张执行流程图，如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjljZmFkMmExYzA4NDk0OTkwMjM1ZTljMDZlZDNlNWNfckE0QkVGVENPeTQxaTl2eTF5YTVWWEZRR1lwQjg5Mk1fVG9rZW46VE5ET2JFSWJzb1BXZWJ4M2NsQmNFWURXbnRiXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

用户提交账号和密码由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息。

查询DaoAuthenticationProvider的源代码如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500510.png)

UserDetailsService是一个接口，如下：

```Java
package org.springframework.security.core.userdetails;

public interface UserDetailsService {
    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;
}
```

UserDetails是用户信息接口

```Java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```

我们只要实现UserDetailsService 接口查询数据库得到用户信息返回UserDetails 类型的用户信息即可,框架调用loadUserByUsername()方法拿到用户信息之后是如何执行的，见下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429866.png)

首先屏蔽原来定义的UserDetailsService。

```Java
    //配置用户信息服务
//    @Bean
//    public UserDetailsService userDetailsService() {
//        //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
//        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
//        manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
//        manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
//        return manager;
//    }
```

下边自定义UserDetailsService

```Java
package com.xuecheng.ucenter.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.ucenter.mapper.XcUserMapper;
import com.xuecheng.ucenter.model.po.XcUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2022/9/28 18:09
 */
@Service
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    XcUserMapper xcUserMapper;

    /**
     * @description 根据账号查询用户信息
     * @param s  账号
     * @return org.springframework.security.core.userdetails.UserDetails
     * @author Mr.M
     * @date 2022/9/28 18:30
    */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {

        XcUser user = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, s));
        if(user==null){
            //返回空表示用户不存在
            return null;
        }
        //取出数据库存储的正确密码
        String password  =user.getPassword();
        //用户权限,如果不加报Cannot pass a null GrantedAuthority collection
        String[] authorities= {"test"};
        //创建UserDetails对象,权限信息待实现授权功能时再向UserDetail中加入
        UserDetails userDetails = User.withUsername(user.getUsername()).password(password).authorities(authorities).build();

        return userDetails;
    }


}
```

数据库中的密码加过密的，用户输入的密码是明文，我们需要修改密码格式器PasswordEncoder，原来使用的是NoOpPasswordEncoder，它是通过明文方式比较密码，现在我们修改为BCryptPasswordEncoder，它是将用户输入的密码编码为BCrypt格式与数据库中的密码进行比对。

如下：

```Java
    @Bean
    public PasswordEncoder passwordEncoder() {
//        //密码为明文方式
//        return NoOpPasswordEncoder.getInstance();
        return new BCryptPasswordEncoder();
    }
```

我们通过测试代码测试BCryptPasswordEncoder，如下：

```Java
public static void main(String[] args) {
    String password = "111111";
    PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
    for(int i=0;i<10;i++) {
        //每个计算出的Hash值都不一样
        String hashPass = passwordEncoder.encode(password);
        System.out.println(hashPass);
        //虽然每次计算的密码Hash值不一样但是校验是通过的
        boolean f = passwordEncoder.matches(password, hashPass);
        System.out.println(f);
    }
}
```

修改数据库中的密码为Bcrypt格式，并且记录明文密码，稍后申请令牌时需要。

由于修改密码编码方式还需要将客户端的密钥更改为Bcrypt格式.

```Java
 @Override
  public void configure(ClientDetailsServiceConfigurer clients)
          throws Exception {
        clients.inMemory()// 使用in-memory存储
                .withClient("XcWebApp")// client_id
//                .secret("secret")//客户端密钥
                .secret(new BCryptPasswordEncoder().encode("XcWebApp"))//客户端密钥
                .resourceIds("xuecheng-plus")//资源列表
                .authorizedGrantTypes("authorization_code", "password","client_credentials","implicit","refresh_token")// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials
                .scopes("all")// 允许的授权范围
                .autoApprove(false)//false跳转到授权页面
                //客户端接收授权码的重定向地址
                .redirectUris("http://www.51xuecheng.cn")
   ;
  }
```

现在重启认证服务。

下边使用httpclient进行测试：

```Java
#### 密码模式
POST {{auth_host}}/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username=stu1&password=111111
```

输入正确的账号和密码，申请令牌成功。

输入错误的密码，报错：

```Java
{
  "error": "invalid_grant",
  "error_description": "用户名或密码错误"
}
```

输入错误的账号，报错：

```Java
{
  "error": "unauthorized",
  "error_description": "UserDetailsService returned null, which is an interface contract violation"
}
```

#### 3.2.3 扩展用户身份信息

用户表中存储了用户的账号、手机号、email，昵称、qq等信息，UserDetails接口只返回了username、密码等信息，如下：

```Java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```

我们需要扩展用户身份的信息，在jwt令牌中存储用户的昵称、头像、qq等信息。

如何扩展Spring Security的用户身份信息呢？

在认证阶段DaoAuthenticationProvider会调用UserDetailService查询用户的信息，这里是可以获取到齐全的用户信息的。由于JWT令牌中用户身份信息来源于UserDetails，UserDetails中仅定义了username为用户的身份信息，这里有两个思路：第一是可以扩展UserDetails，使之包括更多的自定义属性，第二也可以扩展username的内容 ，比如存入json数据内容作为username的内容。相比较而言，方案二比较简单还不用破坏UserDetails的结构，我们采用方案二。

修改UserServiceImpl如下：

```Java
package com.xuecheng.ucenter.service.impl;

import com.alibaba.fastjson.JSON;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.ucenter.mapper.XcUserMapper;
import com.xuecheng.ucenter.model.po.XcUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2022/9/28 18:09
 */
@Service
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    XcUserMapper xcUserMapper;

    /**
     * @description 根据账号查询用户信息
     * @param s  账号
     * @return org.springframework.security.core.userdetails.UserDetails
     * @author Mr.M
     * @date 2022/9/28 18:30
    */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {

        XcUser user = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, s));
        if(user==null){
            //返回空表示用户不存在
            return null;
        }

        //取出数据库存储的正确密码
        String password  =user.getPassword();
        //用户权限,如果不加报Cannot pass a null GrantedAuthority collection
        String[] authorities = {"p1"};
       //为了安全在令牌中不放密码
        user.setPassword(null);
        //将user对象转json
        String userString = JSON.toJSONString(user);
        //创建UserDetails对象
        UserDetails userDetails = User.withUsername(userString).password(password).authorities(authorities).build();

        return userDetails;
    }


}
```

重启认证服务，重新生成令牌，生成成功。

我们可以使用check_token查询jwt的内容

```JSON
####校验jwt令牌
POST {{auth_host}}/oauth/check_token?token=
```

响应示例如下，

```JSON
{
  "aud": [
    "res1"
  ],
  "user_name": "{\"birthday\":\"2022-09-28T19:28:46\",\"createTime\":\"2022-09-28T08:32:03\",\"id\":\"50\",\"name\":\"学生1\",\"nickname\":\"大水牛\",\"password\":\"$2a$10$0pt7WlfTbnPDTcWtp/.2Mu5CTXvohnNQhR628qq4RoKSc0dGAdEgm\",\"sex\":\"1\",\"status\":\"1\",\"username\":\"stu1\",\"userpic\":\"http://file.51xuecheng.cn/dddf\",\"utype\":\"101001\"}",
  "scope": [
    "all"
  ],
  "active": true,
  "exp": 1664372184,
  "authorities": [
    "p1"
  ],
  "jti": "73da9f7b-bd8c-45ac-9add-46b711d11fb8",
  "client_id": "c1"
}
```

user_name存储了用户信息的json格式，在资源服务中就可以取出该json格式的内容转为用户对象去使用。

#### 3.2.3 资源服务获取用户身份

下边编写一个工具类在各个微服务中去使用，获取当前登录用户的对象。

在content-api中定义此类：

```Java
package com.xuecheng.content.util;

import com.alibaba.fastjson.JSON;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.context.SecurityContextHolder;

import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * @author Mr.M
 * @version 1.0
 * @description 获取当前用户身份工具类
 * @date 2022/10/18 18:02
 */
@Slf4j
public class SecurityUtil {

    public static XcUser getUser() {
        try {
            Object principalObj = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
            if (principalObj instanceof String) {
                //取出用户身份信息
                String principal = principalObj.toString();
                //将json转成对象
                XcUser user = JSON.parseObject(principal, XcUser.class);
                return user;
            }
        } catch (Exception e) {
            log.error("获取当前登录用户身份出错:{}", e.getMessage());
            e.printStackTrace();
        }

        return null;
    }


    @Data
    public static class XcUser implements Serializable {

        private static final long serialVersionUID = 1L;

        private String id;

        private String username;

        private String password;

        private String salt;

        private String name;
        private String nickname;
        private String wxUnionid;
        private String companyId;
        /**
         * 头像
         */
        private String userpic;

        private String utype;

        private LocalDateTime birthday;

        private String sex;

        private String email;

        private String cellphone;

        private String qq;

        /**
         * 用户状态
         */
        private String status;

        private LocalDateTime createTime;

        private LocalDateTime updateTime;


    }


}
```

下边在内容管理服务中测试此工具类，以查询课程信息接口为例：

```Java
@ApiOperation("根据课程id查询课程基础信息")
@GetMapping("/course/{courseId}")
public CourseBaseInfoDto getCourseBaseById(@PathVariable("courseId") Long courseId){
    //取出当前用户身份
//    Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
   SecurityUtil.XcUser user = SecurityUtil.getUser();
    System.out.println(user);

    return courseBaseInfoService.getCourseBaseInfo(courseId);
}
```

重启内容管理服务：

1、启动认证服务、网关、内容管理服务

2、生成新的令牌

3、携带令牌访问内容管理服务的查询课程接口

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500120.png)

### 3.3 支持认证方式多样

#### 3.3.1 统一认证入口

目前各大网站的认证方式非常丰富：账号密码认证、手机验证码认证、扫码登录等。基于当前研究的Spring Security认证流程如何支持多样化的认证方式呢？

1、支持账号和密码认证

采用OAuth2协议的密码模式即可实现。

2、支持手机号加验证码认证

用户认证提交的是手机号和验证码，并不是账号和密码。

3、微信扫码认证

基于OAuth2协议与微信交互，学成在线网站向微信服务器申请到一个令牌，然后携带令牌去微信查询用户信息，查询成功则用户在学成在线项目认证通过。

目前我们测试通过OAuth2的密码模式，用户认证会提交账号和密码，由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息。

在前边我们自定义了UserDetailsService接口实现类，通过loadUserByUsername()方法根据账号查询用户信息。

而不同的认证方式提交的数据不一样，比如：手机加验证码方式会提交手机号和验证码，账号密码方式会提交账号、密码、验证码。

我们可以在loadUserByUsername()方法上作文章，将用户原来提交的账号数据改为提交json数据，json数据可以扩展不同认证方式所提交的各种参数。

首先创建一个DTO类表示认证的参数：

```Java
package com.xuecheng.ucenter.model.dto;

import lombok.Data;

import java.util.HashMap;
import java.util.Map;

/**
 * @author Mr.M
 * @version 1.0
 * @description 认证用户请求参数
 * @date 2022/9/29 10:56
 */
@Data
public class AuthParamsDto {

    private String username; //用户名
    private String password; //域  用于扩展
    private String cellphone;//手机号
    private String checkcode;//验证码
    private String checkcodekey;//验证码key
    private String authType; // 认证的类型   password:用户名密码模式类型    sms:短信模式类型
    private Map<String, Object> payload = new HashMap<>();//附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId


}
```

此时loadUserByUsername()方法可以修改如下：

```Java
package com.xuecheng.ucenter.service.impl;

import com.alibaba.fastjson.JSON;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.ucenter.mapper.XcUserMapper;
import com.xuecheng.ucenter.model.dto.AuthParamsDto;
import com.xuecheng.ucenter.model.po.XcUser;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * @author Mr.M
 * @version 1.0
 * @description 自定义UserDetailsService用来对接Spring Security
 * @date 2022/9/28 18:09
 */
@Slf4j
@Service
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    XcUserMapper xcUserMapper;

    /**
     * @description 查询用户信息组成用户身份信息
     * @param s  AuthParamsDto类型的json数据
     * @return org.springframework.security.core.userdetails.UserDetails
     * @author Mr.M
     * @date 2022/9/28 18:30
    */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {

        AuthParamsDto authParamsDto = null;
        try {
            //将认证参数转为AuthParamsDto类型
            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);
        } catch (Exception e) {
            log.info("认证请求不符合项目要求:{}",s);
            throw new RuntimeException("认证请求数据格式不对");
        }
        //账号
        String username = authParamsDto.getUsername();
        XcUser user = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));
        if(user==null){
            //返回空表示用户不存在
            return null;
        }
        //取出数据库存储的正确密码
        String password  =user.getPassword();
        //用户权限,如果不加报Cannot pass a null GrantedAuthority collection
        String[] authorities = {"p1"};
        //将user对象转json
        String userString = JSON.toJSONString(user);
        //创建UserDetails对象
        UserDetails userDetails = User.withUsername(userString).password(password).authorities(authorities).build();

        return userDetails;
    }

}
```

原来的DaoAuthenticationProvider 会进行密码校验，现在重新定义DaoAuthenticationProviderCustom类，重写类的additionalAuthenticationChecks方法。

```Java
package com.xuecheng.auth.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;

/**
 * @description 自定义DaoAuthenticationProvider
 * @author Mr.M
 * @date 2022/9/29 10:31
 * @version 1.0
 */
@Slf4j
@Component
public class DaoAuthenticationProviderCustom extends DaoAuthenticationProvider {


 @Autowired
 public void setUserDetailsService(UserDetailsService userDetailsService) {
  super.setUserDetailsService(userDetailsService);
 }


 //屏蔽密码对比
 protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {


 }

}
```

修改WebSecurityConfig类指定daoAuthenticationProviderCustom

```Java
@Autowired
DaoAuthenticationProviderCustom daoAuthenticationProviderCustom;


@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.authenticationProvider(daoAuthenticationProviderCustom);
}
```

此时可以重启认证服务，测试申请令牌接口，传入的账号信息改为json数据，如下：

```Plain
#################扩展认证请求参数后######################
####密码模式
POST {{auth_host}}/auth/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username={"username":"stu1","authType":"password","password":"111111"}
```

经过测试发现loadUserByUsername()方法可以正常接收到认证请求中的json数据。

有了这些认证参数我们可以定义一个认证Service接口去进行各种方式的认证。

定义用户信息，为了扩展性让它继承XcUser

```Java
@Data
public class XcUserExt extends XcUser {
}
```

定义认证Service 接口

```Java
package com.xuecheng.ucenter.service;

import com.xuecheng.ucenter.model.dto.AuthParamsDto;
import com.xuecheng.ucenter.model.po.XcUser;

/**
 * @description 认证service
 * @author Mr.M
 * @date 2022/9/29 12:10
 * @version 1.0
 */
public interface AuthService {

   /**
    * @description 认证方法
    * @param authParamsDto 认证参数
    * @return com.xuecheng.ucenter.model.po.XcUser 用户信息
    * @author Mr.M
    * @date 2022/9/29 12:11
   */
   XcUserExt execute(AuthParamsDto authParamsDto);

}
```

loadUserByUsername()修改如下：

```Java
@Slf4j
@Service
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    XcUserMapper xcUserMapper;

    @Autowired
    ApplicationContext applicationContext;


    /**
     * @description 查询用户信息组成用户身份信息
     * @param s  AuthParamsDto类型的json数据
     * @return org.springframework.security.core.userdetails.UserDetails
     * @author Mr.M
     * @date 2022/9/28 18:30
    */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {

        AuthParamsDto authParamsDto = null;
        try {
            //将认证参数转为AuthParamsDto类型
            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);
        } catch (Exception e) {
            log.info("认证请求不符合项目要求:{}",s);
            throw new RuntimeException("认证请求数据格式不对");
        }
        //开始认证
        authService.execute(authParamsDto);
        .....
```

到此我们基于Spring Security认证流程修改为如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429271.png)

#### 3.3.2 实现账号密码认证

上节定义了AuthService认证接口，下边实现该接口实现账号密码认证

```Java
package com.xuecheng.ucenter.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.ucenter.mapper.XcUserMapper;
import com.xuecheng.ucenter.model.dto.AuthParamsDto;
import com.xuecheng.ucenter.model.po.XcUser;
import com.xuecheng.ucenter.service.AuthService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

/**
 * @description 账号密码认证
 * @author Mr.M
 * @date 2022/9/29 12:12
 * @version 1.0
 */
 @Service("password_authservice")
public class PasswordAuthServiceImpl implements AuthService {

 @Autowired
 XcUserMapper xcUserMapper;

 @Autowired
 PasswordEncoder passwordEncoder;


 @Override
 public XcUserExt execute(AuthParamsDto authParamsDto) {

  //账号
  String username = authParamsDto.getUsername();
  XcUser user = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));
  if(user==null){
   //返回空表示用户不存在
   throw new RuntimeException("账号不存在");
  }
  XcUserExt xcUserExt = new XcUserExt();
  BeanUtils.copyProperties(user,xcUserExt);
  //校验密码
  //取出数据库存储的正确密码
  String passwordDb  =user.getPassword();
  String passwordForm = authParamsDto.getPassword();
  boolean matches = passwordEncoder.matches(passwordForm, passwordDb);
  if(!matches){
   throw new RuntimeException("账号或密码错误");
  }
  return xcUserExt;
 }
}
```

修改UserServiceImpl类，根据认证方式使用不同的认证bean

```Java
package com.xuecheng.ucenter.service.impl;

import com.alibaba.fastjson.JSON;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.ucenter.mapper.XcUserMapper;
import com.xuecheng.ucenter.model.dto.AuthParamsDto;
import com.xuecheng.ucenter.model.po.XcUser;
import com.xuecheng.ucenter.service.AuthService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * @author Mr.M
 * @version 1.0
 * @description 自定义UserDetailsService用来对接Spring Security
 * @date 2022/9/28 18:09
 */
@Slf4j
@Service
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    XcUserMapper xcUserMapper;

    @Autowired
    ApplicationContext applicationContext;

//    @Autowired
//    AuthService authService;

    /**
     * @description 查询用户信息组成用户身份信息
     * @param s  AuthParamsDto类型的json数据
     * @return org.springframework.security.core.userdetails.UserDetails
     * @author Mr.M
     * @date 2022/9/28 18:30
    */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {

        AuthParamsDto authParamsDto = null;
        try {
            //将认证参数转为AuthParamsDto类型
            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);
        } catch (Exception e) {
            log.info("认证请求不符合项目要求:{}",s);
            throw new RuntimeException("认证请求数据格式不对");
        }

        //认证方法
        String authType = authParamsDto.getAuthType();
        AuthService authService =  applicationContext.getBean(authType + "_authservice",AuthService.class);
        XcUserExt user = authService.execute(authParamsDto);

        return getUserPrincipal(user);
    }


    /**
     * @description 查询用户信息
     * @param user  用户id，主键
     * @return com.xuecheng.ucenter.model.po.XcUser 用户信息
     * @author Mr.M
     * @date 2022/9/29 12:19
    */
    public UserDetails getUserPrincipal(XcUserExt user){
        //用户权限,如果不加报Cannot pass a null GrantedAuthority collection
        String[] authorities = {"p1"};
        String password = user.getPassword();
        //为了安全在令牌中不放密码
        user.setPassword(null);
        //将user对象转json
        String userString = JSON.toJSONString(user);
        //创建UserDetails对象
        UserDetails userDetails = User.withUsername(userString).password(password ).authorities(authorities).build();
        return userDetails;
    }

}
```

重启认证服务，测试申请令牌接口。

1、测试账号和密码都正确的情况是否可以申请令牌成功。

2、测试密码错误的情况。

3、测试账号不存在情况。

### 3.4 验证码服务

#### 3.4.1 部署验证码服务工程

在认证时一般都需要输入验证码，验证码有什么用？

验证码可以防止恶性攻击，比如：XSS跨站脚本攻击、CSRF跨站请求伪造攻击，一些比较复杂的图形验证码可以有效的防止恶性攻击。

为了保护系统的安全在一些比较重要的操作都需要验证码。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmY3Mjg5M2M3NzA4YzE5NzZmMDQ0YjkwNTZiMzE4ZjFfSGw3TGh3ZDJiSkdmRFBJNlFpWVh5RHluS0tQS0EyeTVfVG9rZW46TjJJZGJmVzFFb3VtOUp4T2RDcmNLRjZkbmNiXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

验证码的类型也有很多：图片、语音、手机短信验证码等。

本项目创建单独的验证码服务为各业务提供验证码的生成、校验等服务。

拷贝课程资料目录xuecheng-plus-checkcode验证码服务工程到自己的工程目录。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500821.png)

定义nacos配置文件

```YAML
server:
  servlet:
    context-path: /checkcode
  port: 63075
```

注意修改bootstrap.yml中的命名空间为自己定义的命名空间。

配置redis-dev.yaml，保存redis服务启动

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500129.png)

内容如下：

```XML
spring: 
  redis:
    host: 192.168.101.65
    port: 6379
    password: redis
    database: 0
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 0
    timeout: 10000
    #redisson:
      #配置文件目录
      #config: classpath:singleServerConfig.yaml
```

#### 3.4.2 验证码接口测试

验证码服务对外提供的接口有：

1、生成验证码

2、校验验证码。

如下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA1MmJhOGY2ZTgzNTQ1OGNlYzZiYjIwOGMwZDg0NWJfbFBDV3JIVVJ2bUxLRUtjc0RlN2g5SElSbEVGNk82RDdfVG9rZW46TExYd2JjVVJnb3NsQUx4UU1qbGNVQ21WblVjXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

验证码服务如何生成并校验验证码？

拿图片验证码举例：

1、先生成一个指定位数的验证码，根据需要可能是数字、数字字母组合或文字。

2、根据生成的验证码生成一个图片并返回给页面

3、给生成的验证码分配一个key，将key和验证码一同存入缓存。这个key和图片一同返回给页面。

4、用户输入验证码，连同key一同提交至认证服务。

5、认证服务拿key和输入的验证码请求验证码服务去校验

6、验证码服务根据key从缓存取出正确的验证码和用户输入的验证码进行比对，如果相同则校验通过，否则不通过。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429411.png)

根据接口分析，验证码服务接口如下：

```Java
package com.xuecheng.checkcode.controller;

import com.xuecheng.base.model.RestResponse;
import com.xuecheng.checkcode.model.CheckCodeParamsDto;
import com.xuecheng.checkcode.model.CheckCodeResultDto;
import com.xuecheng.checkcode.service.CheckCodeService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import java.util.Map;

/**
 * @author Mr.M
 * @version 1.0
 * @description 验证码服务接口
 * @date 2022/9/29 18:39
 */
@Api(value = "验证码服务接口")
@RestController
public class CheckCodeController {


    @ApiOperation(value="生成验证信息", notes="生成验证信息")
    @PostMapping(value = "/pic")
    public CheckCodeResultDto generatePicCheckCode(CheckCodeParamsDto checkCodeParamsDto){
        
    }

    @ApiOperation(value="校验", notes="校验")
    @ApiImplicitParams({
            @ApiImplicitParam(name = "name", value = "业务名称", required = true, dataType = "String", paramType="query"),
            @ApiImplicitParam(name = "key", value = "验证key", required = true, dataType = "String", paramType="query"),
            @ApiImplicitParam(name = "code", value = "验证码", required = true, dataType = "String", paramType="query")
    })
    @PostMapping(value = "/verify")
    public Boolean verify(String key, String code){
        
    }
}
```

1、生成验证码接口

```Plain
#### 申请验证码
POST {{checkcode_host}}/checkcode/pic
```

2、校验验证码接口

根据生成验证码返回的key以及日志中输出正确的验证码去测试。

```Bash
#### 校验验证码
POST {{checkcode_host}}/checkcode/verify?key=checkcode4506b95bddbe46cdb0d56810b747db1b&code=70dl
```

### 3.5 账号密码认证

#### 3.5.1 需求分析

到目前为止账号和密码认证所需要的技术、组件都已开发完毕，下边实现账号密码认证，输出如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500806.png)

执行流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500089.png)

#### 3.5.2 账号密码认证开发

1、在认证服务定义远程调用验证码服务的接口

```Java
package com.xuecheng.ucenter.feignclient;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * @description 
 * @author Mr.M
 * @date 2022/9/20 20:29
 * @version 1.0
 */
 @FeignClient(value = "checkcode",fallbackFactory = CheckCodeClientFactory.class)
 @RequestMapping("/checkcode")
public interface CheckCodeClient {

 @PostMapping(value = "/verify")
 public Boolean verify(@RequestParam("key") String key,@RequestParam("code") String code);

}
```

CheckCodeClientFactory:

```Java
@Slf4j
@Component
public class CheckCodeClientFactory implements FallbackFactory<CheckCodeClient> {
    @Override
    public CheckCodeClient create(Throwable throwable) {
        return new CheckCodeClient() {

            @Override
            public Boolean verify(String key, String code) {
                log.debug("调用验证码服务熔断异常:{}", throwable.getMessage());
                return null;
            }
        };
    }
}
```

启动类添加：

```Java
@EnableFeignClients(basePackages={"com.xuecheng.*.feignclient"})
```

配置文件引入feign-dev.yaml

```Java
- data-id: feign-${spring.profiles.active}.yaml
  group: xuecheng-plus-common
  refresh: true
```

2、完善PasswordAuthServiceImpl

```Java
package com.xuecheng.ucenter.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.xuecheng.ucenter.feignclient.CheckCodeClient;
import com.xuecheng.ucenter.mapper.XcUserMapper;
import com.xuecheng.ucenter.model.dto.AuthParamsDto;
import com.xuecheng.ucenter.model.po.XcUser;
import com.xuecheng.ucenter.service.AuthService;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

/**
 * @description 账号密码认证
 * @author Mr.M
 * @date 2022/9/29 12:12
 * @version 1.0
 */
 @Service("password_authservice")
public class PasswordAuthServiceImpl implements AuthService {

 @Autowired
 XcUserMapper xcUserMapper;

 @Autowired
 PasswordEncoder passwordEncoder;
 @Autowired
 CheckCodeClient checkCodeClient;

 @Override
 public XcUser execute(AuthParamsDto authParamsDto) {

  //校验验证码
  String checkcode = authParamsDto.getCheckcode();
  String checkcodekey = authParamsDto.getCheckcodekey();

  if(StringUtils.isBlank(checkcodekey) || StringUtils.isBlank(checkcode)){
   throw new RuntimeException("验证码为空");

  }
  Boolean verify = checkCodeClient.verify(checkcodekey, checkcode);
  if(!verify){
   throw new RuntimeException("验证码输入错误");
  }
  //账号
  String username = authParamsDto.getUsername();
  XcUser user = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));
  if(user==null){
   //返回空表示用户不存在
   throw new RuntimeException("账号不存在");
  }
  //校验密码
  //取出数据库存储的正确密码
  String passwordDb  =user.getPassword();
  String passwordForm = authParamsDto.getPassword();
  boolean matches = passwordEncoder.matches(passwordForm, passwordDb);
  if(!matches){
   throw new RuntimeException("账号或密码错误");
  }
  return user;
 }
}
```

小技巧：目前账号密码方式添加了验证码校验，为了后期获取令牌方便可以重新定义一个不需要验证码校验的认证类AuthService ，AuthService 中去掉验证码的校验，方便生成令牌。

#### 3.5.3 账号密码认证测试

1、使用浏览器访问 http://www.51xuecheng.cn/sign.html

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429921.png)

2、首先测试验证码，分别输入正确的验证码和错误的验证码进行测试

3、输入正确的账号密码和错误的账号密码进行测试

登录成功将jwt令牌存储cookie.

4、测试自动登录

勾选自动登录cookie生成时间为30天，不勾选自动登录关闭浏览器窗口后自动删除cookie。

## 10.4 微信扫码登录

### 4.1 接入规范

#### 4.1.1 接入流程

微信扫码登录基于OAuth2协议的授权码模式，

接口文档：

https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html

流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500029.png)

第三方应用获取access_token令牌后即可请求微信获取用户的信息，成功获取到用户的信息表示用户在第三方应用认证成功。

#### 4.1.2 请求获取授权码

第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login），则可以通过在 PC 端打开以下链接： https://open.weixin.qq.com/connect/qrconnect?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect 若提示“该链接无法访问”，请检查参数是否填写错误，如redirect_uri的域名与审核时填写的授权域名不一致或 scope 不为snsapi_login。

**参数说明**

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTk1ZjQzZjcyNDk0MTcwNzMwNjhmZmJlNWM0YmIzNTRfdHFRb1RWY2xyZWd6NUs0ZGJKaEYzd0VqQWM3NDVKT05fVG9rZW46R3BMd2JYRElXbzVOUVV4RUh4RGMxbTJHbklLXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

**返回说明**

用户允许授权后，将会重定向到redirect_uri的网址上，并且带上 code 和state参数

```Plain
redirect_uri?code=CODE&state=STATE
```

若用户禁止授权，则不会发生重定向。

登录一号店网站应用 https://test.yhd.com/wechat/login.do 打开后，一号店会生成 state 参数，跳转到 https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&redirect_uri=https%3A%2F%2Fpassport.yhd.com%2Fwechat%2Fcallback.do&response_type=code&scope=snsapi_login&state=3d6be0a4035d839573b04816624a415e#wechat_redirect 微信用户使用微信扫描二维码并且确认登录后，PC端会跳转到 https://test.yhd.com/wechat/callback.do?code=CODE&state=3d6be0a40sssssxxxxx6624a415e 为了满足网站更定制化的需求，我们还提供了第二种获取 code 的方式，支持网站将微信登录二维码内嵌到自己页面中，用户使用微信扫码授权后通过 JS 将code返回给网站。 JS微信登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到微信域下登录后再返回，提升微信登录的流畅性与成功率。 网站内嵌二维码微信登录 JS 实现办法：

步骤1：在页面中先引入如下 JS 文件（支持https）：

```Plain
http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js
```

步骤2：在需要使用微信登录的地方实例以下 JS 对象：

```Plain
 var obj = new WxLogin({
 self_redirect:true,
 id:"login_container", 
 appid: "", 
 scope: "", 
 redirect_uri: "",
  state: "",
 style: "",
 href: ""
 });
```

 

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500902.png)

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500643.png)

#### 4.1.3 **通过 code 获取access_token**

通过 code 获取access_token

```Plain
https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code
```

 

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MTIyZDRmYjEyMjhjNDRlODdhOTQzZGU2NTI5YjBiNmVfam8xMkRwN0RVRkg4bWwwQ21zRjg4bXRtRXFYN3NpNlBfVG9rZW46SkhTMmJQeE11b1ByOGR4akRxN2NMZWpmbkFkXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

**返回说明**

正确的返回：

```Plain
{ 
"access_token":"ACCESS_TOKEN", 
"expires_in":7200, 
"refresh_token":"REFRESH_TOKEN",
"openid":"OPENID", 
"scope":"SCOPE",
"unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"
}
```

 **参数说明**

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500386.png)

错误返回样例：

```Plain
{"errcode":40029,"errmsg":"invalid code"}
```

#### 4.1.4 **通过access_token调用接口**

获取access_token后，进行接口调用，有以下前提：

```Plain
access_token有效且未超时；
微信用户已授权给第三方应用帐号相应接口作用域（scope）。
```

对于接口作用域（scope），能调用的接口有以下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500043.png)

 其中snsapi_base属于基础接口，若应用已拥有其它 scope 权限，则默认拥有snsapi_base的权限。使用snsapi_base可以让移动端网页授权绕过跳转授权登录页请求用户授权的动作，直接跳转第三方网页带上授权临时票据（code），但会使得用户已授权作用域（scope）仅为snsapi_base，从而导致无法获取到需要用户授权才允许获得的数据和基础功能。 接口调用方法可查阅[《微信授权关系接口调用指南》](https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html)

获取用户信息接口文档：https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html

接口地址

```Plain
http请求方式: GET
https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID
```

如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500338.png)

响应：

```Java
{
"openid":"OPENID",
"nickname":"NICKNAME",
"sex":1,
"province":"PROVINCE",
"city":"CITY",
"country":"COUNTRY",
"headimgurl": "https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0",
"privilege":[
"PRIVILEGE1",
"PRIVILEGE2"
],
"unionid": " o6_bmasdasdsad6_2sgVt7hMZOPfL"

}
```

说明如下：

```Plain
参数            说明
openid        普通用户的标识，对当前开发者帐号唯一
nickname        普通用户昵称
sex            普通用户性别，1为男性，2为女性
province        普通用户个人资料填写的省份
city            普通用户个人资料填写的城市
country        国家，如中国为CN
headimgurl        用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空
privilege        用户特权信息，json数组，如微信沃卡用户为（chinaunicom）
unionid          用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的 unionid 是唯一的。
```

### 4.2 准备开发环境

#### 4.2.1 添加应用

1、注册微信开放平台

https://open.weixin.qq.com/

2、添加应用

进入网站应用，添加应用

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429740.png)

3、添加应用需要指定一个外网域名作为微信回调域名

审核通过后，生成app密钥。

最终获取appID和AppSecret

#### 4.2.2 内网穿透

我们的开发环境在局域网，微信回调指向一个公网域名。

如何让微信回调请求至我们的开发计算机上呢？

可以使用内网穿透技术，什么是内网穿透？

内网穿透简单来说就是将内网外网通过隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要内网穿透工具了。开启隧道之后，网穿透工具会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了~~

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500899.png)

1、在内网穿透服务器上开通隧道，配置外网域名，配置穿透内网的端口即本地电脑上的端口。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjc1YWM4MzkwZTAxOWEyMjk2N2JkN2U0MzUyNDE0NThfcVBod2ZiR2o2R1Y3VjRzQ0ZZQlo1N0ZaaTVUOEVmek1fVG9rZW46SU5uRGJVRUo1b1lpSlJ4ekNHUGNtU2dzbmFoXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

这里我们配置认证服务端口，最终实现通过外网域名访问本地认证服务。

2、在本地电脑上安装内网穿透的工具，工具上配置内网穿透服务器隧道token。

市面上做内网穿透的商家很多，需要时可以查阅资料了解下。

### 4.3 接入微信登录

#### 4.3.1 接入分析

根据OAuth2协议授权码流程，结合本项目自身特点，分析接入微信扫码登录的流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500140.png)

本项目认证服务需要做哪些事？

1、需要定义接口接收微信下发的授权码。

2、收到授权码调用微信接口申请令牌。

3、申请到令牌调用微信获取用户信息

4、获取用户信息成功将其写入本项目用户中心数据库。

5、最后重定向到浏览器自动登录。

#### 4.3.2 定义接口

参考接口规范中“请求获取授权码” 定义接收微信下发的授权码接口，

定义WxLoginController类，如下：

```Java
@Slf4j
@Controller
public class WxLoginController {

    @RequestMapping("/wxLogin")
    public String wxLogin(String code, String state) throws IOException {
        log.debug("微信扫码回调,code:{},state:{}",code,state);
        //请求微信申请令牌，拿到令牌查询用户信息，将用户信息写入本项目数据库
        XcUser xcUser = new XcUser();
        //暂时硬编写，目的是调试环境
        xcUser.setUsername("t1");
        if(xcUser==null){
            return "redirect:http://www.51xuecheng.cn/error.html";
        }
        String username = xcUser.getUsername();
        return "redirect:http://www.51xuecheng.cn/sign.html?username="+username+"&authType=wx";
    }
}
```

定义微信认证的service

```Java
package com.xuecheng.ucenter.service.impl;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * @author Mr.M
 * @version 1.0
 * @description 微信扫码认证
 * @date 2022/9/29 12:12
 */
@Slf4j
@Service("wx_authservice")
public class WxAuthServiceImpl implements AuthService {

    @Autowired
    XcUserMapper xcUserMapper;

    @Override
    public XcUserExt execute(AuthParamsDto authParamsDto) {

        //账号
        String username = authParamsDto.getUsername();
        XcUser user = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getUsername, username));
        if(user==null){
            //返回空表示用户不存在
            throw new RuntimeException("账号不存在");
        }
        XcUserExt xcUserExt = new XcUserExt();
        BeanUtils.copyProperties(user,xcUserExt);
        return xcUserExt;
    }
}
```

#### 4.3.3 接口环境测试

接口定义好下边进行测试下，主要目的是测试接口调度的环境。

1、启动内网穿透工具

2、在/wxLogin接口中打断点

3、打开前端微信扫码页面

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500376.png)

点击微信图标打开二维码

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500878.png)

用户扫码，确认授权

此时正常进入 /wxLogin  方法，最后跳转到http://www.51xuecheng.cn/sign.html?username=t1&authType=wx。

#### 4.3.4 接入微信认证 

接下来请求微信申请令牌。

1、使用restTemplate请求微信，配置RestTemplate bean

在启动类配置restTemplate

```Java
    @Bean
    RestTemplate restTemplate(){
        RestTemplate restTemplate = new RestTemplate(new OkHttp3ClientHttpRequestFactory());
        return  restTemplate;
    }
```

2、定义与微信认证的service接口：

```Java
/**
 * @author Mr.M
 * @version 1.0
 * @description 微信认证接口
 * @date 2023/2/21 22:15
 */
public interface WxAuthService {

    public XcUser wxAuth(String code);

}
```

3、下边在controller中调用wxAuth接口：

```Java
@Slf4j
@Controller
public class WxLoginController {

    @Autowired
    WxAuthService wxAuthService;

    @RequestMapping("/wxLogin")
    public String wxLogin(String code, String state) throws IOException {
        log.debug("微信扫码回调,code:{},state:{}",code,state);
        //请求微信申请令牌，拿到令牌查询用户信息，将用户信息写入本项目数据库
        XcUser xcUser = wxAuthService.wxAuth(code);
        if(xcUser==null){
            return "redirect:http://www.51xuecheng.cn/error.html";
        }
        String username = xcUser.getUsername();
        return "redirect:http://www.51xuecheng.cn/sign.html?username="+username+"&authType=wx";
    }
}
```

4、在WxAuthService 的wxAuth方法中实现申请令牌、查询用户信息等内容。

```Java
@Slf4j
@Service("wx_authservice")
public class WxAuthServiceImpl implements AuthService, WxAuthService {
@Autowired
XcUserMapper xcUserMapper;
@Autowired
RestTemplate restTemplate;

@Value("${weixin.appid}")
String appid;
@Value("${weixin.secret}")
String secret;

public XcUser wxAuth(String code){

    //收到code调用微信接口申请access_token
    Map<String, String> access_token_map = getAccess_token(code);
    if(access_token_map==null){
        return null;
    }
    System.out.println(access_token_map);
    String openid = access_token_map.get("openid");
    String access_token = access_token_map.get("access_token");
    //拿access_token查询用户信息
    Map<String, String> userinfo = getUserinfo(access_token, openid);
    if(userinfo==null){
        return null;
    }
    //添加用户到数据库
    XcUser xcUser = null;
    
    return xcUser;
}

/**
 * 申请访问令牌,响应示例
 {
 "access_token":"ACCESS_TOKEN",
 "expires_in":7200,
 "refresh_token":"REFRESH_TOKEN",
 "openid":"OPENID",
 "scope":"SCOPE",
 "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"
 }
*/
private Map<String,String> getAccess_token(String code) {

    String wxUrl_template = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&secret=%s&code=%s&grant_type=authorization_code";
    //请求微信地址
    String wxUrl = String.format(wxUrl_template, appid, secret, code);

    log.info("调用微信接口申请access_token, url:{}", wxUrl);

    ResponseEntity<String> exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, null, String.class);

    String result = exchange.getBody();
    log.info("调用微信接口申请access_token: 返回值:{}", result);
    Map<String,String> resultMap = JSON.parseObject(result, Map.class);

    return resultMap;
}

/**获取用户信息，示例如下：
 {
 "openid":"OPENID",
 "nickname":"NICKNAME",
 "sex":1,
 "province":"PROVINCE",
 "city":"CITY",
 "country":"COUNTRY",
 "headimgurl": "https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0",
 "privilege":[
 "PRIVILEGE1",
 "PRIVILEGE2"
 ],
 "unionid": " o6_bmasdasdsad6_2sgVt7hMZOPfL"
 }
*/
private Map<String,String> getUserinfo(String access_token,String openid) {

    String wxUrl_template = "https://api.weixin.qq.com/sns/userinfo?access_token=%s&openid=%s";
    //请求微信地址
    String wxUrl = String.format(wxUrl_template, access_token,openid);

    log.info("调用微信接口申请access_token, url:{}", wxUrl);

    ResponseEntity<String> exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, null, String.class);

    //防止乱码进行转码
    String result = new     String(exchange.getBody().getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
    log.info("调用微信接口申请access_token: 返回值:{}", result);
    Map<String,String> resultMap = JSON.parseObject(result, Map.class);

    return resultMap;
}
....
```

测试获取用户信息

1、在获取用户信息处打断点

2、进入http://www.51xuecheng.cn/wxsign.html

3、手机扫码授权

#### 4.3.5 保存用户信息

向数据库保存用户信息，如果用户不存在将其保存在数据库。

```Java
@Autowired
XcUserRoleMapper xcUserRoleMapper;

@Transactional
public XcUser addWxUser(Map userInfo_map){
    String unionid = userInfo_map.get("unionid").toString();
    //根据unionid查询数据库
    XcUser xcUser = xcUserMapper.selectOne(new LambdaQueryWrapper<XcUser>().eq(XcUser::getWxUnionid, unionid));
    if(xcUser!=null){
        return xcUser;
    }
    String userId = UUID.randomUUID().toString();
    xcUser = new XcUser();
    xcUser.setId(userId);
    xcUser.setWxUnionid(unionid);
    //记录从微信得到的昵称
    xcUser.setNickname(userInfo_map.get("nickname").toString());
    xcUser.setUserpic(userInfo_map.get("headimgurl").toString());
    xcUser.setName(userInfo_map.get("nickname").toString());
    xcUser.setUsername(unionid);
    xcUser.setPassword(unionid);
    xcUser.setUtype("101001");//学生类型
    xcUser.setStatus("1");//用户状态
    xcUser.setCreateTime(LocalDateTime.now());
    xcUserMapper.insert(xcUser);
    XcUserRole xcUserRole = new XcUserRole();
    xcUserRole.setId(UUID.randomUUID().toString());
    xcUserRole.setUserId(userId);
    xcUserRole.setRoleId("17");//学生角色
    xcUserRoleMapper.insert(xcUserRole);
    return xcUser;
}
```

调用保存用户信息

```Java
@Autowired
WxAuthServiceImpl currentProxy;

public XcUser wxAuth(String code){

    //收到code调用微信接口申请access_token
    Map<String, String> access_token_map = getAccess_token(code);
    if(access_token_map==null){
        return null;
    }
    System.out.println(access_token_map);
    String openid = access_token_map.get("openid");
    String access_token = access_token_map.get("access_token");
    //拿access_token查询用户信息
    Map<String, String> userinfo = getUserinfo(access_token, openid);
    if(userinfo==null){
        return null;
    }
    //将用户信息保存到数据库
    XcUser xcUser = currentProxy.addWxUser(userinfo);
    return xcUser;
}
```

测试保存用户信息

1、在保存用户信息处打断点

2、进入http://www.51xuecheng.cn/wxsign.html

3、手机扫码授权

4、自动跳转到登录页面，提交认证成功。

## 10.5 用户授权

### 5.1 RBAC

如何实现授权？业界通常基于RBAC实现授权。

RBAC分为两种方式：

基于角色的访问控制（Role-Based Access Control）

基于资源的访问控制（Resource-Based Access Control）

角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等，访问控制流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500420.png)

根据上图中的判断逻辑，授权代码可表示如下：

```Java
if(主体.hasRole("总经理角色id")){
查询工资
}
```

如果上图中查询工资所需要的角色变化为总经理和部门经理，此时就需要修改判断逻辑为“判断用户的角色是否是总经理或部门经理”，修改代码如下：

```Java
if(主体.hasRole("总经理角色id") ||  主体.hasRole("部门经理角色id")){
    查询工资
}
```

根据上边的例子发现，当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差。

 

基于资源的访问控制（Resource-Based Access

Control）是按资源（或权限）进行授权，比如：用户必须具有查询工资权限才可以查询员工工资信息等，访问控制流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500299.png)

根据上图中的判断，授权代码可以表示为：

```Java
if(主体.hasPermission("查询工资权限标识")){
    查询工资
}
```

优点：系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，系统可扩展性强。

### 5.2 资源服务授权流程

本项目在资源服务内部进行授权，基于资源的授权模式，因为接口在资源服务，通过在接口处添加授权注解实现授权。

1、首先配置nginx代理

```Java
   http {
    server_names_hash_bucket_size 64;
    ...
   
   #前端开发服务
  upstream uidevserver{
    server 127.0.0.1:8601 weight=10;
  } 
   server {
        listen       80;
        server_name  teacher.51xuecheng.cn;
        #charset koi8-r;
        ssi on;
        ssi_silent_errors on;
        #access_log  logs/host.access.log  main;
        #location / {
         #   alias   D:/itcast2022/xc_edu3.0/code_1/dist/;
         #   index  index.html index.htm;
        #}
        location / {
            proxy_pass   http://uidevserver;
        }

        location /api/ {
                proxy_pass http://gatewayserver/;
        } 
        
        
   }
```

加载nginx 配置。

2、在资源服务集成Spring Security

在需要授权的接口处使用@PreAuthorize("hasAuthority('权限标识符')")进行控制

下边代码指定/course/list接口需要拥有xc_teachmanager_course_list 权限。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500747.png)

设置了@PreAuthorize表示执行此方法需要授权，如果当前用户请求接口没有权限则抛出异常

org.springframework.security.access.AccessDeniedException: 不允许访问

3、在统一异常处理处解析此异常信息

```Java
@ResponseBody
@ExceptionHandler(Exception.class)
@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
public RestErrorResponse exception(Exception e) {

   log.error("【系统异常】{}",e.getMessage(),e);
   e.printStackTrace();
   if(e.getMessage().equals("不允许访问")){
      return new RestErrorResponse("没有操作此功能的权限");
   }
   return new RestErrorResponse(CommonError.UNKOWN_ERROR.getErrMessage());


}
```

4、重启资源服务进行测试

使用教学机构用户登录系统

这里使用t1用户登录，账号:t1、密码：111111

登录成功，点击“教学机构”

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500216.png)

当用户没有权限时页面提示：没有操作此功能的权限。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500995.png)

### 5.3 授权相关的数据模型

如何给用户分配权限呢？

首先要学习数据模型，本项目授权相关的数据表如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429137.png)

说明如下：

xc_user：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等

xc_role：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等。

xc_user_role：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有

xc_menu:模块表，记录了菜单及菜单下的权限

xc_permission:角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有

本项目教学阶段不再实现权限定义及用户权限分配的功能，权限分配的界面原型如下图所示：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500558.png)

本项目要求掌握基于权限数据模型（5张数据表），要求在数据库中操作完成给用户分配权限、查询用户权限等需求。

1、查询用户所拥有的权限

步骤：

查询用户的id

查询用户所拥有的角色

查询用户所拥有的权限

例子：

SELECT * FROM xc_menu WHERE id IN(    SELECT menu_id FROM xc_permission WHERE role_id IN(        SELECT role_id FROM xc_user_role WHERE user_id = '49'    ) )

2、给用户分配权限

1）添加权限

查询用户的id

查询权限的id

查询用户的角色，如果没有角色需要先给用户指定角色

向角色权限表添加记录

2）删除用户权限

本项目是基于角色分配权限，如果要删除用户的权限可以给用户换角色，那么新角色下的权限就是用户的权限；如果不换用户的角色可以删除角色下的权限即删除角色权限关系表相应记录，这样操作是将角色下的权限删除，属于该角色的用户都将删除此权限。

### **5.4 查询用户权限**

使用Spring Security进行授权，首先在生成jwt前会查询用户的权限，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429507.png)

接下来需要修改UserServiceImpl和PasswordAuthServiceImpl从数据库查询用户的权限。

1、定义mapper接口

```Java
public interface XcMenuMapper extends BaseMapper<XcMenu> {
    @Select("SELECT    * FROM xc_menu WHERE id IN (SELECT menu_id FROM xc_permission WHERE role_id IN ( SELECT role_id FROM xc_user_role WHERE user_id = #{userId} ))")
    List<XcMenu> selectPermissionByUserId(@Param("userId") String userId);
}
```

2、修改PasswordAuthServiceImpl

修改UserServiceImpl类的getUserPrincipal方法，查询权限信息

```Java
//查询用户身份
public UserDetails getUserPrincipal(XcUserExt user){
    String password = user.getPassword();
    //查询用户权限
    List<XcMenu> xcMenus = menuMapper.selectPermissionByUserId(user.getId());
    List<String> permissions = new ArrayList<>();
    if(xcMenus.size()<=0){
        //用户权限,如果不加则报Cannot pass a null GrantedAuthority collection
        permissions.add("p1");
    }else{
        xcMenus.forEach(menu->{
            permissions.add(menu.getCode());
        });
    }
    //将用户权限放在XcUserExt中
    user.setPermissions(permissions);

    //为了安全在令牌中不放密码
    user.setPassword(null);
    //将user对象转json
    String userString = JSON.toJSONString(user);
    String[] authorities = permissions.toArray(new String[0]);
    UserDetails userDetails = User.withUsername(userString).password(password).authorities(authorities).build();
    return userDetails;

}
```

### 5.5 授权测试

以上实现了认证时从数据库查询用户的权限，下边进行用户授权测试。

重启认证服务，使用内容管理课程列表查询为例，代码如下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Njc2ZTBhN2MzZTAwOTBlN2VmZmUxMjRiMDQwNjkxMTdfcnZ4UEdEWmNENWQyOTkzRUloNmtKaHIyUEJiZkZFZ3hfVG9rZW46SThjV2JmR3dzb2F5S0d4ZUVVM2NDeE9kbkdoXzE3MzIzNDMzMzM6MTczMjM0NjkzM19WNA)

用户拥有xc_teachmanager_course_list权限方可访问课程查询接口。

以用户stu1为例，当它没有此权限时页面报“没有此操作的权限”错误

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500470.png)

将xc_teachmanager_course_list权限分配给用户。

1）首先找到当前用户的角色

2）找到xc_teachmanager_course_list权限的主键

3）在角色权限关系表中添加记录

分配完权限需要重新登录

由于用户分配了xc_teachmanager_course_list权限，用户具有访问课程查询接口的权限。

### 5.6 细粒度授权

#### 5.6.1 什么是细粒度授权

什么是细粒度授权？

细粒度授权也叫数据范围授权，即不同的用户所拥有的操作权限相同，但是能够操作的数据范围是不一样的。一个例子：用户A和用户B都是教学机构，他们都拥有“我的课程”权限，但是两个用户所查询到的数据是不一样的。

本项目有哪些细粒度授权？

比如：

我的课程，教学机构只允许查询本教学机构下的课程信息。

我的选课，学生只允许查询自己所选课。

如何实现细粒度授权？

细粒度授权涉及到不同的业务逻辑，通常在service层实现，根据不同的用户进行校验，根据不同的参数查询不同的数据或操作不同的数据。

#### 5.6.2 教学机构细粒度授权

教学机构在维护课程时只允许维护本机构的课程，教学机构细粒度授权过程如下：

1）获取当前登录的用户身份

2）得到用户所属教育机构的Id

3）查询该教学机构下的课程信息

最终实现了用户只允许查询自己机构的课程信息。

根据公司Id查询课程，流程如下：

1）教学机构用户登录系统，从用户身份中取出所属机构的id

在用户表中设计了company_id字段存储该用户所属的机构id.

2）接口层取出当前登录用户的身份，取出机构id

3) 将机构id传入service方法。
4) service方法将机构id传入Dao方法，最终查询出本机构的课程信息。

代码实现如下：

```Java
@ApiOperation("课程查询接口")
@PreAuthorize("hasAuthority('xc_teachmanager_course_list')")//拥有课程列表查询的权限方可访问
@PostMapping("/course/list")
public PageResult<CourseBase> list(PageParams pageParams, @RequestBody QueryCourseParamsDto queryCourseParams){
    //取出用户身份
    XcUser user = SecurityUtil.getUser();
    //机构id
    String companyId = user.getCompanyId();
    return courseBaseInfoService.queryCourseBaseList(Long.parseLong(companyId),pageParams,queryCourseParams);
}
```

Service方法如下：

```Java
@Override
public PageResult<CourseBase> queryCourseBaseList(Long companyId,PageParams pageParams, QueryCourseParamsDto queryCourseParamsDto) {

 //构建查询条件对象
 LambdaQueryWrapper<CourseBase> queryWrapper = new LambdaQueryWrapper<>();
 //机构id
 queryWrapper.eq(CourseBase::getCompanyId,companyId);
 ....
```

#### 5.6.3 教学机构细粒度授权测试

使用一个教学机构的用户登录项目，并且此用户具有查询课程的权限。

手机修改数据库指定用户归属到一个机构中，涉及以下数据表：

xc_company为机构表

xc_company_user为机构用户关系表

xc_user表中有company_id字段。

我们准备了t1 用户作为此次测试的用户，使用此用户登录系统：

提前在查询课程列表接口处打上断点。

经过测试可以正常取出用户所属的机构id

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500164.png)

跟踪持久层日志发现已将机构id传入dao方法，拼装sql语句，查询本机构的课程信息

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500081.png)

## 10.6 实战

### 6.1 找回密码(实战)

需求：忘记密码需要找回，可以通过手机号找回密码，通过邮箱找回密码以及人工通道。

界面访问地址：http://www.51xuecheng.cn/findpassword.html

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231500502.png)

接口：

手机验证码：/api/checkcode/phone?param1=手机号

邮箱验证码：/api/checkcode/phone?param1=电子邮箱地址

找回密码：/api/auth/findpassword

请求：

```JSON
{
     cellphone:'',
     email:'',
     checkcodekey:'',
     checkcode:'',
     confirmpwd:'',
     password:''
 }
```

响应：

200: 找回成功

其它：找回失败，失败原因使用统一异常处理返回的信息格式

执行流程 1、校验验证码，不一致则抛出异常

2、判断两次密码是否一致，不一致则抛出异常

3、根据手机号和邮箱查询用户

4、如果找到用户更新为新密码

### 6.2 注册(实战)

需求：为学生提供注册入口，通过此入口注册的用户为学生用户。

界面访问地址：http://www.51xuecheng.cn/register.html

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231429389.png)

接口：

手机验证码：/api/checkcode/phone?param1=手机号

注册：/api/auth/register

请求：

```JSON
{
   cellphone:'',
   username:'',
   email:'',
   nickname:'',
   password:'',
   confirmpwd:'',
   checkcodekey:'',
   checkcode:''
}
```

响应：

200: 注册成功

其它：注册失败，失败原因使用统一异常处理返回的信息格式

执行流程：

1、校验验证码，如果不一致则抛出异常

2、校验两次密码是否一致，如果不一致则抛出异常

3、校验用户是否存在，如果存在则抛出异常

4、向用户表、用户角色关系表添加数据。角色为学生角色。







# 11、支付

## 3.1 需求分析

### 3.1.1 执行流程

用户去学习收费课程时引导其去支付，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501437.png)

当用户点击“微信支付”或支付宝支付时执行流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501627.png)

1、请求学习中心服务创建选课记录

2、请求订单服务创建商品订单、生成支付二维码。

3、用户扫码请求订单支付服务，订单支付服务请求第三方支付平台生成支付订单。

4、前端唤起支付客户端，用户输入密码完成支付。

5、第三方支付平台支付完成发起支付通知。

6、订单支付服务接收第三方支付通知结果。

7、用户在前端查询支付结果，请求订单支付服务查询支付结果。

8、订单支付服务向学习中心服务通知支付结果。

9、学习中心服务收到支付结果，如果支付成功则更新选课记录，并添加到我的课程表。

### 3.1.2 通用订单服务设计

在本项目中不仅选课需要下单、购买学习资料、老师一对一答疑等所以收费项目都需要下单支付。

所以本项目设计通用的订单服务，通用的订单服务承接各业务模块的收费支付需求，当用户需要交费时统一生成商品订单并进行支付。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQ4ZmEzZjMzNzk1NDY1OTA2NzRiODM0YWM2MjBhYTZfZUU4TU5sVzJ5elQ5WFdIQ21sWHNHcFYxdEJmd1o1cUlfVG9rZW46TlRiQ2JDZ2Fhb2RmcDN4VUoyaGNOYW1ibjFnXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

所有收费业务最终转换为商品订单记录在订单服务的商品订单表。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODAxZWRmMzExNWY1YTlkMWRjNjBhN2UzNjNkNWZlOWZfSE1MSEdTUE1vRFFwbXNoMkdLY1A2NkZadUFGckV3UjZfVG9rZW46VWZHaGJzYlZqb2wya2x4d29KU2Nwc2RsbmNkXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

以选课为例，选课记录表的ID记录在商品订单表的out_business_id字段。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJjYjQ0ZTcxM2FmOWVjZmIwNDgwMjgzOWJhODBiODZfNE83M3J5YXk2YXRLSjlOcEl3Nm40ZjBoRXVqSk1kTzNfVG9rZW46Sm1oOGJOSlBUb05HeVN4Y2MzNWNPaVFsbkllXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

## 3.2 支付接口调研

### 3.2.1 微信支付接口调研

一般情况下，一个网站要支持在线支付功能通常接入第三方支付平台，比如：微信支付、支付宝、其它的聚合支付平台。

本项目的需求实现手机扫码支付，现在对微信、支付宝的支付接口进行调研。

微信目前提供的支付方式如下：

地址：https://pay.weixin.qq.com/static/product/product_index.shtml

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTI2NDk4ZGMwODMzYjQ3MWQ1ODA2Mzg5MTRlNzAzNDBfWmZGZTlsTkI0TnJ0THRETGlXcHNvQ1RxVHFNV0ZBY2pfVG9rZW46WlQzQ2JtQndVb0d1WVl4bU41a2NaV0RJbjdkXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

1、付款码支付是指用户展示微信钱包内的“付款码”给商户系统扫描后直接完成支付，适用于线下场所面对面收银的场景，例如商超、便利店、餐饮、医院、学校、电影院和旅游景区等具有明确经营地址的实体场所。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501805.png)

2、JSAPI支付是指商户通过调用微信支付提供的JSAPI接口，在支付场景中调起微信支付模块完成收款

线下场所：调用接口生成二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付

公众号场景：用户在微信公众账号内进入商家公众号，打开某个主页面，完成支付

PC网站场景：在网站中展示二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501131.png)

3、小程序支付是指商户通过调用微信支付小程序支付接口，在微信小程序平台内实现支付功能；用户打开商家助手小程序下单，输入支付密码并完成支付后，返回商家小程序。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTZiZTIzZTRmNTQ5NDJlOGJlNzQwNzRlYWIxNTkwMDBfanptYkk1TlJLdHVTSnFWTGlMaWpKNUNTdVprcXpjZ0pfVG9rZW46R3pTZmJvQ2Vtb1BGOHN4YVZmVWNvZmM3bnJjXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

4、Native支付是指商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。该模式适用于PC网站、实体店单品或订单、媒体广告支付等场景。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NjcwODRiOWNkZmU2YmMzNjAzZGY2MDkyYmY0NjU3NDNfYm5mR0xXc2I5MDBIMEVEYjNLQ1d0MWNSYkhyTmV1UFhfVG9rZW46VldKdWJ4TG16b0VyY3Z4bkZKNGNvN1Y3bjZnXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

5、APP支付是指商户通过在移动端应用APP中集成开放SDK调起微信支付模块来完成支付。适用于在移动端APP中集成微信支付功能的场景。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NDUyZjgzZjA3NWY0NjdlNTE5ZDhhMjlmOTA2MDFjZGRfTHFZOEhsRDljOWx6M1kxaUtxWkUySkpJUWhOTWdGeDJfVG9rZW46SmhWbmJZeTdsb1Nrdkd4TnN0WWMxYUtHbkhjXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

6、刷脸支付是指用户在刷脸设备前通过摄像头刷脸、识别身份后进行的一种支付方式，安全便捷。适用于线下实体场所的收银场景，如商超、餐饮、便利店、医院、学校等。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjAzMmI5MWFiYzFlNDZmZWQxZTg2MzkzYzM4MzM0ODBfM0daVTJxRHhpcUh3Vm00RGlLMmF1MmdkaW9XWEV5am1fVG9rZW46RnA1ZmI5Z3prbzU2djh4d2d1VmNwZFZLbldnXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

以上接口native和JSAPI都可以实现pc网站实现扫码支付，两者区别是什么？怎么选择？

JSAPI除了在pc网站扫码支付还可以实现公众号页面内支付，可以实现在手机端H5页面唤起微信客户端完成支付。

本项目选择JSAPI支付接口。

接口文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_1.shtml

如何开通JSAPI支付接口?

以企业身份注册微信公众号https://mp.weixin.qq.com/

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmY0YmRlNmVjODBhY2U5OTY5MWQ4ZWE5YjIwOTU5MGJfZUZRVXpra3Vuem5WRG5XS0RwRFJjQWlCdFNzMkFhUXJfVG9rZW46SER5S2JEd05sb2UwQ1p4dXRDOGNjb3pubm1nXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

登录公众号，点击左侧菜单“微信支付”开通微信支付，如下：

需要提供营业执照、身份证等信息。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTkyOTMxYTY0ZDhjNjJiZjQ4ZmMxMmVmYzNkOWU4ZTdfc3pnbnhHRVdLZFkwY3BIMHdqQWZxQk5yUDlONXJmUFpfVG9rZW46UWtGamJYTUZqbzB0N2Z4N096Q2NVcGFsbjVlXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

点击申请接入，需要注册微信商户号。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501722.png)

注册微信商户号的过程请参考官方文档，本文档略。参考地址如下：

https://pay.weixin.qq.com/index.php/apply/applyment_home/guide_normal#none

开通微信支付后即可在微信商户平台（pay.weixin.qq.com）开通JSAPI支付。

登录商品平台，进入产品中心，开通JSAPI支付：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NDk3YzU5ZDQ5ZjQzN2EzYjg0YjRhZjIyNDhiM2EwZDRfeVJ1eTRpWjVGSnNOcFl1Q1RTM2FYQjA4eTNxcnA3ZnVfVG9rZW46WTNrcGJrcm9Rb1VIeXJ4d25DcWNBUFdMbkpsXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

注意：JSAPI支付方式需要在公众号配置回调域名，此域名为已经备案的外网域名。

最后在公众号开发信息中获取：开发者id、开发者密码。

### 3.2.2 支付宝接口调研

支付宝支付产品如下：

文档：https://b.alipay.com/signing/productSetV2.htm

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501132.png)

与本项目需求相关的接口：电脑网站支付、手机网站支付。

1、电脑网站支付

PC网站轻松收款，资金马上到账：用户在商家PC网站消费，自动跳转支付宝PC网站收银台完成付款。 交易资金直接打入商家支付宝账户，实时到账。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU1YjQ0MTE1ZWIxZDBmMjE2ODQzYWI0YWFmZjM1NzlfRXNiNmx2QWxnQlBXMnFyZ29FdTdOWDhqRU9SZWNPOUJfVG9rZW46TDVNTGJoTUgzb3F4WUF4MGZMVWNVbjhzbnpjXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

2、手机网站支付

用户在商家手机网站消费，通过浏览器自动跳转支付宝APP或支付宝网页完成付款。 轻松实现和APP支付相同的支付体验。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NmM2ZGNkNmNlNTFmNDRiMTFkNDcyODg5YjZhOTljZDlfcmFzTUtSQ2o3bkFRZno3MmE5OERRRjB0Y2VyanRueE9fVG9rZW46UU0xS2JtS2hjb2lpczV4T3BGN2N1cjRxbmdlXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

对比两种支付方式：手机网站支付方式可以在H5网页唤起支付宝，手机扫码支付可以使用手机网站支付方式来完成，相比电脑网站支付形式更灵活。

本项目选择手机网站支付方式。

文档：https://opendocs.alipay.com/open/02ivbt

如何开通支付宝手机网站支付接口？

进入网址：https://b.alipay.com/signing/productDetailV2.htm?productId=I1011000290000001001

点击：立即开通

上传营业执照等资料，提交审核，根据提示进行开通。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501360.png)

## 3.3 准备开发环境

### 3.3.1 支付宝开发环境

第三方支付接口流程大同小异，考虑开发及教学的方便性，支付宝提供支付宝沙箱环境开发支付接口，在教学中接入支付宝手机网站支付接口。

1、配置沙箱环境

沙箱环境是支付宝开放平台为开发者提供的与生产环境完全隔离的联调测试环境，开发者在沙箱环境中完成的接口调用不会对生产环境中的数据造成任何影响。

接入手机网站支付需要具备如下条件：

- 申请前必须拥有经过实名认证的支付宝账户；
- 企业或个体工商户可申请；
- 需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致；
- 网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息；
- 网站必须通过ICP备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致；
- 如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。

详细参见：https://docs.open.alipay.com/203

本文档使用支付宝沙箱进行开发测试，这里主要介绍支付宝沙箱环境配置。

详细参见：https://docs.open.alipay.com/200/105311/

开发过程需要三个支付参数：app_id、应用私钥、支付宝公钥，下边在支付宝开发平台配置沙箱环境。

进入支付宝开放平台：https://open.alipay.com/ 

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501894.png)

点击登录，使用自己的支付宝账号扫码登录即可。

登录成功，进入控制台：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MzkxOGMyZTIyMWExYTgwOTRjOWVmNmFlNDMwNTdhZjFfV0ViVFBtWDloZ3JraGx3RjRITjM0dTE4TnFVdDJGc1lfVG9rZW46S2VlTmJBTEUyb1JqdWF4S1lQemNLMzBmbktlXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

在控制台首页最下方 点击进入沙箱环境

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTdiNTMxOTlmNjI0M2Y1MDMwOTRkOTIzMjEwZDdkNWJfRGN5VjFNenIxanVhQ0F1bXFLNW1PWXlSUHg2eGRBeDhfVG9rZW46TVpvaGJLYVFKb3dyUXh4cDFMRWNBNFJTbkVnXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

进入沙箱环境页面列出了应用信息，其中就有我们需要的appid。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MmM5OGVmZWMxNmJjZTRlYTdjMjE4OWJjMGFjNWZmMjRfZ0RPeWdiekp1Y2JOUFlVSmRIcWhWZUoySDFROEF4dDFfVG9rZW46WjdvcGJnYmZUb1NvMWh4WVJqQ2NmZlY3bmllXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

点击“查看”，查看密钥，开发需要支付宝公钥和应用私钥，稍后我们需要使用它们进行开发测试。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTkwNWIzN2Q1MmZjMDg2MDExMjBkMmU5NDQwZGYzOGZfWnFKWU55QXZpSjFWTUVqV3B2TkVEQk1pY2Njc3ZiWVVfVG9rZW46QkYyZ2JxVlg0b2ZzWXB4Q1NBY2NxbVZwbkNiXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

根据测试需要进行充值（沙箱环境为虚拟充值）

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501240.png)

2、模拟器

下载模拟器：http://mumu.163.com/

安装模拟器，安装在没有空格和中文的目录。

安装成功，启动模拟器

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501140.png)

下一步在模拟器安装支付宝：

选择课程资料中支付宝安装包wallet_101521226_client_release_201812261416.apk（沙箱版本）

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTYwNDdiNWVmZTUzN2NiMjkwOTRhMDk3OWFiZDY3MjdfMzdQUXF1Rmt5OHFhTEZRQXkyODA0TzloZzdva3BvbGxfVG9rZW46QmNCeGJKMEx0b1JqV2V4aU9UeGNzTHdtbm5nXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

安装成功后支付宝客户端的快捷方式出现在桌面上。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVmZjJiZmRmMGEwMjAzNzk5NjM2NTlkMThkMjkzODlfQ2E0Nlc0WGFPQWJ4RnBFVXM4U1d4ZTB0Rm5TRmZEaldfVG9rZW46TnE1WGJiSnU3b2szQ0x4R2NveWNlRjFxbjBNXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

使用沙箱环境的买家账号登录沙箱版本的支付宝。

查看沙箱环境的账号：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501961.png)

### 3.3.2 创建订单服务

拷贝课程资料目录下的订单服务工程xuecheng-plus-orders到自己的工程目录。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YzllMDA5NTY4MmRhMTY4M2E4M2M4NzBlOTBmNDFhM2NfZ1I2eFE5MTlwMkIzUldvRng2TmpNamd4OWYycERlOWRfVG9rZW46TWRSZ2J5S3lUb2RncGF4dnBjNGNJUzhIbnFiXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

创建xc_orders数据库，并导入xcplus_orders.sql 

修改nacos中orders-service-dev.yaml的数据库连接参数。

## 3.4 支付接口测试

### 3.4.1 阅读接口定义

手机网站支付接入流程详细参见：https://docs.open.alipay.com/203/105285/

1、接口交互流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501826.png)

1）用户在商户的H5网站下单支付后，商户系统按照[手机网站支付接口alipay.trade.wap.pay](https://docs.open.alipay.com/203/107090)API的参数规范生成订单数据

2）前端页面通过Form表单的形式请求到支付宝。此时支付宝会自动将页面跳转至支付宝H5收银台页面，如果用户手机上安装了支付宝APP，则自动唤起支付宝APP。

3）输入支付密码完成支付。

4）用户在支付宝APP或H5收银台完成支付后，会根据商户在手机网站支付API中传入的前台回跳地址return_url自动跳转回商户页面，同时在URL请求中以Query String的形式附带上支付结果参数，详细回跳参数见“手机网站支付接口alipay.trade.wap.pay”[前台回跳参数](https://docs.open.alipay.com/203/107090#s2)。

5）支付宝还会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统，详情见[支付结果异步通知](https://docs.open.alipay.com/203/105286)。

2、接口定义

文档：https://opendocs.alipay.com/open/203/107090

接口定义：外部商户请求支付宝创建订单并支付

公共参数

**请求地址**：

开发中使用沙箱地址：https://openapi.alipaydev.com/gateway.do

请求参数：

详细查阅https://opendocs.alipay.com/open/203/107090

一部分由sdk设置，一部分需要编写程序时指定。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501545.png)

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501828.png)

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I4NDYzNzhmNmIxMGQ5MmZiZDRlYjY2MTFmY2JjZThfYnpOR2hJQzB5UmVxZjBuMGlybGVPbW1yNVVjZGVaYUNfVG9rZW46V1JXV2J4cDkzb2NXTW54Tm9hQWNjUWlZbmRoXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTYxMmVjYTI3MDU2Y2NjNzQyMjIwOTgxMGU3MTVjMThfcWk1ejN4N3MzZFdoVjdXUENaMkVLOGRUZWEyUEtIQ2ZfVG9rZW46S1N2OWJRQWo2bzNoVE54SVdOUmNkU2RXblRjXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

其它扩展参数参见接口文档。

3、示例代码

```Java
public void doPost(HttpServletRequest httpRequest,
                   HttpServletResponse httpResponse) throws ServletException, IOException {
    AlipayClient alipayClient = ... //获得初始化的AlipayClient
    AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
    alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
    alipayRequest.setNotifyUrl("http://domain.com/CallBack/notify_url.jsp");//在公共参数中设置回跳和通知地址
    alipayRequest.setBizContent("{" +
            "    \"out_trade_no\":\"20150320010101002\"," +
            "    \"total_amount\":88.88," +
            "    \"subject\":\"Iphone6 16G\"," +
            "    \"product_code\":\"QUICK_WAP_WAY\"" +
            "  }");//填充业务参数
    String form = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单
    httpResponse.setContentType("text/html;charset=" + AlipayServiceEnvConstants.CHARSET);
    httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面
    httpResponse.getWriter().flush();
}
```

### 3.4.2 下单执行流程

根据接口描述，支付宝下单接口的执行流程如下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NDlmNDRiNThkOWI5NTJhYjk0NDY4MGYwMGY1NjA2MTNfRWlhWTlFZ0Z1TmVUTmZIanI2ejVhTldUR2lSS0hoYUVfVG9rZW46RWh2QWIxMzd6b2ZZMkV4VFY3U2NST2tIbnBkXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

### 3.4.3 支付接口测试

#### 3.4.3.1 编写下单代码

根据接口流程，首先在订单服务编写测试类请求支付宝下单的接口。

在订单服务api工程添加依赖：

```XML
<!-- 支付宝SDK -->
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>3.7.73.ALL</version>
</dependency>

<!-- 支付宝SDK依赖的日志 -->
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>1.2</version>
</dependency>
```

下载示例代码https://opendocs.alipay.com/open/203/105910

拷贝示例代码，修改、测试。

拷贝AlipayConfig.java到订单服务的service工程。

```Java
package com.xuecheng.orders.api;

import com.alipay.api.AlipayApiException;
import com.alipay.api.AlipayClient;
import com.alipay.api.DefaultAlipayClient;
import com.alipay.api.request.AlipayTradeWapPayRequest;
import com.xuecheng.orders.config.AlipayConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @author Mr.M
 * @version 1.0
 * @description 测试支付宝接口
 * @date 2022/10/20 22:19
 */
@Controller
public class PayTestController {

    @Value("${pay.alipay.APP_ID}")
    String APP_ID;
    @Value("${pay.alipay.APP_PRIVATE_KEY}")
    String APP_PRIVATE_KEY;

    @Value("${pay.alipay.ALIPAY_PUBLIC_KEY}")
    String ALIPAY_PUBLIC_KEY;



    @RequestMapping("/alipaytest")
    public void doPost(HttpServletRequest httpRequest,
                       HttpServletResponse httpResponse) throws ServletException, IOException, AlipayApiException {
        AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY,AlipayConfig.SIGNTYPE);
        //获得初始化的AlipayClient
        AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
//        alipayRequest.setNotifyUrl("http://domain.com/CallBack/notify_url.jsp");//在公共参数中设置回跳和通知地址
        alipayRequest.setBizContent("{" +
                "    \"out_trade_no\":\"202210100010101002\"," +
                "    \"total_amount\":0.1," +
                "    \"subject\":\"Iphone6 16G\"," +
                "    \"product_code\":\"QUICK_WAP_WAY\"" +
                "  }");//填充业务参数
        String form = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单
        httpResponse.setContentType("text/html;charset=" + AlipayConfig.CHARSET);
        httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面
        httpResponse.getWriter().flush();
    }

}
```

#### 3.4.3.2 生成二维码

用户在前端使用支付宝沙箱通过扫码请求下单接口，我们需要生成订单服务的下单接口的二维码。

ZXing是一个开源的类库，是用Java编写的多格式的1D / 2D条码图像处理库，使用ZXing可以生成、识别QR Code（二维码）。常用的二维码处理库还有zbar，近几年已经不再更新代码，下边介绍ZXing生成二维码的方法。

1）引入依赖

在base工程pom.xml中添加依赖：

```XML
        <!-- 二维码生成&识别组件 -->
        <dependency>
            <groupId>com.google.zxing</groupId>
            <artifactId>core</artifactId>
            <version>3.3.3</version>
        </dependency>

        <dependency>
            <groupId>com.google.zxing</groupId>
            <artifactId>javase</artifactId>
            <version>3.3.3</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
```

2）生成二维码方法

拷贝课程资料中utils下的QRCodeUtil.java到base工程util包下。

测试根据内容生成二维码方法，在QRCodeUtil中添加main方法如下：

```Java
    public static void main(String[] args) throws IOException {
        QRCodeUtil qrCodeUtil = new QRCodeUtil();
        System.out.println(qrCodeUtil.createQRCode("http://www.itcast.cn/", 200, 200));
    }
```

运行main方法输入二维码图片的base64串，如下：

```Bash
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAQAAAACFI5MzAAABQElEQVR42u2YPZKDMAyF5aFIuUfIUThafDSOwhEoUzC8fZKMySSbrVI8ZuICBX8uIvtZPxjeDfuSf8liPi7LFSgrzRTvV3XCKawXYLptFobviz6ZzB2xEfTjhyS9OwXB3A7jbMSngLOQ0I4v2AZf96wqTWJ9+9/dYEHSx2RYqfg/oqUgiX3nFBVfcCepcSbiJP67iwZ1G+5+Am7kyTzW9OcW/kRAX+QJ953+uCl8zO5PV5UsaffUp8rqP5+jiySJU8jtNxcNrysetCNK6A/V4lEQeU+xa0eZREE1tOTpFYod0VKXsKCqvRqMkW5pkza8Ggy3WgEuTvZcz0dcUBc+9MneL1DqkXjQz0eaZA1LqVtmzcMffTKPiPwz1mh2zkGyNwtT9kguTVI7LWv6ul7DCpOjX9iaGV66HDny/ZL1WfILfc/hMHLUpekAAAAASUVORK5CYII=
```

将base64串复制到浏览器地址后回车将展示一个二维码，用户用手机扫此二维码将请求至http://www.itcast.cn/。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTJhZjNmOGE2ZjZkOGQzYTJjMjc1OGNhMmYzZjVhOTBfMHVMaE1JVTRsS081am1GOUpNWEtpNlcwd3hHc3JaeTRfVG9rZW46QzM5Y2JCQUVVb1J0aHd4WVNZbmMxRkhlbmhkXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

#### 3.4.3.3 接口测试

1、生成订单服务下单接口的二维码

修改二维码生成的代码如下：

```Java
public static void main(String[] args) throws IOException {
      QRCodeUtil qrCodeUtil = new QRCodeUtil();
      System.out.println(qrCodeUtil.createQRCode("http://localhost:63030/orders/alipaytest", 200, 200));

}
```

注意：http://localhost:63030地址用模拟器无法访问，进入cmd命令状态，输入命令ipconfig -all 查看本地网卡分配的局域网ip地址，将上边的地址修改如下：

```Plain
http://192.168.101.1:63030/orders/alipaytest
```

运行main方法，复制输出到控制台的base64串。

```Bash
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAQAAAACFI5MzAAABxUlEQVR42u2YO46EMBBEGxE45AjcBC6GhCUuNtzER3DoANFbZT4zu9KmNavVOLAwj6BV/TXmvy37kL9Oopl1sS+DWV/M2oRzKyWL+95tfXDfenyzJK/vlCTZ0G1WGpzDDlKA9ST2YbfJrMnz2wiE8WQw8A2E/lkc6kQ66afnBKTGKCwaru179ApIXVBnzNb7gy+/ZbCAQJgB5zLCyrD6ZnSSlPAxm1VNyphh28NmKUFI7F3EQ55qrXJfL3VUBOGZJyssF74C45tWSjbEBW2DJslG94QPtQTNYsyzH9WSrgmXOiqCCBlgFmIUhMLwKCVcSFHkxsaagcY1vmSwgkRDZE5WO4YzT6tYSuIprNTEzskBedq5lNS4wEs2TOiEbT1tUxGslaW6OoX98+5ZKhLpmhYFi8LsTNY7T1WE7apNzE5UCgiDD2cpca+T612v0zNGZYQWMVDhJG7h2dE1BOoMSIujUjQcZUYxOWcXBodzeuKmJdddhtNTqZNcc1cxDTnuMmwbxr7dup5wjl8S44J9O75Mdkpyzo1hr/eqV9tUBE+8waBy80p1T3YictxpDyexcQUXk+Muw9m5RohZnWKU5PMX55+RLyKnzJvqtaeFAAAAAElFTkSuQmCC
```

打开模拟器，在模拟器中打开浏览器，将base64串复制到浏览器的地址栏。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501079.png)

使用截屏工具进行截屏，稍后使用支付宝沙箱客户端扫此图片。

 

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501325.png)

2、启动订单服务

3、打开模拟器，在模拟器中打开支付宝沙箱客户端，并使用沙箱客户端账号密码登录。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQ0N2QyZWJjMGM0OWMwYmNhOGY2OWE2YjMwMjkzMmNfdWRPdmRudFdsV3JQVTNxSnV5TGxweFI5N1BpNnlZcXRfVG9rZW46VzZaV2JubnZNb0ZOalR4OU9jY2NNbndHbllkXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

点击扫一扫选择相册中刚才截屏的二维码

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MTRjODdjNWZlNzM3ODM1YzIyNzI5MTRkY2U2MDhjMTdfUnc4dkdBN2lFY3VtcnR1RnFRV3FrcXRDZjlqV005cGpfVG9rZW46S2xpSmJ4WjMzb0ZzYnB4N1E2WWNRTnc5bllrXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501007.png)

扫码后如果提示系统繁忙再重试

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501045.png)

如果提示请求勿重复提交则需要修改下单测试代码中指定的out_trade_no商品订单号，订单号在每个商户是唯一的，每次支付前修改out_trade_no 为一个没有使用过的订单号。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501920.png)

修改订单号后重启订单服务，再使用沙箱支付宝客户端扫码

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501315.png)

输入支付密码进行支付。

支付密码为沙箱账号的支付密码，此支付所扣款为沙箱账号的虚拟货币余额。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBkOThiYzEzZGU0NzA5YzBiMGVkMDVhNzlhZGZhZjZfMHR1VnpHZEYwWGVQNjRhenFFUDBKOHZDTEY4enZvU0NfVG9rZW46WDhocmJURTdVb3JsVjJ4VXRUVGNad1Y1bmVoXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

支付成功界面：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501214.png)

### 3.4.4 支付结果查询接口

支付完成可以调用第三方支付平台的支付结果查询接口 查询支付结果。

文档：https://opendocs.alipay.com/open/02ivbt

示例代码：

```Java
AlipayClient alipayClient = new DefaultAlipayClient("https://openapi.alipay.com/gateway.do","app_id","your private_key","json","GBK","alipay_public_key","RSA2");
AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
JSONObject bizContent = new JSONObject();
bizContent.put("out_trade_no", "20150320010101001");
//bizContent.put("trade_no", "2014112611001004680073956707");
request.setBizContent(bizContent.toString());
AlipayTradeQueryResponse response = alipayClient.execute(request);
if(response.isSuccess()){
    System.out.println("调用成功");
} else {
    System.out.println("调用失败");
}
```

刚才订单付款成功，可以使用out_trade_no商品订单号或支付宝的交易流水号trade_no去查询支付结果。

out_trade_no商品订单号:  是在下单请求时指定的商品订单号。

支付宝的交易流水号trade_no：是支付完成后支付宝通知支付结果时发送的trade_no

我们使用out_trade_no商品订单号去查询，代码如下：

```Java
package com.xuecheng.orders.api;

import com.alibaba.fastjson.JSONObject;
import com.alipay.api.AlipayApiException;
import com.alipay.api.AlipayClient;
import com.alipay.api.DefaultAlipayClient;
import com.alipay.api.request.AlipayTradeQueryRequest;
import com.alipay.api.response.AlipayTradeQueryResponse;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

/**
 * @author Mr.M
 * @version 1.0
 * @description 支付宝查询接口
 * @date 2022/10/4 17:18
 */
@SpringBootTest
public class AliPayTest {

    @Value("${pay.alipay.APP_ID}")
    String APP_ID;
    @Value("${pay.alipay.APP_PRIVATE_KEY}")
    String APP_PRIVATE_KEY;
    
    @Value("${pay.alipay.ALIPAY_PUBLIC_KEY}")
    String ALIPAY_PUBLIC_KEY;

@Test
public void queryPayResult() throws AlipayApiException {
    AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, "json", AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); //获得初始化的AlipayClient
    AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
    JSONObject bizContent = new JSONObject();
    bizContent.put("out_trade_no", "202210100010101002");
    //bizContent.put("trade_no", "2014112611001004680073956707");
    request.setBizContent(bizContent.toString());
    AlipayTradeQueryResponse response = alipayClient.execute(request);
    if (response.isSuccess()) {
        System.out.println("调用成功");
        String resultJson = response.getBody();
        //转map
        Map resultMap = JSON.parseObject(resultJson, Map.class);
        Map alipay_trade_query_response = (Map) resultMap.get("alipay_trade_query_response");
        //支付结果
        String trade_status = (String) alipay_trade_query_response.get("trade_status");
        System.out.println(trade_status);
    } else {
        System.out.println("调用失败");
    }
}
}
```

运行代码，输出如下：

```Plain
调用成功
TRADE_SUCCESS
```

输出结果即是调用支付宝查询接口查询到的支付结果

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjVkZGI0NjNiNjVjODAwYWE5NjQxZjAyNDVjNDA0MWZfUnJDRDNDcFBQajg2Zk16b3k1Zzg0UjdaTVFGaEFkMVBfVG9rZW46SDRTa2J6Zmo5b2ZrMml4dnN0QmM1enkxbjlnXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

参考文档https://opendocs.alipay.com/open/02ivbt 查阅每个参数的意义。

我们主要需要下边的参数：

"out_trade_no" : "20220520010101026",

"trade_no":"2022100422001422760505740639"  ： 支付宝交易流水号

"total_amount" : "1.30"

"trade_status" : "TRADE_SUCCESS"： 交易状态

交易状态类型：

交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）

TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）

TRADE_SUCCESS（交易支付成功）

TRADE_FINISHED（交易结束，不可退款）

### 3.4.5 支付结果通知接口

#### 3.4.5.1 准备环境

对于手机网站支付产生的交易，支付宝会通知商户支付结果，有两种通知方式，通过return_url、notify_url进行通知，使用return_url不能保证通知到位，推荐使用notify_url完成支付结构通知。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501983.png)

具体的使用方法是在调用下单接口的 API 中传入的异步通知地址 notify_url，通过 POST 请求的形式将支付结果作为参数通知到商户系统。详情可查看 [支付宝异步通知说明](https://opendocs.alipay.com/support/01raw4) 。

文档：https://opendocs.alipay.com/open/203/105286

根据下单执行流程，订单服务收到支付结果需要对内容进行验签，验签过程如下：

1. 在通知返回参数列表中，除去sign、sign_type两个参数外，凡是通知返回回来的参数皆是待验签的参数。将剩下参数进行 url_decode，然后进行字典排序，组成字符串，得到待签名字符串； 生活号异步通知组成的待验签串里需要保留 sign_type 参数。
2. 将签名参数（sign）使用 base64 解码为字节码串；
3. 使用 RSA 的验签方法，通过签名字符串、签名参数（经过 base64 解码）及支付宝公钥验证签名。
4. 验证签名正确后，必须再严格按照如下描述校验通知数据的正确性。

在上述验证通过后，商户必须根据支付宝不同类型的业务通知，正确的进行不同的业务处理，并且过滤重复的通知结果数据。

通过验证out_trade_no、total_amount、appid参数的正确性判断通知请求的合法性。

验证的过程可以参考sdk demo代码，下载 sdk demo代码，https://opendocs.alipay.com/open/203/105910

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501982.png)

参考demo中的alipay.trade.wap.pay-java-utf-8\WebContent\ notify_url.jsp

另外，支付宝通知订单服务的地址必须为外网域名且备案通过可以正常访问。

此接口仍然使用内网穿透技术。

#### 3.4.5.2 编写测试代码

1、在下单请求时设置通知地址request.setNotifyUrl("商户自己的notify_url地址");

```Java
@GetMapping("/alipaytest")
    public void alipaytest(HttpServletRequest httpRequest,
                           HttpServletResponse httpResponse) throws ServletException, IOException {
        //构造sdk的客户端对象
        AlipayClient alipayClient = new DefaultAlipayClient(serverUrl, APP_ID, APP_PRIVATE_KEY, "json", CHARSET, ALIPAY_PUBLIC_KEY, sign_type); //获得初始化的AlipayClient
        AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
        alipayRequest.setNotifyUrl("http://tjxt-user-t.itheima.net/xuecheng/orders/paynotify");//在公共参数中设置回跳和通知地址
        .....
        
```

2、编写接收通知接口，接收参数并验签

参考课程资料下的alipay.trade.wap.pay-java-utf-8\WebContent\notify_url.jsp

代码如下：

```Java
//接收通知
@PostMapping("/paynotify")
public void paynotify(HttpServletRequest request,HttpServletResponse response) throws UnsupportedEncodingException, AlipayApiException {
    Map<String,String> params = new HashMap<String,String>();
    Map requestParams = request.getParameterMap();
    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) {
        String name = (String) iter.next();
        String[] values = (String[]) requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i]
                    : valueStr + values[i] + ",";
        }
        //乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化
        //valueStr = new String(valueStr.getBytes("ISO-8859-1"), "gbk");
        params.put(name, valueStr);
    }

   
    //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//
    //计算得出通知验证结果
    //boolean AlipaySignature.rsaCheckV1(Map<String, String> params, String publicKey, String charset, String sign_type)
    boolean verify_result = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, "RSA2");

    if(verify_result) {//验证成功
        //////////////////////////////////////////////////////////////////////////////////////////
        //请在这里加上商户的业务逻辑程序代码
        
         //商户订单号
        String out_trade_no = new String(request.getParameter("out_trade_no").getBytes("ISO-8859-1"),"UTF-8");
        //支付宝交易号
    
        String trade_no = new String(request.getParameter("trade_no").getBytes("ISO-8859-1"),"UTF-8");
    
        //交易状态
        String trade_status = new String(request.getParameter("trade_status").getBytes("ISO-8859-1"),"UTF-8");


        //——请根据您的业务逻辑来编写程序（以下代码仅作参考）——

        if (trade_status.equals("TRADE_FINISHED")) {//交易结束
            //判断该笔订单是否在商户网站中已经做过处理
            //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序
            //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的
            //如果有做过处理，不执行商户的业务程序

            //注意：
            //如果签约的是可退款协议，退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知
            //如果没有签约可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。
        } else if (trade_status.equals("TRADE_SUCCESS")) {//交易成功
            System.out.println(trade_status);
            //判断该笔订单是否在商户网站中已经做过处理
            //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序
            //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的
            //如果有做过处理，不执行商户的业务程序

            //注意：
            //如果签约的是可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。
        }
        response.getWriter().write("success");
    }else{
        response.getWriter().write("fail");
    }


}
```

#### 3.4.5.3 通知接口测试

1、重启订单服务，并在接收通知接口中打上断点

2、配置内网穿透的本地端口为订单服务端口，启动内网穿透客户端。

3、打开模拟器、支付宝沙箱，扫码、支付。

4、观察接收订单支付数据等是否正常。

## 3.5 生成支付二维码

### 3.5.1 需求分析

#### 3.5.1.1 执行流程

再次打开课程支付引导界面，点击“支付宝支付”按钮系统该如何处理？

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NGU1MWZjYTAzMDQyNjk1ZmFlNTQ2MzY3N2E2OTk5YWNfRHF3SEZkZzVDaUYyQmZ0ZnhmNTZpbGI4NkRkUzdCWGdfVG9rZW46UmVJSGJ0enlpb0NoYnJ4bjNuWWNUUUhzbjB2XzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

点击“支付宝支付”此时打开支付二维码，用户扫码支付。

所以首先需要生成支付二维码，用户扫描二维码开始请求支付宝下单，在向支付宝下单前需要添加选课记录、创建商品订单、生成支付记录。

生成二维码执行流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501688.png)

执行流程：

1、前端调用学习中心服务的添加选课接口。

2、添加选课成功请求订单服务生成支付二维码接口。

3、生成二维码接口：创建商品订单、生成支付记录、生成二维码。

4、将二维码返回到前端，用户扫码。

用户扫码支付流程如下：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc1MDNlZDc1YjE0MTkyYWY5MDBmZmQ0OGU3MDIzNmJfbURiNWMxaFFZeHd5dEJueERITG9kcjRoNkVaUWlpUFNfVG9rZW46TW9acmJpUkE5b2ZBVU14dDhNaWNqeUdIblhjXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

执行流程：

1、用户输入支付密码，支付成功。

2、接收第三方平台通知的支付结果。

3、根据支付结果更新支付记录的支付状态为支付成功。

#### 3.5.1.2 数据模型

订单支付模式的核心由三张表组成：订单表、订单明细表、支付记录表。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501202.png)

订单表：记录订单信息

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJiN2MwYzdiZWJiMWUxMmQ1OTcxYzY0ODQ1ZGZhYzdfTHh4SGU4QlN1TTRHMlR5cXlhT0pQWU1vSUFWekhZZ0pfVG9rZW46S2JlYWJWMWt3b3JZR214QklTR2M2c2JubkZQXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

订单明细表记录订单的详细信息

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501833.png)

支付记录表记录每次支付的详细信息

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501984.png)

为什么创建支付记录表？

在请求微信、支付宝或其它第三方支付平台下单接口时需要传入商户的订单号，如果将我们系统的商品订单号直接传给第三方支付平台，当支付交易关闭或其它什么原因就导致第三方支付平台报“订单号已存在”，此时我们系统的订单将无法完成支付，我们的需求是用户什么时候想支付都可以完成支付。

解决以上问题的方案是：

1、用户每次发起支付都创建一个新的支付记录 ，此支付记录与商品订单关联。

2、将支付记录的流水号传给第三方支付系统的下单接口，这样即可解决上边的问题。

3、不过在程序中要考虑重复支付的问题。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NmVmYzAzMzE4NDI3ZDJmOTE5MTc3Nzc1ZWJiOGQ4NjRfam9FR0FjcmFOSWhncGVjM3M1WlBHSXJjY3lxVTNDZW5fVG9rZW46UlhNSGJITkFqb1BHYTV4eDBQaGNtODZ3bjNlXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

### 3.5.2 接口定义

在订单服务中定义生成支付二维码接口。

请求：订单信息

响应：支付记录及二维码

下边先定义模型类再定义接口：

请求的订单模型类：

```Java
package com.xuecheng.orders.model.dto;

import com.xuecheng.orders.model.po.XcOrders;
import lombok.Data;
import lombok.ToString;

/**
 * @author Mr.M
 * @version 1.0
 * @description 创建商品订单
 * @date 2022/10/4 10:21
 */
@Data
@ToString
public class AddOrderDto  {

    /**
     * 总价
     */
    private Float totalPrice;

    /**
     * 订单类型
     */
    private String orderType;

    /**
     * 订单名称
     */
    private String orderName;
    /**
     * 订单描述
     */
    private String orderDescrip;

    /**
     * 订单明细json，不可为空
     * [{"goodsId":"","goodsType":"","goodsName":"","goodsPrice":"","goodsDetail":""},{...}]
     */
    private String orderDetail;

    /**
     * 外部系统业务id
     */
    private String outBusinessId;

}
```

响应：支付记录信息及二维码信息

```Java
@Data
@ToString
public class PayRecordDto extends XcPayRecord {

    //二维码
    private String qrcode;

}
```

生成支付二维码定义如下：

```Java
@Api(value = "订单支付接口", tags = "订单支付接口")
@Slf4j
@Controller
public class OrderController {

    @ApiOperation("生成支付二维码")
    @PostMapping("/generatepaycode")
    @ResponseBody
    public PayRecordDto generatePayCode(@RequestBody AddOrderDto addOrderDto) {
        
            return null;
    }

}
```

### 3.5.3 接口实现

#### 3.5.3.1 保存商品订单

定义保存订单信息接口

```Java
public interface OrderService {


   /**
 * @description 创建商品订单
 * @param addOrderDto 订单信息
 * @return PayRecordDto 支付记录(包括二维码)
 * @author Mr.M
 * @date 2022/10/4 11:02
*/
public PayRecordDto createOrder(String userId,AddOrderDto addOrderDto);
```

在保存订单接口中需要完成创建商品订单、创建支付记录，接口实现方法如下：

```Java
@Slf4j
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    XcOrdersMapper ordersMapper;
    @Autowired
    XcOrdersGoodsMapper ordersGoodsMapper;
    
    @Autowired
    XcPayRecordMapper payRecordMapper;

    @Transactional
    @Override
    public PayRecordDto createOrder(String userId, AddOrderDto addOrderDto) {

        //添加商品订单

        //添加支付记录
        
        //生成二维码
        
        return null;
    }
}
```

编写创建商品订单方法：

第一：确定订单号的生成规则 

订单号注意唯一性、安全性、尽量短等特点，生成方案常用的如下：

1、时间戳+随机数

年月日时分秒毫秒+随机数

2、高并发场景

年月日时分秒毫秒+随机数+redis自增序列

3、订单号中加上业务标识

订单号加上业务标识方便客服，比如：第10位是业务类型，第11位是用户类型等。

4、雪花算法

雪花算法是推特内部使用的分布式环境下的唯一ID生成算法，它基于时间戳生成，保证有序递增，加以入计算机硬件等元素，可以满足高并发环境下ID不重复。

本项目订单号生成采用雪花算法。

第二：商品订单的数据来源于选课记录，在订单表需要存入选课记录的ID，这里需要作好幂等处理。

```Java
public XcOrders saveXcOrders(String userId,AddOrderDto addOrderDto){
    //幂等性处理
    XcOrders order = getOrderByBusinessId(addOrderDto.getOutBusinessId());
    if(order!=null){
        return order;
    }
    order = new XcOrders();
    //生成订单号
    long orderId = IdWorkerUtils.getInstance().nextId();
    order.setId(orderId);
    order.setTotalPrice(addOrderDto.getTotalPrice());
    order.setCreateDate(LocalDateTime.now());
    order.setStatus("600001");//未支付
    order.setUserId(userId);
    order.setOrderType(addOrderDto.getOrderType());
    order.setOrderName(addOrderDto.getOrderName());
    order.setOrderDetail(addOrderDto.getOrderDetail());
    order.setOrderDescrip(addOrderDto.getOrderDescrip());
    order.setOutBusinessId(addOrderDto.getOutBusinessId());//选课记录id
    ordersMapper.insert(order);
    String orderDetailJson = addOrderDto.getOrderDetail();
    List<XcOrdersGoods> xcOrdersGoodsList = JSON.parseArray(orderDetailJson, XcOrdersGoods.class);
    xcOrdersGoodsList.forEach(goods->{
        XcOrdersGoods xcOrdersGoods = new XcOrdersGoods();
        BeanUtils.copyProperties(goods,xcOrdersGoods);
        xcOrdersGoods.setOrderId(orderId);//订单号
        ordersGoodsMapper.insert(xcOrdersGoods);
    });
    return order;
}

//根据业务id查询订单
public XcOrders getOrderByBusinessId(String businessId) {
    XcOrders orders = ordersMapper.selectOne(new LambdaQueryWrapper<XcOrders>().eq(XcOrders::getOutBusinessId, businessId));
    return orders;
}
```

#### 3.5.3.2 创建支付记录

编写创建支付记录的方法：

```Java
public XcPayRecord createPayRecord(XcOrders orders){
    if(order==null){
       XueChengPlusException.cast("订单不存在");
    }
    if(orders.getStatus().equals("600002")){
        XueChengPlusException.cast("订单已支付");
    }
    XcPayRecord payRecord = new XcPayRecord();
    //生成支付交易流水号
    long payNo = IdWorkerUtils.getInstance().nextId();
    payRecord.setPayNo(payNo);
    payRecord.setOrderId(orders.getId());//商品订单号
    payRecord.setOrderName(orders.getOrderName());
    payRecord.setTotalPrice(orders.getTotalPrice());
    payRecord.setCurrency("CNY");
    payRecord.setCreateDate(LocalDateTime.now());
    payRecord.setStatus("601001");//未支付
    payRecord.setUserId(orders.getUserId());
    payRecordMapper.insert(payRecord);
    return payRecord;

}
```

#### 3.5.3.3 生成支付二维码

1、在nacos中orders-service-dev.yaml配置二维码的url

```Java
pay:
 qrcodeurl: http://192.168.101.1:63030/orders/requestpay?payNo=%s
```

2、完善创建订单service方法:

```Java
@Value("${pay.qrcodeurl}")
String qrcodeurl;

@Transactional
@Override
public PayRecordDto createOrder(String userId, AddOrderDto addOrderDto) {
    //创建商品订单
    XcOrders orders = saveXcOrders(userId, addOrderDto);
    if(orders==null){
        XueChengPlusException.cast("订单创建失败");
    }
    //生成支付记录
    XcPayRecord payRecord = createPayRecord(orders);
    //生成二维码
    String qrCode = null;
    try {
        //url要可以被模拟器访问到，url为下单接口(稍后定义)
        String url = String.format(qrcodeurl, payRecord.getPayNo());
        qrCode = new QRCodeUtil().createQRCode(url, 200, 200);
    } catch (IOException e) {
        XueChengPlusException.cast("生成二维码出错");
    }
    PayRecordDto payRecordDto = new PayRecordDto();
    BeanUtils.copyProperties(payRecord,payRecordDto);
    payRecordDto.setQrcode(qrCode);

    return payRecordDto;
}
```

#### 3.5.3.4 生成二维码接口完善

完善生成支付二维码controller接口

```Java
@Autowired
OrderService orderService;
    
@ApiOperation("生成支付二维码")
@PostMapping("/generatepaycode")
@ResponseBody
public PayRecordDto generatePayCode(@RequestBody AddOrderDto addOrderDto) {
    //登录用户
    SecurityUtil.XcUser user = SecurityUtil.getUser();
    if(user == null){
        XueChengPlusException.cast("请登录后继续选课");
    }
   return orderService.createOrder(user.getId(), addOrderDto);
   
}
```

#### 3.5.3.5 扫码下单接口

生成了支付二维码，用户扫码请求第三方支付平台下单，下单成功用户完成支付。

1、定义用户扫码请求下单接口如下：

```Java
@ApiOperation("扫码下单接口")
@GetMapping("/requestpay")
public void requestpay(String payNo,HttpServletResponse httpResponse) throws IOException {

}
```

2、定义查询支付记录的Service接口与实现方法

扫码下单传入的是支付记录号，根据支付记录号查询支付记录。

```Java
/**
 * @description 查询支付记录
 * @param payNo  交易记录号
 * @return com.xuecheng.orders.model.po.XcPayRecord
 * @author Mr.M
 * @date 2022/10/20 23:38
*/
public XcPayRecord getPayRecordByPayno(String payNo);
```

实现如下：

```Java
@Override
public XcPayRecord getPayRecordByPayno(String payNo) {
    XcPayRecord xcPayRecord = payRecordMapper.selectOne(new LambdaQueryWrapper<XcPayRecord>().eq(XcPayRecord::getPayNo, payNo));
    return xcPayRecord;
}
```

3、完善扫码下单接口如下：

```Java
@Value("${pay.alipay.APP_ID}")
String APP_ID;
@Value("${pay.alipay.APP_PRIVATE_KEY}")
String APP_PRIVATE_KEY;

@Value("${pay.alipay.ALIPAY_PUBLIC_KEY}")
String ALIPAY_PUBLIC_KEY;

    @ApiOperation("扫码下单接口")
    @GetMapping("/requestpay")
    public void requestpay(String payNo,HttpServletResponse httpResponse) throws IOException {
        //如果payNo不存在则提示重新发起支付
        XcPayRecord payRecord = orderService.getPayRecordByPayno(payNo);
        if(payRecord == null){
            XueChengPlusException.cast("请重新点击支付获取二维码");
        }
        //支付状态
        String status = payRecord.getStatus();
        if("601002".equals(status)){
            XueChengPlusException.cast("订单已支付，请勿重复支付。");
        }
        //构造sdk的客户端对象
        AlipayClient client = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE);//获得初始化的AlipayClient
        AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request
//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");
//        alipayRequest.setNotifyUrl("http://tjxt-user-t.itheima.net/xuecheng/orders/paynotify");//在公共参数中设置回跳和通知地址
        alipayRequest.setBizContent("{" +
                " \"out_trade_no\":\""+payRecord.getPayNo()+"\"," +
                " \"total_amount\":\""+payRecord.getTotalPrice()+"\"," +
                " \"subject\":\""+payRecord.getOrderName()+"\"," +
                " \"product_code\":\"QUICK_WAP_PAY\"" +
                " }");//填充业务参数
        String form = "";
        try {
            //请求支付宝下单接口,发起http请求
            form = client.pageExecute(alipayRequest).getBody(); //调用SDK生成表单
        } catch (AlipayApiException e) {
            e.printStackTrace();
        }
        httpResponse.setContentType("text/html;charset=" + AlipayConfig.CHARSET);
        httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面
        httpResponse.getWriter().flush();
        httpResponse.getWriter().close();
    }
```

### 3.5.3 支付测试

测试准备：

1、启动网关服务、认证服务、验证码服务、学习中心服务、订单服务、内容管理服务。

2、发布一门收费课程。

3、使用资料目录中的新模板course_template.ftl 

测试流程：

1、进入收费课程详细页面，点击马上学习。

2、跟踪浏览器及微服务，观察选课记录是否创建成功、商品订单是否创建成功、支付记录是否创建成功。

3、观察生成二维码是否成功

4、使用模拟器扫码测试，是否可以正常支付。

如果报订单参数异常报如下错误，需要检查请求支付宝的下单数据是否正确。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501510.png)

### 3.5.4 重复支付问题

上边实现中，扫码下单时会根据支付记录号判断是否支付完成，生成二维码时也会判断订单的状态是否支付完成，如果支付完成将不再重新支付，即使这样做也无法绝对避免重复支付。

正常情况下同一个用户的同一个订单不会存在并发扫码支付的问题，但系统是可能存在重复支付的问题的，解决该问题需要单独定义任务，每隔24小时查询前一天的订单是否存在重复支付的问题，如果存在则调用第三方支付平台的退款接口进行退款。

## 3.6 查询支付结果

### 3.6.1 接口定义

根据前边我们调研的获取支付结果的接口，包括：主动查询支付结果、被动接收支付结果。

这里先实现主动查询支付结果，当支付完成用户点击 “支付完成” 将请求第三方支付平台查询支付结果。

在OrderController类中定义接口如下：

```Java
@ApiOperation("查询支付结果")
@GetMapping("/payresult")
@ResponseBody
public PayRecordDto payresult(String payNo) throws IOException {
    //查询支付结果
    
    return null;

}
```

### 3.6.2 接口实现

#### 3.6.2.1 service总体接口

1、定义查询支付结果的service

```Java
/**
 * 请求支付宝查询支付结果
 * @param payNo 支付记录id
 * @return 支付记录信息
 */
public PayRecordDto queryPayResult(String payNo);
```

2、service实现如下：

```Java
@Override
public PayRecordDto queryPayResult(String payNo){
    XcPayRecord payRecord = getPayRecordByPayno(payNo);
    if (payRecord == null) {
        XueChengPlusException.cast("请重新点击支付获取二维码");
    }
    //支付状态
    String status = payRecord.getStatus();
    //如果支付成功直接返回
    if ("601002".equals(status)) {
        PayRecordDto payRecordDto = new PayRecordDto();
        BeanUtils.copyProperties(payRecord, payRecordDto);
        return payRecordDto;
    }
    //从支付宝查询支付结果
    PayStatusDto payStatusDto = queryPayResultFromAlipay(payNo);
    //保存支付结果
    currentProxy.saveAliPayStatus( payStatusDto);
    //重新查询支付记录
    payRecord = getPayRecordByPayno(payNo);
    PayRecordDto payRecordDto = new PayRecordDto();
    BeanUtils.copyProperties(payRecord, payRecordDto);
    return payRecordDto;

}

/**
 * 请求支付宝查询支付结果
 * @param payNo 支付交易号
 * @return 支付结果
 */
public PayStatusDto queryPayResultFromAlipay(String payNo){

}

/**
 * @description 保存支付宝支付结果
 * @param payStatusDto  支付结果信息
 * @return void
 * @author Mr.M
 * @date 2022/10/4 16:52
 */
public void saveAliPayStatus(PayStatusDto payStatusDto) ;
```

#### 3.6.2.2 查询支付结果

定义从支付宝查询支付结果的方法

```Java
/**
 * 请求支付宝查询支付结果
 * @param payNo 支付交易号
 * @return 支付结果
 */
public PayStatusDto queryPayResultFromAlipay(String payNo) {

    //========请求支付宝查询支付结果=============
    AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, "json", AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); //获得初始化的AlipayClient
    AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
    JSONObject bizContent = new JSONObject();
    bizContent.put("out_trade_no", payNo);
    request.setBizContent(bizContent.toString());
    AlipayTradeQueryResponse response = null;
    try {
        response = alipayClient.execute(request);
        if (!response.isSuccess()) {
            XueChengPlusException.cast("请求支付查询查询失败");
        }
    } catch (AlipayApiException e) {
        log.error("请求支付宝查询支付结果异常:{}", e.toString(), e);
        XueChengPlusException.cast("请求支付查询查询失败");
    }

    //获取支付结果
    String resultJson = response.getBody();
    //转map
    Map resultMap = JSON.parseObject(resultJson, Map.class);
    Map alipay_trade_query_response = (Map) resultMap.get("alipay_trade_query_response");
    //支付结果
    String trade_status = (String) alipay_trade_query_response.get("trade_status");
    String total_amount = (String) alipay_trade_query_response.get("total_amount");
    String trade_no = (String) alipay_trade_query_response.get("trade_no");
    //保存支付结果
    PayStatusDto payStatusDto = new PayStatusDto();
    payStatusDto.setOut_trade_no(payNo);
    payStatusDto.setTrade_status(trade_status);
    payStatusDto.setApp_id(APP_ID);
    payStatusDto.setTrade_no(trade_no);
    payStatusDto.setTotal_amount(total_amount);
    return payStatusDto;

}
```

#### 3.6.2.3 保存支付结果

1、定义保存支付结果的接口

```Java
/**
 * @description 保存支付宝支付结果
 * @param payStatusDto  支付结果信息
 * @return void
 * @author Mr.M
 * @date 2022/10/4 16:52
 */
public void saveAliPayStatus(PayStatusDto payStatusDto) ;
```

2、编写接口实现

```Java
@Transactional
@Override
public void saveAliPayStatus(PayStatusDto payStatusDto) {
    //支付流水号
    String payNo = payStatusDto.getOut_trade_no();
    XcPayRecord payRecord = getPayRecordByPayno(payNo);
    if (payRecord == null) {
        XueChengPlusException.cast("支付记录找不到");
    }
    //支付结果
    String trade_status = payStatusDto.getTrade_status();
    log.debug("收到支付结果:{},支付记录:{}}", payStatusDto.toString(),payRecord.toString());
    if (trade_status.equals("TRADE_SUCCESS")) {

        //支付金额变为分
        Float totalPrice = payRecord.getTotalPrice() * 100;
        Float total_amount = Float.parseFloat(payStatusDto.getTotal_amount()) * 100;
        //校验是否一致
        if (totalPrice.intValue() != total_amount.intValue()) {
            //校验失败
            log.info("校验支付结果失败,支付记录:{},APP_ID:{},totalPrice:{}" ,payRecord.toString(),payStatusDto.getApp_id(),total_amount.intValue());
            XueChengPlusException.cast("校验支付结果失败");
        }
        log.debug("更新支付结果,支付交易流水号:{},支付结果:{}", payNo, trade_status);
        XcPayRecord payRecord_u = new XcPayRecord();
        payRecord_u.setStatus("601002");//支付成功
        payRecord_u.setOutPayChannel("Alipay");
        payRecord_u.setOutPayNo(payStatusDto.getTrade_no());//支付宝交易号
        payRecord_u.setPaySuccessTime(LocalDateTime.now());//通知时间
        int update1 = payRecordMapper.update(payRecord_u, new LambdaQueryWrapper<XcPayRecord>().eq(XcPayRecord::getPayNo, payNo));
        if (update1 > 0) {
            log.info("更新支付记录状态成功:{}", payRecord_u.toString());
        } else {
            log.info("更新支付记录状态失败:{}", payRecord_u.toString());
            XueChengPlusException.cast("更新支付记录状态失败");
        }
        //关联的订单号
        Long orderId = payRecord.getOrderId();
        XcOrders orders = ordersMapper.selectById(orderId);
        if (orders == null) {
            log.info("根据支付记录[{}}]找不到订单", payRecord_u.toString());
            XueChengPlusException.cast("根据支付记录找不到订单");
        }
        XcOrders order_u = new XcOrders();
        order_u.setStatus("600002");//支付成功
        int update = ordersMapper.update(order_u, new LambdaQueryWrapper<XcOrders>().eq(XcOrders::getId, orderId));
        if (update > 0) {
            log.info("更新订单表状态成功,订单号:{}", orderId);
        } else {
            log.info("更新订单表状态失败,订单号:{}", orderId);
            XueChengPlusException.cast("更新订单表状态失败");
        }
    }

}
```

### 3.6.3 接口测试

1、完善接口

```Java
@ApiOperation("查询支付结果")
@GetMapping("/payresult")
@ResponseBody
public PayRecordDto payresult(String payNo) throws IOException {
    //调用支付宝接口查询
    PayRecordDto payRecordDto = orderService.queryPayResult(payNo);
    return payRecordDto;
}
```

2、测试流程

完成生成支付二维码

用支付宝扫码但不支付

使用httpclient请求查询支付结果，查询失败

```Java
### 查询支付结果
GET {{orders_host}}/orders/payresult?payNo=1628648111951941632
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJ7XCJiaXJ0aGRheVwiOlwiMjAyMi0wOS0yOFQxOToyODo0NlwiLFwiY3JlYXRlVGltZVwiOlwiMjAyMi0wOS0yOFQwODozMjowM1wiLFwiaWRcIjpcIjUwXCIsXCJuYW1lXCI6XCLlrabnlJ8xXCIsXCJuaWNrbmFtZVwiOlwi5aSn5rC054mbXCIsXCJwZXJtaXNzaW9uc1wiOltdLFwic2V4XCI6XCIxXCIsXCJzdGF0dXNcIjpcIjFcIixcInVzZXJuYW1lXCI6XCJzdHUxXCIsXCJ1c2VycGljXCI6XCJodHRwOi8vZmlsZS41MXh1ZWNoZW5nLmNuL2RkZGZcIixcInV0eXBlXCI6XCIxMDEwMDFcIn0iLCJzY29wZSI6WyJhbGwiXSwiZXhwIjoxNjc3MTQwMDI1LCJhdXRob3JpdGllcyI6WyJwMSJdLCJqdGkiOiJmYThiMmY1OS03ZTQ5LTRmODUtOTBlMC05NzYwNjlkYjE3ODIiLCJjbGllbnRfaWQiOiJYY1dlYkFwcCJ9.89sp5lPdFafZ_HdGhe8Cpv0anMJC3vT4PtaGMHgCkr8
```

用支付宝扫码再次完成支付

使用httpclient请求查询支付结果，支付结果为成功，并更新支付记录状态和订单状态。

3、使用前后端联调

拷贝资料目录中LocalDateTimeConfig.java到base工程下，处理long转string精度损失的问题。

使用最新的门户代码xc-ui-pc-static-portal.zip

## 3.7 接收支付通知

### 3.7.1 接口定义

支付完成后第三方支付系统会主动通知支付结果，要实现主动通知需要在请求支付系统下单时传入NotifyUrl，这里有两个url：NotifyUrl和ReturnUrl，ReturnUrl是支付完成后支付系统携带支付结果重定向到ReturnUrl地址，NotifyUrl是支付完成后支付系统在后台定时去通知，使用NotifyUrl比使用ReturnUrl有保证。

根据接口描述：https://opendocs.alipay.com/open/203/105286的内容下边在订单服务定义接收支付结果通知的接口。

首先在下单时指定NotifyUrl:

```Java
alipayRequest.setNotifyUrl("http://tjxt-user-t.itheima.net/xuecheng/orders/receivenotify");
```

接收支付结果通知接口如下：

```Java
@ApiOperation("接收支付结果通知")
@PostMapping("/receivenotify")
public void receivenotify(HttpServletRequest request,HttpServletResponse out) throws UnsupportedEncodingException, AlipayApiException {
    Map<String,String> params = new HashMap<String,String>();
    Map requestParams = request.getParameterMap();
    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) {
        String name = (String) iter.next();
        String[] values = (String[]) requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i]
                    : valueStr + values[i] + ",";
        }
        params.put(name, valueStr);
    }

    //验签
    boolean verify_result = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, "RSA2");

    if(verify_result) {//验证成功

        //商户订单号
        String out_trade_no = new String(request.getParameter("out_trade_no").getBytes("ISO-8859-1"),"UTF-8");
        //支付宝交易号
        String trade_no = new String(request.getParameter("trade_no").getBytes("ISO-8859-1"),"UTF-8");
        //交易状态
        String trade_status = new String(request.getParameter("trade_status").getBytes("ISO-8859-1"),"UTF-8");
        //appid
        String app_id = new String(request.getParameter("app_id").getBytes("ISO-8859-1"),"UTF-8");
        //total_amount
        String total_amount = new String(request.getParameter("total_amount").getBytes("ISO-8859-1"),"UTF-8");

        //交易成功处理
        if (trade_status.equals("TRADE_SUCCESS")) {
           
           //处理逻辑。。。
            
        }
    }


}
```

### 3.7.2 接口实现

完善contorller接口

```Java
@ApiOperation("接收支付结果通知")
@PostMapping("/receivenotify")
public void receivenotify(HttpServletRequest request) throws UnsupportedEncodingException, AlipayApiException {
    Map<String,String> params = new HashMap<String,String>();
    Map requestParams = request.getParameterMap();
    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) {
        String name = (String) iter.next();
        String[] values = (String[]) requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i]
                    : valueStr + values[i] + ",";
        }
        params.put(name, valueStr);
    }

    //验签
    boolean verify_result = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, "RSA2");

    if(verify_result) {//验证成功

        //商户订单号
        String out_trade_no = new String(request.getParameter("out_trade_no").getBytes("ISO-8859-1"),"UTF-8");
        //支付宝交易号
        String trade_no = new String(request.getParameter("trade_no").getBytes("ISO-8859-1"),"UTF-8");
        //交易状态
        String trade_status = new String(request.getParameter("trade_status").getBytes("ISO-8859-1"),"UTF-8");
        //appid
        String app_id = new String(request.getParameter("app_id").getBytes("ISO-8859-1"),"UTF-8");
        //total_amount
        String total_amount = new String(request.getParameter("total_amount").getBytes("ISO-8859-1"),"UTF-8");

        //交易成功处理
        if (trade_status.equals("TRADE_SUCCESS")) {

            PayStatusDto payStatusDto = new PayStatusDto();
            payStatusDto.setOut_trade_no(out_trade_no);
            payStatusDto.setTrade_status(trade_status);
            payStatusDto.setApp_id(app_id);
            payStatusDto.setTrade_no(trade_no);
            payStatusDto.setTotal_amount(total_amount);

           //处理逻辑。。。
            orderService.saveAliPayStatus(payStatusDto);
        }
    }


}
```

### 3.7.4 接口测试

测试准备：

1、启动网关服务、认证服务、验证码服务、学习中心服务、内容管理服务。

2、发布一门收费课程。

测试流程：

1、对选课进行支付

2、支付成功跟踪service方法的日志，支付成功需要更新支付交易表记录的状态、通知时间、支付宝交易号、支付渠道(Alipay)

支付成功更新订单表的状态为空。

# 12、支付通知

## 4.1 需求分析

订单服务作为通用服务在订单支付成功后需要将支付结果异步通知给其它微服务。

下图使用了消息队列完成支付结果通知：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501881.png)

学习中心服务：对收费课程选课需要支付，与订单服务对接完成支付。

学习资源服务：对收费的学习资料需要购买后下载，与订单服务对接完成支付。

订单服务完成支付后将支付结果发给每一个与订单服务对接的微服务，订单服务将消息发给交换机，由交换机广播消息，每个订阅消息的微服务都可以接收到支付结果.

微服务收到支付结果根据订单的类型去更新自己的业务数据。

## 4.2 技术方案

使用消息队列进行异步通知需要保证消息的可靠性，即生产端将消息成功通知到消费端。

消息从生产端发送到消费端经历了如下过程：

1、消息发送到交换机

2、消息由交换机发送到队列

3、消息者收到消息进行处理

保证消息的可靠性需要保证以上过程的可靠性，本项目使用RabbitMQ可以通过如下方面保证消息的可靠性。

1、生产者确认机制

发送消息前使用数据库事务将消息保证到数据库表中

成功发送到交换机将消息从数据库中删除

2、mq持久化

mq收到消息进行持久化，当mq重启即使消息没有消费完也不会丢失。

需要配置交换机持久化、队列持久化、发送消息时设置持久化。

3、消费者确认机制

消费者消费成功自动发送ack，否则重试消费。

## 4.3 发送支付结果

### 4.3.1 订单服务集成MQ

订单服务通过消息队列将支付结果发给学习中心服务，消息队列采用发布订阅模式。

1、订单服务创建支付结果通知交换机。

2、学习中心服务绑定队列到交换机。

项目使用RabbitMQ作为消息队列，在课前下发的虚拟上已经安装了RabbitMQ.

执行docker start rabbitmq 启动RabbitMQ。访问：http://192.168.101.65:15672/  

账户密码：guest/guest

交换机为Fanout广播模式。

首先需要在学习中心服务和订单服务工程配置连接消息队列。

1、首先在订单服务添加消息队列依赖

```XML
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

2、在nacos配置rabbitmq-dev.yaml为通用配置文件

```YAML
spring:
  rabbitmq:
    host: 192.168.101.65
    port: 5672
    username: guest
    password: guest
    virtual-host: /
    publisher-confirm-type: correlated #correlated 异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback
    publisher-returns: true #开启publish-return功能，同样是基于callback机制，需要定义ReturnCallback
    template:
      mandatory: true #定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息
    listener:
      simple:
        prefetch: 1  #每次只能获取一条消息，处理完成才能获取下一个消息
        acknowledge-mode: auto #auto:出现异常时返回unack，消息回滚到mq；没有异常，返回ack ,manual:手动控制,none:丢弃消息，不回滚到mq
        retry:
          enabled: false #开启消费者失败重试
          initial-interval: 5000ms #初识的失败等待时长为1秒
          multiplier: 1 #失败的等待时长倍数，下次等待时长 = multiplier * last-interval
          max-attempts: 3 #最大重试次数
          stateless: true #true无状态；false有状态。如果业务中包含事务，这里改为false
  
```

3、在订单服务接口工程引入rabbitmq-dev.yaml配置文件

```YAML
shared-configs:
  - data-id: rabbitmq-${spring.profiles.active}.yaml
    group: xuecheng-plus-common
    refresh: true
```

4、拷贝资料中MQ配置类到订单服务的service工程。

```Java
package com.xuecheng.orders.config;

import com.alibaba.fastjson.JSON;
import com.xuecheng.messagesdk.model.po.MqMessage;
import com.xuecheng.messagesdk.service.MqMessageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2023/2/23 16:59
 */
@Slf4j
@Configuration
public class PayNotifyConfig implements ApplicationContextAware {

    //交换机
    public static final String PAYNOTIFY_EXCHANGE_FANOUT = "paynotify_exchange_fanout";
    //支付结果通知消息类型
    public static final String MESSAGE_TYPE = "payresult_notify";
    //支付通知队列
    public static final String PAYNOTIFY_QUEUE = "paynotify_queue";

    //声明交换机，且持久化
    @Bean(PAYNOTIFY_EXCHANGE_FANOUT)
    public FanoutExchange paynotify_exchange_fanout() {
        // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除
        return new FanoutExchange(PAYNOTIFY_EXCHANGE_FANOUT, true, false);
    }
    //支付通知队列,且持久化
    @Bean(PAYNOTIFY_QUEUE)
    public Queue course_publish_queue() {
        return QueueBuilder.durable(PAYNOTIFY_QUEUE).build();
    }

    //交换机和支付通知队列绑定
    @Bean
    public Binding binding_course_publish_queue(@Qualifier(PAYNOTIFY_QUEUE) Queue queue, @Qualifier(PAYNOTIFY_EXCHANGE_FANOUT) FanoutExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        // 获取RabbitTemplate
        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);
        //消息处理service
        MqMessageService mqMessageService = applicationContext.getBean(MqMessageService.class);
        // 设置ReturnCallback
        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
            // 投递失败，记录日志
            log.info("消息发送失败，应答码{}，原因{}，交换机{}，路由键{},消息{}",
                    replyCode, replyText, exchange, routingKey, message.toString());
            MqMessage mqMessage = JSON.parseObject(message.toString(), MqMessage.class);
            //将消息再添加到消息表
            mqMessageService.addMessage(mqMessage.getMessageType(),mqMessage.getBusinessKey1(),mqMessage.getBusinessKey2(),mqMessage.getBusinessKey3());

        });
    }
}
```

重启订单服务，登录rabbitmq，查看交换机自动创建成功

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZiY2NhMjI3YjlkM2UwN2I2YTQxYmVmN2JiYzU1MGZfUmFVOHpHOEExeEtYcWhmYWNxWTB5SG5OVFY0bXh2alJfVG9rZW46TGhwdWJGTU9Nb3hTcFV4WGZOemN1TnpubnFjXzE3MzIzNDUyODA6MTczMjM0ODg4MF9WNA)

查看队列自动成功

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231501908.png)

### 4.3.2 发送支付结果

在OrderService中定义接口

```Java
/**
 * 发送通知结果
 * @param message
 */
public void notifyPayResult(MqMessage message);
```

编写接口实现方法：

```Java
@Override
public void notifyPayResult(MqMessage message) {

    //1、消息体，转json
    String msg = JSON.toJSONString(message);
    //设置消息持久化
    Message msgObj = MessageBuilder.withBody(msg.getBytes(StandardCharsets.UTF_8))
            .setDeliveryMode(MessageDeliveryMode.PERSISTENT)
            .build();
    // 2.全局唯一的消息ID，需要封装到CorrelationData中
    CorrelationData correlationData = new CorrelationData(message.getId().toString());
    // 3.添加callback
    correlationData.getFuture().addCallback(
            result -> {
                if(result.isAck()){
                    // 3.1.ack，消息成功
                    log.debug("通知支付结果消息发送成功, ID:{}", correlationData.getId());
                    //删除消息表中的记录
                    mqMessageService.completed(message.getId());
                }else{
                    // 3.2.nack，消息失败
                    log.error("通知支付结果消息发送失败, ID:{}, 原因{}",correlationData.getId(), result.getReason());
                }
            },
            ex -> log.error("消息发送异常, ID:{}, 原因{}",correlationData.getId(),ex.getMessage())
    );
    // 发送消息
    rabbitTemplate.convertAndSend(PayNotifyConfig.PAYNOTIFY_EXCHANGE_FANOUT, "", msgObj,correlationData);

}
```

订单服务收到第三方平台的支付结果时，在saveAliPayStatus方法中添加代码，向数据库消息表添加消息并进行发送消息，如下所示：

```Java
@Transactional
@Override
public void saveAliPayStatus(PayStatusDto payStatusDto) {
        .......
        //保存消息记录,参数1：支付结果通知类型，2: 业务id，3:业务类型
        MqMessage mqMessage = mqMessageService.addMessage("payresult_notify", orders.getOutBusinessId(), orders.getOrderType(), null);
        //通知消息
        notifyPayResult(mqMessage);
    }
}
```

## 4.4 接收支付结果

### 4.4.1 学习中心服务集成MQ

1、在学习中心服务添加消息队列依赖

```XML
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

2、在学习中心服务接口工程引入rabbitmq-dev.yaml配置文件

```YAML
shared-configs:
  - data-id: rabbitmq-${spring.profiles.active}.yaml
    group: xuecheng-plus-common
    refresh: true
```

3、添加配置类

```Java
package com.xuecheng.learning.config;

import com.alibaba.fastjson.JSON;
import com.xuecheng.messagesdk.model.po.MqMessage;
import com.xuecheng.messagesdk.service.MqMessageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2023/2/23 16:59
 */
@Slf4j
@Configuration
public class PayNotifyConfig {

    //交换机
    public static final String PAYNOTIFY_EXCHANGE_FANOUT = "paynotify_exchange_fanout";
    //支付结果通知消息类型
    public static final String MESSAGE_TYPE = "payresult_notify";
    //支付通知队列
    public static final String PAYNOTIFY_QUEUE = "paynotify_queue";

    //声明交换机，且持久化
    @Bean(PAYNOTIFY_EXCHANGE_FANOUT)
    public FanoutExchange paynotify_exchange_fanout() {
        // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除
        return new FanoutExchange(PAYNOTIFY_EXCHANGE_FANOUT, true, false);
    }
    //支付通知队列,且持久化
    @Bean(PAYNOTIFY_QUEUE)
    public Queue course_publish_queue() {
        return QueueBuilder.durable(PAYNOTIFY_QUEUE).build();
    }

    //交换机和支付通知队列绑定
    @Bean
    public Binding binding_course_publish_queue(@Qualifier(PAYNOTIFY_QUEUE) Queue queue, @Qualifier(PAYNOTIFY_EXCHANGE_FANOUT) FanoutExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange);
    }

}
```

### 4.4.2 接收支付结果

监听MQ，接收支付结果，定义ReceivePayNotifyService类如下：

```Java
package com.xuecheng.learning.service.impl;

import com.alibaba.fastjson.JSON;
import com.rabbitmq.client.Channel;
import com.xuecheng.base.exception.XueChengPlusException;
import com.xuecheng.learning.config.PayNotifyConfig;
import com.xuecheng.learning.service.MyCourseTablesService;
import com.xuecheng.messagesdk.model.po.MqMessage;
import com.xuecheng.messagesdk.service.MqMessageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;

/**
 * @author Mr.M
 * @version 1.0
 * @description 接收支付结果
 * @date 2023/2/23 19:04
 */
@Slf4j
@Service
public class ReceivePayNotifyService {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    MqMessageService mqMessageService;

    @Autowired
    MyCourseTablesService myCourseTablesService;


    //监听消息队列接收支付结果通知
    @RabbitListener(queues = PayNotifyConfig.PAYNOTIFY_QUEUE)
    public void receive(Message message, Channel channel) {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        //获取消息
        MqMessage mqMessage = JSON.parseObject(message.getBody(), MqMessage.class);
        log.debug("学习中心服务接收支付结果:{}", mqMessage);

        //消息类型
        String messageType = mqMessage.getMessageType();
        //订单类型,60201表示购买课程
        String businessKey2 = mqMessage.getBusinessKey2();
        //这里只处理支付结果通知
        if (PayNotifyConfig.MESSAGE_TYPE.equals(messageType) && "60201".equals(businessKey2)) {
            //选课记录id
            String choosecourseId = mqMessage.getBusinessKey1();
            //添加选课
            boolean b = myCourseTablesService.saveChooseCourseSuccess(choosecourseId);
            if(!b){
                //添加选课失败，抛出异常，消息重回队列
                XueChengPlusException.cast("收到支付结果，添加选课失败");
            }
        }


    }


}
```

在MyCourseTablesService中定义保存选课成功的接口：

```Java
public boolean saveChooseCourseSuccess(String chooseCourseId);
```

编写接口实现方法：

```Java
@Transactional
@Override
public boolean saveChooseCourseSuccess(String chooseCourseId) {

    //根据choosecourseId查询选课记录
    XcChooseCourse xcChooseCourse = chooseCourseMapper.selectById(chooseCourseId);
    if(xcChooseCourse == null){
        log.debug("收到支付结果通知没有查询到关联的选课记录,choosecourseId:{}",chooseCourseId);
        return false;
    }
    String status = xcChooseCourse.getStatus();
    if("701001".equals(status)){
        //添加到课程表
        addCourseTabls(xcChooseCourse);
        return true;
    }
    //待支付状态才处理
    if ("701002".equals(status)) {
        //更新为选课成功
        xcChooseCourse.setStatus("701001");
        int update = chooseCourseMapper.updateById(xcChooseCourse);
        if(update>0){
            log.debug("收到支付结果通知处理成功,选课记录:{}",xcChooseCourse);
            //添加到课程表
            addCourseTabls(xcChooseCourse);
            return true;
        }else{
            log.debug("收到支付结果通知处理失败,选课记录:{}",xcChooseCourse);
            return false;
        }
    }

    return false;
}
```

## 4.5 通知支付结果测试

测试准备：

1、找一门已发布的收费课程。

2、如果在我的课程表存储则删除。

3、删除此课程的选课记录及订单信息。

测试流程：

1、进入课程详细页面，点击马上学习，生成二维码进行支付。

2、支付完成点击“支付完成”，观察订单服务控制台是否发送消息。

3、观察学习中心服务控制台是否接收到消息。

4、观察数据库中的消息表的相应记录是否已删除。

消费重试测试：

1、在学习中心服务接收支付结果方法中制造异常。

2、重新执行上边的测试流程，观察是否消费重试。









# 13、压力测试

## 2.1 性能指标

对接口进行优化之前需要对接口进行压力测试，不仅接口需要压力测试，整个微服务在发布前也是需要经历压力测试的，因为压力测试可以暴露功能测试所发现不了的问题。

功能测试即是对系统的功能按用户需求进行测试，比如：添加一门课程，根据需求文档先准备测试数据，再通过前端界面将一门课程添加到系统，测试是否可以操作成功。整个过程就是测试软件是否可以实现用户的需求。

压力测试是通过测试工具制造大规模的并发请求去访问系统，测试系统是否经受住压力。

比如：一个在线学习网站，上线要求该网站可以支持1万用户同时在线，此时就需要模拟1万并发请求去访问网站的关键业务流程，比如：测试点播学习流程，测试系统是否可以抗住1万并发请求。

一些功能测试时无法发现的问题在压力测试时就会发现，比如：内存泄露、线程安全、IO异常等问题。

压力测试常用的性能指标如下：

1、吞吐量

吞吐量是系统每秒可以处理的事务数，也称为TPS（Transaction Per Second）。

比如：一次点播流程，从请求进入系统到视频画图显示出来这整个流程就是一次事务。

所以吞吐量并不是一次数据库事务，它是完成一次业务的整体流程。

2、响应时间

响应时间是指客户端请求服务端，从请求进入系统到客户端拿到响应结果所经历的时间。响应时间包括：最大响应时间、最小响应时间、平均响应时间。

3、每秒查询数

每秒查询数即QPS（Queries-per-second），它是衡量查询接口的性能指标，比如：商品信息查询， 一秒可以请求该接口查询商品信息的次数就是QPS。

拿查询接口举例，一次查询请求内部不会再去请求其它接口，此时  QPS=TPS

如果一次查询请求内容需要远程调用另一个接口查询数据，此时 QPS=2 * TPS

4、错误率

错误率 是一批请求发生错误的请求占全部请求的比例。

不同的指标其要求不同，比如现在进行接口优化，优化后的接口响应时间应该越来越小，吞吐量越来越大，以及QPS值也是越大越好，错误率要保持在一个很小的范围。

另外除了关注这些性能指标以外还要关注系统的负载情况：

1、CPU使用率，不高于85%

2、内存利用率，不高于 85%

3、网络利用率，不高于 80%

4、磁盘IO

磁盘IO的性能指标是IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)。

如果过大说明IO操作密集，IO过大也会影响性能指标。

## 2.2 安装Jmeter

Apache JMeter 是 Apache 组织基于 Java 开发的压力测试工具，用于对软件做压力测试。

下载Jmeter

https://jmeter.apache.org/download_jmeter.cgi

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZjYzljM2RhZGZkYmIyZTlhMDQ1MTUzOWY0OTJhNTZfU1ZBck5Wb2F4andKQnVrWDJGV0d6eTd0VlhhOURNNzlfVG9rZW46TE15a2JKcjVNb2tMYmt4YlFNNGNKWFMxbmVlXzE3MzIzNDUzNzI6MTczMjM0ODk3Ml9WNA)

下载，解压，进入bin目录修改jmeter.properties，设置中文和字体

```Java
language=zh_CN
jmeter.hidpi.mode=true
jmeter.hidpi.scale.factor=1.8
jsyntaxtextarea.font.family= Hack
jsyntaxtextarea.font.size=25
jmeter.toolbar.icons.size=32x32
jmeter.tree.icons.size=24x24
```

双击运行bin目录下的jmeter.bat文件。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231502007.png)

界面如下图：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MWIxNjViNzNjMzI0MGE5NmVjNGIyNzAzYjhiZTEzMDFfQmhvczd2QUoxUjlBcDJLamx0bTNvdk56SmR6QXhuZjhfVG9rZW46RWhhRWJoSW93b0oydmt4Q2hHQ2NJYXRVbjNjXzE3MzIzNDUzNzI6MTczMjM0ODk3Ml9WNA)

## 2.3 压力测试

样本数：200个线程，每个线程请求100次，共20000次

压力机：通常压力机是单独的客户端。

测试gateway+content

吞吐量180左右

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjYwY2ZjZDEyOTdjZGRlZDZhY2Y2ZWU0YmU4NjBjMjFfU09KQzNoM1Q0ejZGdWlFbjBZQlBHd2M1V0N5NEVyTm1fVG9rZW46RG1wQWJ1MjFsb1FITnh4bk9BbWN5UmFybkJRXzE3MzIzNDUzNzI6MTczMjM0ODk3Ml9WNA)

测试content

吞吐量300左右

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTA1NjVhN2I3OTRjNWVjMDZlM2MzYjg4MjQ0YzEwOThfbEpWZVAyd3NpaUtDYVZsbE1OZ0xLVDM5eEtSam9yMUdfVG9rZW46RjBpR2I0NDZGbzVLaFh4TjJSUGNlRW5JblB0XzE3MzIzNDUzNzI6MTczMjM0ODk3Ml9WNA)

## 2.4 优化日志

内容管理日志级别改为info级别.

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJjZmU0OGZjNzlmM2NjNTVkZjY5YTA0N2MwYTNlNjhfMXdLMVQxTzRlTlIyRHk2SnJmTWhTYXR4WWx1cXptWFVfVG9rZW46SFFzOGJpTGtkb3drNWV4SDVmY2NyNXdNbmVjXzE3MzIzNDUzNzI6MTczMjM0ODk3Ml9WNA)

单独请求内容管理测试，吞吐量达到1500左右

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY5YWQwNjA4YTQ2YWFkZjkzYWI2YWZiZTY0ZDBiM2FfbUM2cThUejNlVThMbjc1aXBPRFJlZEF3ZkF2SWtmUlVfVG9rZW46RzZHc2J5aEpRb0pYT2J4NEh2dWNEbDI2bnJoXzE3MzIzNDUzNzI6MTczMjM0ODk3Ml9WNA)

# 14、缓存优化

## 3.1 redis缓存

测试用例是根据id查询课程信息，这里不存在复杂的SQL，也不存在数据库连接不释放的问题，暂时不考虑数据库方面的优化。

课程发布信息的特点的是查询较多，修改很少，这里考虑将课程发布信息进行缓存。

课程信息缓存的流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503758.png)

在nacos配置redis-dev.yaml（group=xuecheng-plus-common）

```Java
spring: 
  redis:
    host: 192.168.101.65
    port: 6379
    password: redis
    database: 0
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 0
    timeout: 10000
```

在content-api微服务加载redis-dev.yaml

```Java
shared-configs:
    - data-id: redis-${spring.profiles.active}.yaml
      group: xuecheng-plus-common
      refresh: true
```

在content-service微服务中添加依赖

```Java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
    <version>2.6.2</version>
</dependency>
```

定义查询缓存接口：

```Java
/**
 * @description 查询缓存中的课程信息
 * @param courseId 
 * @return com.xuecheng.content.model.po.CoursePublish
 * @author Mr.M
 * @date 2022/10/22 16:15
*/
public CoursePublish getCoursePublishCache(Long courseId);
```

接口实现如下：

```Java
public CoursePublish getCoursePublishCache(Long courseId){
    //查询缓存
   Object  jsonObj = redisTemplate.opsForValue().get("course:" + courseId);
    if(jsonObj!=null){
    String jsonString = jsonObj.toString();
        System.out.println("=================从缓存查=================");
        CoursePublish coursePublish = JSON.parseObject(jsonString, CoursePublish.class);
        return coursePublish;
    } else {
        System.out.println("从数据库查询...");
        //从数据库查询
        CoursePublish coursePublish = getCoursePublish(courseId);
        if(coursePublish!=null){
            redisTemplate.opsForValue().set("course:" + courseId, JSON.toJSONString(coursePublish));
        }
        return coursePublish;
    }
}
}
```

修改controller接口调用代码

```Java
@ApiOperation("获取课程发布信息")
    @ResponseBody
    @GetMapping("/course/whole/{courseId}")
    public CoursePreviewDto getCoursePublish(@PathVariable("courseId") Long courseId) {
        //查询课程发布信息
        CoursePublish coursePublish = coursePublishService.getCoursePublishCache(courseId);
//        CoursePublish coursePublish = coursePublishService.getCoursePublish(courseId);
        if(coursePublish==null){
            return new CoursePreviewDto();
        }

        //课程基本信息
        CourseBaseInfoDto courseBase = new CourseBaseInfoDto();
        BeanUtils.copyProperties(coursePublish, courseBase);
        //课程计划
        List<TeachplanDto> teachplans = JSON.parseArray(coursePublish.getTeachplan(), TeachplanDto.class);
        CoursePreviewDto coursePreviewInfo = new CoursePreviewDto();
        coursePreviewInfo.setCourseBase(courseBase);
        coursePreviewInfo.setTeachplans(teachplans);
        return coursePreviewInfo;
    }
```

重新测试请求内容管理服务课程查询接口。

吞吐量达到2700左右，增加了近一倍。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=N2RmNzQ4NjNhYzBjNzMwNmJiMTdmMDVjZjdiMTRhN2NfT0tLYmxIaVRpUkI2dW1GNWdpd0JOaHBySlE4RWlWOGJfVG9rZW46RXlUWmI5VVN3b09nYTF4RXdYbWNHVXE0bjViXzE3MzIzNDUzNzM6MTczMjM0ODk3M19WNA)

## 3.2 缓存穿透问题

### 3.2.1 什么是缓存穿透

使用缓存后代码的性能有了很大的提高，虽然性能有很大的提升但是控制台打出了很多“从数据库查询”的日志，明明判断了如果缓存存在课程信息则从缓存查询，为什么要有这么多从数据库查询的请求的？

这是因为并发数高，很多线程会同时到达查询数据库代码处去执行。

我们分析下代码：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503231.png)

如果存在恶意攻击的可能，如果有大量并发去查询一个不存在的课程信息会出现什么问题呢？

比如去请求/content/course/whole/181，查询181号课程，该课程并不在课程发布表中。

进行压力测试发现会去请求数据库。

大量并发去访问一个数据库不存在的数据，由于缓存中没有该数据导致大量并发查询数据库，这个现象要缓存穿透。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503698.png)

缓存穿透可以造成数据库瞬间压力过大，连接数等资源用完，最终数据库拒绝连接不可用。

### 3.2.2 解决缓存穿透

如何解决缓存穿透?

1、对请求增加校验机制

比如：课程Id是长整型，如果发来的不是长整型则直接返回。

2、使用布隆过滤器

什么是布隆过滤器，以下摘自百度百科：

布隆过滤器可以用于检索一个元素是否在一个集合中。如果想要判断一个元素是不是在一个集合里，一般想到的是将所有元素保存起来，然后通过比较确定。[链表](https://baike.baidu.com/item/链表/9794473?fromModule=lemma_inlink)，树等等数据结构都是这种思路. 但是随着集合中元素的增加，我们需要的存储空间越来越大，[检索速度](https://baike.baidu.com/item/检索速度/20807841?fromModule=lemma_inlink)也越来越慢(O(n),O(logn))。不过世界上还有一种叫作散列表（又叫[哈希表](https://baike.baidu.com/item/哈希表/5981869?fromModule=lemma_inlink)，Hash table）的数据结构。它可以通过一个Hash函数将一个元素映射成一个位阵列（Bit array）中的一个点。这样一来，我们只要看看这个点是不是1就可以知道集合中有没有它了。这就是布隆过滤器的基本思想。

布隆过滤器的特点是，高效地插入和查询，占用空间少；查询结果有不确定性，如果查询结果是存在则元素不一定存在，如果不存在则一定不存在；另外它只能添加元素不能删除元素，因为删除元素会增加误判率。

比如：将商品id写入布隆过滤器，如果分3次hash此时在布隆过滤器有3个点，当从布隆过滤器查询该商品id，通过hash找到了该商品id在过滤器中的点，此时返回1，如果找不到一定会返回0。

所以，为了避免缓存穿透我们需要缓存预热将要查询的课程或商品信息的id提前存入布隆过滤器，添加数据时将信息的id也存入过滤器，当去查询一个数据时先在布隆过滤器中找一下如果没有到到就说明不存在，此时直接返回。

实现方法有：

Google工具包Guava实现。

redisson 。

2、缓存空值或特殊值

请求通过了第一步的校验，查询数据库得到的数据不存在，此时我们仍然去缓存数据，缓存一个空值或一个特殊值的数据。

但是要注意：如果缓存了空值或特殊值要设置一个短暂的过期时间。

```Java
public CoursePublish getCoursePublishCache(Long courseId) {

    //查询缓存
   Object  jsonObj = redisTemplate.opsForValue().get("course:" + courseId);
    if(jsonObj!=null){
    String jsonString = jsonObj.toString();
        if(jsonString.equals("null"))
            return null;
        CoursePublish coursePublish = JSON.parseObject(jsonString, CoursePublish.class);
        return coursePublish;
    } else {
        //从数据库查询
        System.out.println("从数据库查询数据...");
        CoursePublish coursePublish = getCoursePublish(courseId);
        //设置过期时间300秒
        redisTemplate.opsForValue().set("course:" + courseId, JSON.toJSONString(coursePublish),30, TimeUnit.SECONDS);
        return coursePublish;
    }
}
```

再测试，虽然还存在个别请求去查询数据库，但不是所有请求都去查询数据库，基本上都命中缓存。

## 3.3 缓存雪崩

### 3.3.1 什么是缓存雪崩

缓存雪崩是缓存中大量key失效后当高并发到来时导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用。

造成缓存雪崩问题的原因是是大量key拥有了相同的过期时间，比如对课程信息设置缓存过期时间为10分钟，在大量请求同时查询大量的课程信息时，此时就会有大量的课程存在相同的过期时间，一旦失效将同时失效，造成雪崩问题。

### 3.3.2 解决缓存雪崩

如何解决缓存雪崩？

1、使用同步锁控制查询数据库的线程

使用同步锁控制查询数据库的线程，只允许有一个线程去查询数据库，查询得到数据后存入缓存。

```Java
synchronized(obj){
  //查询数据库
  //存入缓存
}
```

2、对同一类型信息的key设置不同的过期时间

通常对一类信息的key设置的过期时间是相同的，这里可以在原有固定时间的基础上加上一个随机时间使它们的过期时间都不相同。

示例代码如下：

```Java
   //设置过期时间300秒
  redisTemplate.opsForValue().set("course:" + courseId, JSON.toJSONString(coursePublish),300+new Random().nextInt(100), TimeUnit.SECONDS);
```

3、缓存预热

不用等到请求到来再去查询数据库存入缓存，可以提前将数据存入缓存。使用缓存预热机制通常有专门的后台程序去将数据库的数据同步到缓存。

## 3.4 缓存击穿

### 3.4.1 什么是缓存击穿

缓存击穿是指大量并发访问同一个热点数据，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。

比如某手机新品发布，当缓存失效时有大量并发到来导致同时去访问数据库。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503191.png)

### 3.4.2 解决缓存击穿

如何解决缓存击穿？

1、使用同步锁控制查询数据库的线程

使用同步锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到数据库存入缓存。

```Java
synchronized(obj){
  //查询数据库
  //存入缓存
}
```

2、热点数据不过期

可以由后台程序提前将热点数据加入缓存，缓存过期时间不过期，由后台程序做好缓存同步。

下边使用synchronized对代码加锁。

```Java
public  CoursePublish getCoursePublishCache(Long courseId){
    synchronized(this){
        //查询缓存
        String jsonString = (String) redisTemplate.opsForValue().get("course:" + courseId);
        if(StringUtils.isNotEmpty(jsonString)){
            if(jsonString.equals("null"))
                return null;
            CoursePublish coursePublish = JSON.parseObject(jsonString, CoursePublish.class);
            return coursePublish;
        }else{
            System.out.println("=========从数据库查询==========");
            //从数据库查询
            CoursePublish coursePublish = getCoursePublish(courseId);
           //设置过期时间300秒
        redisTemplate.opsForValue().set("course:" + courseId, JSON.toJSONString(coursePublish),300, TimeUnit.SECONDS);
            return coursePublish;
        }
    }

}
```

测试，吞吐量有1300左右

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OWNhOWNkOTUzMmJhNzc5ZDJhNTNkYzkxZWNkODFmMjlfOTg3WVo1dDBvSUlDQWI0V2x4TUpGZzNSWm1JbU03cjBfVG9rZW46VWpsVmJycEhFb1VvVUR4UU1KOGNuVGlTbmJiXzE3MzIzNDUzNzM6MTczMjM0ODk3M19WNA)

对上边的代码进行优化，对查询缓存的代码不用synchronized加锁控制，只对查询数据库进行加锁，如下：

```Java
public  CoursePublish getCoursePublishCache(Long courseId){

        //查询缓存
         Object  jsonObj = redisTemplate.opsForValue().get("course:" + courseId);
         if(jsonObj!=null){
            String jsonString = jsonObj.toString();
            CoursePublish coursePublish = JSON.parseObject(jsonString, CoursePublish.class);
            return coursePublish;
        }else{
            synchronized(this){
                Object  jsonObj = redisTemplate.opsForValue().get("course:" + courseId);
                if(jsonObj!=null){
                   String jsonString = jsonObj.toString();
                    CoursePublish coursePublish = JSON.parseObject(jsonString, CoursePublish.class);
                    return coursePublish;
                }
                 System.out.println("=========从数据库查询==========");
                //从数据库查询
                CoursePublish coursePublish = getCoursePublish(courseId);
              //设置过期时间300秒
                redisTemplate.opsForValue().set("course:" + courseId, JSON.toJSONString(coursePublish),300, TimeUnit.SECONDS);
                return coursePublish;
            }
        }


}
```

测试，查询数据库只发生一次，整个测试过程的吞吐量在3800左右。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTIyNzc0NjIyMGFiYTRkMjc4Y2Q3ZmM1ZDlkZTYyN2JfWlRiNUFNbkJCNmJVQmM2ZDRvZlFFWUVOZUNxSERwSXJfVG9rZW46R2VYcWJNeHZhb3JMZTJ4dk8wQmNGbTJQbnFiXzE3MzIzNDUzNzM6MTczMjM0ODk3M19WNA)

### 3.4.3 小结

1）缓存穿透：

去访问一个数据库不存在的数据无法将数据进行缓存，导致查询数据库，当并发较大就会对数据库造成压力。缓存穿透可以造成数据库瞬间压力过大，连接数等资源用完，最终数据库拒绝连接不可用。

解决的方法：

缓存一个null值。

使用布隆过滤器。

2）缓存雪崩：

缓存中大量key失效后当高并发到来时导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用。

造成缓存雪崩问题的原因是是大量key拥有了相同的过期时间。

解决办法：

使用同步锁控制

对同一类型信息的key设置不同的过期时间，比如：使用固定数+随机数作为过期时间。

3）缓存击穿

大量并发访问同一个热点数据，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。

解决办法：

使用同步锁控制

设置key永不过期

无中生有是穿透，布隆过滤null隔离。 缓存击穿key过期， 锁与非期解难题。 大量过期成雪崩，过期时间要随机。 面试必考三兄弟，可用限流来保底。

限流技术方案：

alibaba/Sentinel 

nginx+Lua

## 3.5 分布式锁

### 3.5.1 本地锁的问题

上边的程序使用了同步锁解决了缓存击穿、缓存雪崩的问题，保证同一个key过期后只会查询一次数据库。

如果将同步锁的程序分布式部署在多个虚拟机上则无法保证同一个key只会查询一次数据库，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503583.png)

一个同步锁程序只能保证同一个虚拟机中多个线程只有一个线程去数据库，如果高并发通过网关负载均衡转发给各个虚拟机，此时就会存在多个线程去查询数据库情况，因为虚拟机中的锁只能保证该虚拟机自己的线程去同步执行，无法跨虚拟机保证同步执行。

我们将虚拟机内部的锁叫本地锁，本地锁只能保证所在虚拟机的线程同步执行。

下边进行测试：

启动三个内容管理服务：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YWRiNGM2MTI0ZDhkNDQ0YTc3Y2FhZDY0NTk1NTIzNDNfeWxXU29EMk1HOXFKaVlpZXMydkNzNTNxOVhnMHJ2VGtfVG9rZW46VzVMSmIxZFFib2s3WXB4OENkQWMwbWkzbnJlXzE3MzIzNDUzNzM6MTczMjM0ODk3M19WNA)

通过网关访问课程查询，网关通过负载均衡将请求转发给三个服务。

通过测试发现，有两个服务各有一次数据库查询，这说明本地锁无法跨虚拟机保证同步执行。

### 3.5.2 什么是分布锁

本地锁只能控制所在虚拟机中的线程同步执行，现在要实现分布式环境下所有虚拟机中的线程去同步执行就需要让多个虚拟机去共用一个锁，虚拟机可以分布式部署，锁也可以分布式部署，如下图：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503954.png)

虚拟机都去抢占同一个锁，锁是一个单独的程序提供加锁、解锁服务，谁抢到锁谁去查询数据库。

该锁已不属于某个虚拟机，而是分布式部署，由多个虚拟机所共享，这种锁叫分布式锁。

### 3.5.3 分布式锁的实现方案

实现分布式锁的方案有很多，常用的如下：

1、基于数据库实现分布锁

利用数据库主键唯一性的特点，或利用数据库唯一索引的特点，多个线程同时去插入相同的记录，谁插入成功谁就抢到锁。

2、基于redis实现锁

redis提供了分布式锁的实现方案，比如：SETNX、set nx、redisson等。

拿SETNX举例说明，SETNX命令的工作过程是去set一个不存在的key，多个线程去设置同一个key只会有一个线程设置成功，设置成功的的线程拿到锁。

3、使用zookeeper实现

zookeeper是一个分布式协调服务，主要解决分布式程序之间的同步的问题。zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁。

### 3.5.4 Redis NX实现分布式锁

redis实现分布式锁的方案可以在redis.cn网站查阅，地址http://www.redis.cn/commands/set.html

使用命令： `SET resource-name anystring NX EX max-lock-time` 即可实现。

NX：表示key不存在才设置成功。

EX：设置过期时间

这里启动三个ssh客户端，连接redis: docker exec -it redis redis-cli

先认证: auth redis

同时向三个客户端发送测试命令如下：

表示设置lock001锁，value为001，过期时间为30秒

```Plain
SET lock001 001 NX EX 30
```

命令发送成功，观察三个ssh客户端发现只有一个设置成功，其它两个设置失败，设置成功的请求表示抢到了lock001锁。

如何在代码中使用Set nx去实现分布锁呢？

使用spring-boot-starter-data-redis 提供的api即可实现set nx。

添加依赖：

```Java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
    <version>2.6.2</version>
</dependency>
```

添加依赖后，在bean中注入restTemplate。

我们先分析一段伪代码如下：

```Java
if(缓存中有){

  返回缓存中的数据
}else{

  获取分布式锁
  if(获取锁成功）{
       try{
         查询数据库
      }finally{
         释放锁
      }
  }
 
}
```

1、获取分布式锁

使用redisTemplate.opsForValue().setIfAbsent(key,vaue)获取锁

这里考虑一个问题，当set nx一个key/value成功1后，这个key(就是锁)需要设置过期时间吗？

如果不设置过期时间当获取到了锁却没有执行finally这个锁将会一直存在，其它线程无法获取这个锁。

所以执行set nx时要指定过期时间，即使用如下的命令

```
SET resource-name anystring NX EX max-lock-time
```

具体调用的方法是：redisTemplate.opsForValue().setIfAbsent(K var1, V var2, long var3, TimeUnit var5)

2、如何释放锁

释放锁分为两种情况：key到期自动释放，手动删除。

1）key到期自动释放的方法

因为锁设置了过期时间，key到期会自动释放，但是会存在一个问题就是 查询数据库等操作还没有执行完时key到期了，此时其它线程就抢到锁了，最终重复查询数据库执行了重复的业务操作。

怎么解决这个问题？

可以将key的到期时间设置的长一些，足以执行完成查询数据库并设置缓存等相关操作。

如果这样效率会低一些，另外这个时间值也不好把控。

2）手动删除锁

如果是采用手动删除锁可能和key到期自动删除有所冲突，造成删除了别人的锁。

比如：当查询数据库等业务还没有执行完时key过期了，此时其它线程占用了锁，当上一个线程执行查询数据库等业务操作完成后手动删除锁就把其它线程的锁给删除了。

要解决这个问题可以采用删除锁之前判断是不是自己设置的锁，伪代码如下：

```JavaScript
if(缓存中有){

  返回缓存中的数据
}else{

  获取分布式锁: set lock 01 NX
  if(获取锁成功）{
       try{
         查询数据库
      }finally{
         if(redis.call("get","lock")=="01"){
            释放锁: redis.call("del","lock")
         }
         
      }
  }
 
}
```

以上代码第11行到13行非原子性，也会导致删除其它线程的锁。

查看文档上的说明：http://www.redis.cn/commands/set.html

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MGZhMzQ0ZWMwZTA2NzI2Zjc5NGQzNDUzMTRjNjQyNTVfSngwMEdoWW84cjJBZTdRS3FwdGRjMmpNb3gzRTJOc2NfVG9rZW46SUxCdmJRU25hb21oTzF4T3NqWGMyZFNsbnpjXzE3MzIzNDUzNzM6MTczMjM0ODk3M19WNA)

在调用setnx命令设置key/value时，每个线程设置不一样的value值，这样当线程去删除锁时可以先根据key查询出来判断是不是自己当时设置的vlaue，如果是则删除。

这整个操作是原子的，实现方法就是去执行上边的lua脚本。

*Lua* 是一个小巧的脚本语言，redis在2.6版本就支持通过执行Lua脚本保证多个命令的原子性。

什么是原子性？

这些指令要么全成功要么全失败。

以上就是使用Redis Nx方式实现分布式锁，为了避免删除别的线程设置的锁需要使用redis去执行Lua脚本的方式去实现，这样就具有原子性，但是过期时间的值设置不存在不精确的问题。

### 3.5.5 Redisson实现分布式锁

#### 3.5.5.1 什么是Redisson

再查阅 文档http://www.redis.cn/commands/set.html

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODcwMmJjYzNlMjMxNDI5NWQ0ZDYzYmUxZmFlMmI4ZGJfUTNPVXN0ejlySDJUZG1mcW1KUlRlWU00dHRLakpRS3NfVG9rZW46SHZPTWI3ckYzb2MxVlB4N1B0TGNPa0ZqbjRkXzE3MzIzNDUzNzM6MTczMjM0ODk3M19WNA)

点击链接查看

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503814.png)

我们选用Java的实现方案 https://github.com/redisson/redisson

Redisson的文档地址：https://github.com/redisson/redisson/wiki/Table-of-Content

Redisson底层采用的是[Netty](http://netty.io/) 框架。支持[Redis](http://redis.cn/) 2.8以上版本，支持Java1.6+以上版本。Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(`BitSet`, `Set`, `Multimap`, `SortedSet`, `Map`, `List`, `Queue`, `BlockingQueue`, `Deque`, `BlockingDeque`, `Semaphore`, `Lock`, `AtomicLong`, `CountDownLatch`, `Publish / Subscribe`, `Bloom filter`, `Remote service`, `Spring cache`, `Executor service`, `Live Object service`, `Scheduler service`) 。

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjFlZTJiMjgzODc0MGE5MTE3M2U2YTg2NDlkMTI5YjZfTUNBS1NDMFNNU2tCZTgxQVJsVHA1bWE3THJkODlHZGhfVG9rZW46Q2p1ZWJ2Q0hGb0NaSDJ4b0o4QmNCeEN6blVlXzE3MzIzNDUzNzM6MTczMjM0ODk3M19WNA)

使用Redisson可以非常方便将Java本地内存中的常用数据结构的对象搬到分布式缓存redis中。

也可以将常用的并发编程工具如：AtomicLong、CountDownLatch、Semaphore等支持分布式。

使用RScheduledExecutorService 实现分布式调度服务。

支持数据分片，将数据分片存储到不同的redis实例中。

支持分布式锁，基于Java的Lock接口实现分布式锁，方便开发。

下边使用Redisson将Queue队列的数据存入Redis，实现一个排队及出队的接口。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503065.png)

添加redisson的依赖

```Java
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.11.2</version>
</dependency>
```

从课程资料目录拷贝singleServerConfig.yaml到config工程下

在redis配置文件中添加：

```Java
spring:
  redis:
    redisson:
      #配置文件目录
      config: classpath:singleServerConfig.yaml
      #config: classpath:clusterServersConfig.yaml
```

redis集群配置clusterServersConfig.yaml.

Redisson相比set nx实现分布式锁要简单的多，工作原理如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231503781.png)

- **加锁机制**

线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。

线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis

- **WatchDog自动延期看门狗机制**

第一种情况：在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，你也可以设置锁的有效时间(当不设置默认30秒时），这样的目的主要是防止死锁的发生

 第二种情况：线程A业务还没有执行完，时间就过了，线程A 还想持有锁的话，就会启动一个watch dog后台线程，不断的延长锁key的生存时间。

- **lua脚本-保证原子性操作**

主要是如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性

具体使用RLock操作分布锁，RLock继承JDK的Lock接口，所以他有Lock接口的所有特性，比如lock、unlock、trylock等特性,同时它还有很多新特性：强制锁释放，带有效期的锁,。

```Java
public interface RRLock {
    
   //----------------------Lock接口方法-----------------------
    /**
     * 加锁 锁的有效期默认30秒
     */
    void lock();
    
     /**
     * 加锁 可以手动设置锁的有效时间
     *
     * @param leaseTime 锁有效时间
     * @param unit      时间单位 小时、分、秒、毫秒等
     */
    void lock(long leaseTime, TimeUnit unit);
    
    /**
     * tryLock()方法是有返回值的，用来尝试获取锁，
     * 如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false .
     */
    boolean tryLock();
    
    /**
     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，
     * 只不过区别在于这个方法在拿不到锁时会等待一定的时间，
     * 在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
     *
     * @param time 等待时间
     * @param unit 时间单位 小时、分、秒、毫秒等
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    
    /**
     * 比上面多一个参数，多添加一个锁的有效时间
     *
     * @param waitTime  等待时间
     * @param leaseTime 锁有效时间
     * @param unit      时间单位 小时、分、秒、毫秒等
     * waitTime 大于 leaseTime
     */
    boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException;
    
    /**
     * 解锁
     */
    void unlock();
}
```

**lock()**：

- 此方法为加锁，但是锁的有效期采用**默认30秒**
- 如果主线程未释放，且当前锁未调用unlock方法，则进入到**watchDog机制**
- 如果主线程未释放，且当前锁调用unlock方法，则直接释放锁

#### 3.5.5.3 分布式锁避免缓存击穿

下边使用分布式锁修改查询课程信息的接口。

```Java
//Redisson分布式锁
public  CoursePublish getCoursePublishCache(Long courseId){
        //查询缓存
        String jsonString = (String) redisTemplate.opsForValue().get("course:" + courseId);
        if(StringUtils.isNotEmpty(jsonString)){
            if(jsonString.equals("null")){
                return null;
            }
            CoursePublish coursePublish = JSON.parseObject(jsonString, CoursePublish.class);
            return coursePublish;
        }else{
            //每门课程设置一个锁
            RLock lock = redissonClient.getLock("coursequerylock:"+courseId);
            //获取锁
            lock.lock();
            try {
                jsonString = (String) redisTemplate.opsForValue().get("course:" + courseId);
                if(StringUtils.isNotEmpty(jsonString)){
                    CoursePublish coursePublish = JSON.parseObject(jsonString, CoursePublish.class);
                    return coursePublish;
                }
                System.out.println("=========从数据库查询==========");
                //从数据库查询
                CoursePublish coursePublish = getCoursePublish(courseId);
                redisTemplate.opsForValue().set("course:" + courseId, JSON.toJSONString(coursePublish),1,TimeUnit.DAYS);
                return coursePublish;
            }finally {
                //释放锁
                lock.unlock();
            }
        }


}
```

启动多个内容管理服务实例，使用JMeter压力测试，只有一个实例查询一次数据库。

测试Redisson自动续期功能。

在查询数据库处添加休眠，观察锁是否会自动续期。

```JavaScript
try {
    Thread.sleep(60000);
} catch (InterruptedException e) {
    throw new RuntimeException(e);
}
```







# 15、项目总结

## 1 项目概况

### 1.1 项目介绍

从以下几个方面进行项目介绍：

1、项目的背景：做什么业务、服务的客户群是谁、谁去运营、自研还是外包等问题。

2、项目的业务流程：课程发布流程、断点续传流程、视频处理流程、认证授权流程、支付流程、CI/CD流程。

3、项目的功能模块：内容管理模块、媒资管理模块、认证授权模块、选课学习模块、订单支付模块。

4、项目的技术架构：Spring Cloud 、SpringBoot、MySQL、Elasticsearch、XXL-JOB、MinIO、Redis、Redisson、RabbitMQ。

5、个人工作职责

6、个人负责模块的详细说明，包括模块的设计，所用到的技术，技术的实现方案等。

功能模块：

![img](https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NmVkMDliNzk3ZjdiZTRkODZjMGYwMmU3OTJjZGQ2ZGJfZzlUb2QwN3pBWno0VmRWSmNaV0U4akIwdTBYT0NYZDNfVG9rZW46REVRWGJBVG8xb2dNbzd4MHdvbmN3VE1LbmFkXzE3MzIzNDU4MTk6MTczMjM0OTQxOV9WNA)

### 1.2 开发周期

项目周期8个月，其中开发4个月，测试4个月；人员共有15名。

Java开发共6名：3名初级程序员，2名中级程序员，1名高级程序员（兼架构师）。

初级程序员：负责编码、单元测试。

中级程序员：模块设计、核心代码编写、部分模块编码和单元测试

高级程序员：系统架构设计，核心代码编写

产品设计人员：1名

前端工程师：2名

UI设计：1名

测试人员：3名，其中2名功能测试，1名性能测试。

配置管理员：1名，作好项目代码、项目文档等资料的备份工作，负责统一分配git账号、权限。

项目经理：1名，负责制定项目计划、项目管理。

## 2 内容管理模块

### 2.1 内容管理模块功能开发

#### 问题1：内容管理模块是怎么做的？

内容管理模块是对课程及相关信息进行维护，培训机构登录机构端，编辑课程相关的信息，包括：课程基本信息、课程营销、课程计划、课程关联的师资信息等，全部信息编写完毕提交审核，运营人员审核通过后由机构人员进行发布，课程发布后用户可以在平台上进行在线学习。

因为课程的相关信息比较多，用户编辑课程信息分为多个步骤进行，我们设计了课程基本信息表、营销表、课程师资表、课程计划表去分别存储这些信息。

课程发布时我们将课程的相关信息聚合到一张课程发布表，这里我们还需要将课程信息同步到elasticsearch、redis还有分布式文件系统中，这里存在分布式事务，我们基于本地消息表和任务调度的方式去控制分布式事务控制，实现数据的最终一致性。

#### 问题2： 课程审核的流程是什么？

机构用户编辑完课程信息后将课程提交给运营人员进行审核，课程审核包括程序自动审核和人工审核，程序会校验信息的完整性，调用鉴黄接口，人工审核是48小时内完成，审核的意见及审核结果会写入课程审核表，用户通过查询审核意见得到审核的结果。

#### 问题3：课程发布的流程是什么？

课程审核通过后由机构端用户进行课程发布，设计了课程预览功能，通过课程预览能够快速知道课程的哪些信息不全。课程发布后课程相关信息写入课程发布表，课程发布的状态为已发布，还有课程下架功能，下架的课程用户无法搜索到无法选课学习，下架课程的发布状态为下架，课程下架后可以重新发布。

#### 问题4：图片鉴黄是怎么做的？

很多的云平台都提供图片鉴黄的API，比如：阿里云、腾讯云等，提供图片的url调用API就可以了，我们项目组封装了一个sdk，调用接口得到返回值，包括：黄、不黄、人工审核。

### 2.2 使用本地消息表加任务调度完成分布式事务控制

#### 问题1：什么是分布式事务？

由多个服务通过网络完成一个事务叫分布式事务。

比如：课程发布操作不仅要在本地数据库插入课程信息，而且还要请求索引服务将课程信息添加到索引库，还要请求MinIO将课程静态化并上传静态页面，这里就存在分布式事务。

#### 问题2：分布式事务控制的方案有哪些？

首先根据CAP原理决定我们的需求，是要实现CP、还是要实现AP。

实现CP就是要实现强一致性，可以使用Seata框架基于XA、AT模式去实现。

实现AP强调可用性实现最终一致性，可以使用MQ、任务调度的方式、TCC方式去实现。

我们项目中大部分实现的是AP，使用本地消息表加任务调度完成分布式事务最终数据一致性。

#### 问题3：如何使用本地消息表加任务调度完成分布式事务控制？

以发布课程为例进行说明，发布课程需要在内容管理数据库中写课程发布表记录，同时将课程信息同步到redis、ES、MinIO，这里存在分布式事务。

1）点击发布课程使用本地事务向发布表写一个课程信息，同时向消息表写一个消息记录（标记了发布了哪门课程）

2）xxl-job的调度中心使用分片广播模式向执行器下发任务，开始扫描消息表，查询到了待处理的消息。

3）根据消息的内容将课程信息同步到Redis、ES、MinIO

4) 任务完成后删除消息表记录。整个分布式事务完成，最终保证了数据的一致性。

### 2.3 基于xxl-job实现任务调度

#### 问题1：xxl-job的工作原理是什么？xxl-job是什么怎么工作？

XXL-JOB分布式任务调度服务由调用中心和执行器组成，调用中心负责按任务调度策略向执行器下发任务，执行器负责接收任务执行任务。

1）首先部署并启动xxl-job调度中心。(一个java工程)

2）首先在微服务添加xxl-job依赖，在微服务中配置执行器

3）启动微服务，执行器向调度中心上报自己。

4）在微服务中写一个任务方法并用xxl-job的注解去标记执行任务的名称。

5) 在调度中心添加一个任务并配置调度策略，调度策略就是每隔多长时间执行还是在每天或每月的固定时间去执行，比如每天0点执行，或每隔1小时执行一次等。

6）在调度中心启动任务。

7）调度中心根据任务调度策略，到达时间就开始下发任务给执行器。

8）执行器收到任务就开始执行任务。

#### 问题2：如何保证任务不重复执行?

1) 调度中心按分片广播的方式去下发任务。

2）执行器收到作业分片广播的参数：分片总数和分片序号，计算 任务id 除以 执行器总数得到一个余数，如果余数等于执行器序号这时就去执行这个任务，这里保证了不同的执行器执行不同的任务。

3）配置调度过期策略为“忽略”，避免同一个执行器多次重复执行同一个任务

4）配置任务阻塞处理策略为“丢弃后续调度”，丢弃后在下一次调度还可以执行。

5）另外还要保证任务处理的幂等性，执行过的任务可以打一个状态标记已完成，下次再调度执行该任务判断该任务已完成就不再执行。

6）通过分布式锁彻底避免任务多次处理，我们项目使用数据库的乐观锁实现分布式锁，在执行任务前去更新任务的状态为执行中，谁更新成功谁去执行任务。

7）为了避免程序挂掉任务永远是执行器，这里使用任务补偿机制，启动一个定时任务检测在规定的时间内任务还没有完成将任务状态更新 为处理失败。

#### 问题3：任务幂等性如何保证？

幂等性是为了解决重复提交问题，比如：恶意刷单，重复支付等。

解决幂等性常用的方案：

1）数据库约束，比如：唯一索引，主键。同一个主键不可能两次都插入成功。

2）乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新。

3）唯一序列号，请求前生成唯一的序列号，携带序列号去请求，执行时在redis记录该序列号表示以该序列号的请求执行过了，如果相同的序列号再次来执行说明是重复执行。

我们项目中在处理任务时为了避免任务重复处理通过任务状态以及数据库乐观锁去保证任务幂等性。

执行过的任务可以打一个状态标记已完成，下次再调度执行该任务判断该任务已完成就不再执行。

在执行任务前使用数据库的乐观锁去更新任务的状态为执行中，谁更新成功谁去执行任务。

#### 问题4：你们项目如何使用xxl-job进行任务调度?

我们项目中在控制分布式事务时要保证最终数据一致性，是基于消息表的机制进行控制，这时就使用xxl-job去扫描消息表的记录，根据消息表内容去执行任务，最终保证了数据一致性。

具体xxl-job的使用方法参考上边问题1。

#### 问题5: 任务处理达到最大失败次数怎么办？

当任务达到最大失败次数时一般就说明程序处理此视频存在问题，这种情况就需要人工处理，在页面上会提示失败的信息，人工可手动执行该视频进行处理，或通过其它转码工具进行视频转码，转码后直接上传mp4视频。

#### 问题6: 如果任务一直没有完成怎么办？

如果有线程抢占了某个视频的处理任务，如果线程处理过程中挂掉了，该任务的状态将会一直是处理中，其它线程将无法处理，这个问题需要用补偿机制。

单独启动一个任务找到待处理任务表中超过执行期限但仍在处理中的任务，将任务的状态改为执行失败。

任务执行期限是处理一个处理的最大时长，比如视频处理任务的最大时长是30分钟，此时就查询大于30分钟还没有完成的任务，将任务状态改为执行失败。

### 2.4 基于Freemarker实现页面静态

#### 问题1: 为什么要用Freemarker静态化?如何做的？

传统的方式是用户请求到Tomcat服务器通过服务端渲染生成页面返回给浏览器，这种方式不适合高并发访问的场景。

静态化是通过模板引擎技术将一个动态网页提前生成html页面，将html网页放在nginx、apache等高性能服务器中，适合高并发的场景。

使用静态化除了满足高并发的需求外还需要注意的是当页面变化频率非常高的时候不适合静态化，因为页面变化频率高静态化就频繁，这样就会生成很多的静态页面，太多的静态页面是不方便去管理的。

我们项目使用Freemarker实现课程详情页面的静态化，Freemarker是一个成熟的开源的模板引擎，简单易用，功能强大。

使用流程：

1）使用Freemarker的标签编写课程详情页面的模板

2）调用接口获取模板上需要的模型数据

3）调用Freemarker的API生成静态页面。

4）生成的静态页面最终会上传到文件系统方便访问。

## 3 媒资管理模块

### 3.1 媒资管理模块的开发。

#### 问题1：媒资管理包括哪些功能？

媒资管理是对文档、视频等文件进行统一管理，包括：文件管理、视频上传、视频处理、文件审核、文件预览、文件分享、提供外部接口实现我的文件库功能。

对文件的管理我们是这么做的：

在数据库有一张文件表记录文件的信息，文件会存储到分布式文件系统MinIO中，提供普通文件上传和大文件上传的接口，普通文件上传接口主要是上传图片、pdf文件等文件，大文件上传接口主要是上传视频，上传视频我们使用断点续传的方式实现。

对视频进行转码处理，基于多线程加分布式任务调度的机制进行任务处理。

另外考虑媒资管理服务的通用性，提供统一的接口查询文件列表，实现了我的文件库功能，用户可以查询自己上传的文件的哪些，点击某个文件时请求分布式文件系统打开文件或下载文件。

### 2.4 基于MinIO分布式文件系统实现文件服务

#### 问题1：MinIO是什么？为什么用MinIO?

MinIO一个轻量级的分布式文件系统

MinIO有什么优势？

1) MinIO开源，使用简单，功能强大。

2）MinIO使用纠删码算法，只要不超过一半的节点坏掉整个文件系统就可以使用。

3）如果将坏的节点重新启动，自动恢复没有上传成功的文件。

我们在生产环境使用的时候会部署多个MinIO节点，具体有运维人员负责。

#### 问题2：怎么样使用MinIO存储图片？

1） app调用服务端接口上传图片，除了保存原图还自动生成缩略图（大、中、小）。

2）调用MinIO的接口将图片上传到MinIO。

3）如果要浏览图片会先请求到nginx，由nginx代理将请求转发到MinIO。

#### 问题3：怎么样构建这个独立的文件服务？

1）我们项目中有很多要上传文件的地方，比如上传图片、上传文档、上传视频等，所以我们要构建一个独立的文件服务负责上传、下载等功能，负责对文件进行统一管理。

2）创建单独的文件服务，提供以下接口：

上传接口

下载接口

我的文件库接口

删除文件接口

3）文件的存储和下载使用MinIO实现。

MinIO是一个分布式的文件系统，性能高，扩展强。

4）使用Nginx+MinIO组成一个文件服务器

通过访问Nginx，由nginx代理将请求转发到MinIO去浏览、下载文件。

### 2.5 断点续传功能的开发

#### 问题1：这个断点续传是怎么做的？

我们是基于分块上传的模式实现断点续传的需求，当文件上传一部分断网后前边已经上传过的不再上传。

1）前端对文件分块。

2）前端使用多线程一块一块上传，上传前给服务端发一个消息校验该分块是否上传，如果已上传则不再上传。

3）等所有分块上传完毕，服务端合并所有分块，校验文件的完整性。

因为分块全部上传到了服务器，服务器将所有分块按顺序进行合并，就是写每个分块文件内容按顺序依次写入一个文件中。使用字节流去读写文件。

4）前端给服务传了一个md5值，服务端合并文件后计算合并后文件的md5是否和前端传的一样，如果一样则说文件完整，如果不一样说明可能由于网络丢包导致文件不完整，这时上传失败需要重新上传。

#### 问题2：一个文件上传一半不传了怎么办？

上传一个文件进行分块上传，上传一半不传了，之前上传到minio的分块要进行清理。

1、在数据库中有一张文件表记录minio中存储的文件信息。

2、文件开始上传时会写入文件表，状态为上传中，上传完成会更新状态为上传完成。

3、当一个文件传了一半不再上传了说明该文件没有上传完成，会有定时任务去查询文件表中的记录，如果文件未上传完成则删除minio中没有上传成功的文件目录。

### 2.6 使用任务调度加多线程处理视频

#### 问题1：具体是怎么做的？

1、上传视频成功后在数据库表写一条视频处理任务。

2、使用 xxl-job任务调度每隔5分钟去扫描任务表中的任务

3、拿到了视频处理任务，这时根据CPU的核数去启动多线程开始处理视频。

比如：CPU是8核心就启动8个线程去同时处理，因为视频处理非常耗费CPU，启动的线程多也没有用。

4、处理视频是通过Java程序调用ffmpeg工具进行处理，具体是通过ProcessBuilder类去调用ffmpeg工具.

ffmpeg工具有很多参数这是由流媒体程序员给我们，我们直接写到程序员去调用。

5、任务处理完成后删除任务中的任务，将任务写到历史表进行备案。

6、我们在处理视频的过程中保证了任务不重复执行，实现了任务幂等性处理。

## 4 认证授权

### 4.1 使用Oauth2+JWT实现单点登录。

#### 问题1：如何使用Oauth2+JWT实现单点登录？

1）系统是整合了Spring Security框架，同时整合了OAuth2协议以及JWT令牌。

2）所有用户从统一登录入口进行认证，使用的是OAuth2的密码模式进行认证，请求账号和密码到认证服务。

3）认证服务对账号和密码进行校验，校验成功颁发JWT令牌，响应给客户端。

4）客户端将JWT令牌存到客户端cookie.

5）客户端携带JWT令牌通过网关去访问各各微服务。

6）网关对JWT令牌的合法性进行校验，校验成功继续访问，否则拒绝。

7）请求到达了微服务，微服务根据jwt中的权限信息校验用户是否拥有某个接口的权限，如果有则继续访问，没有则拒绝。

#### 问题2：说说OAuth2协议？OAuth2协议是什么？

OAuth2是一个开放的认证协议

OAuth2包括授权码模式、密码模式、简单模式、客户端模式。

以授权码模式为例说明：

1）首先由用户授权同意客户端访问资源服务。

2）认证服务向客户端下发授权码。

3）客户端携带授权码访问认证服务申请令牌。

4）认证服务下发令牌。

5）客户端携带令牌访问资源服务中的资源。

#### 问题3：JWT令牌是安全的吗？

JWT令牌是安全的，它由三部分组成，第三部分对前两部分进行签名加密，如果别人修改了前两部分，再对前两部分进行加密得到的结果与原来第三部分的加密内容不一致从而判断出JWT被篡改。

JWT可以采用对称加密和非对称加密，对称加密是认证服务和资源服务使用相同的密钥，对称加密效率高，如果一旦密钥泄露可以伪造jwt令牌。

非对称加密是认证服务自己保留私钥，将公钥下发给受信任的客户端、资源服务，公钥和私钥是配对的，成对的公钥和私钥才可以正常加密和解密，非对称加密效率低但相比对称加密非对称加密更安全一些。

#### 问题4：jwt在客户端存储多长时间？

根据用户选择，可以存储30天，也可以关闭浏览立即删除。

#### 问题5：jwt令牌过期了怎么办？

两种方法：

第1：过期了肯定需要用户重新登录。

第2：如果要把用户体验作的更好那就需要对即将过期的令牌进行续期，续期的办法是：使用刷新令牌（下发jwt的同时也将刷新令牌下发了）请求认证服务重新生成一个新jwt令牌。

#### 问题6：如何集成微信扫码？

1）我们的系统先在微信开放平台注册账号，添加应用，微信审核后发一个应用 id和应用密钥。

2）在前端页面调用微信js，传入应用 id和应用密钥等参数，生成了登录二维码。

3）用户扫码授权同意我们的系统请求微信查询当前用户自己的信息。

4）微信通过重定向将授权码返回给我们的系统。

5）我们的系统携带授权码申请令牌。

6）微信下发令牌。

7）我们的系统携带令牌请求微信获取用户信息。

8）拿到用户的信息存储到我们系统的数据库。

9）此时用户在我们的系统就存在了，调用我们系统的认证接口颁发jwt令牌，最后认证成功。

#### 问题7: 如何集成SpringSecurity框架到你的系统？

1、创建独立的认证服务。

添加了两个依赖Spring Securityr和Oauth2

支持OAuth2协议认证，支持颁发JWT令牌。

2、重写了两个类

UserDetailsService、DaoAuthenticationProvider。

UserDetailsService：查询用户信息

DaoAuthenticationProvider： 判断用户是否存在，判断密码是否正确，

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231510605.png)

重写方法:

DaoAuthenticationProvider:  重写它的一个校验密码的方法，去掉的原因是因为项目的认证方式不仅有账号密码认证还有微信扫码认证、手机验证码认证，有些认证不需要校验密码，我们在统一的认证类中去写认证校验的逻辑。

UserDetailsService：自定义loadUserByUsername方法，在这个方法里边接收认证请求的参数（认证类型、账号、密码、验证码等信息）进行统一认证，认证异常就抛出异常，认证通过就生成用户的身份信息。

最后根据用户的身份信息生成jwt令牌，响应给客户端，客户端保存jwt令牌。

#### 问题8: 如何实现同一个用户只能在一个客户端登录?

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231510619.png)

1、u001用户在pc登录成功，将u001和jwt令牌的唯一标识记录到redis，jwt令牌的唯一标识是用md5对jwt令牌计算出一个摘要字符串。

2、u001用户携带jwt令牌访问微服务，在网关处判断jwt的合法性，如果合法继续从redis查询该u001及u001对应的令牌唯一标识，如果存在且令牌和redis中的一样则继续访问。

3、u001用户在app登录，生成新的令牌，同第一步，将令牌标识记录到redis，**注意**此时在app登录的u001挤掉了在pc上登录的u001。

4、此时如果u001用户再使用原来的jwt令牌来访问网关发现u001对应的令牌和它的不一样，提示该账号在其它地方登录，是否重新登录。

#### 问题9: 如何扩展springSecurity的用户身份信息？

SpringSecurity默认的用户身份信息实现了UserDetails接口，信息有限，我们项目中对存储在jwt令牌跌中的用户身份信息进行扩展，我们将用户的信息转成json格式存储在jwt中，比如有用户的昵称，头像等信息。

## 5 支付

### 5.1 对接微信和支付宝接口实现支付功能。

#### 问题1：如何对接微信和支付宝实现支付功能?

1）生成支付二维码。同时在数据库插入一条支付记录。

2）用户扫码调用微信、支付宝的下单接口，同时传给支付宝或微信支付记录号。

3）支付完成，支付宝或微信将支付结果通知给我们的其它的系统。同时我们还会主动去查询支付结果。

#### 问题2：如何避免重复支付？

我们在生成支付二维码时判断订单如果已支付将不再生成二维码。

用户在扫码支付时也会判断是否已支付，已支付将不再继续。

因为我们每次支付生成了一个支付记录号，将支付记录号传给第三方支付平台，为的是防止第三方支付平台的问题导致我们的订单无法支付，这样的话在技术上无法彻底避免重复支付。

除了上边的避免重复支付的方法外我们还有一个定时任务每天0点去查询上一天的支付记录，如果有重复的进行退款。

另外用户在生成二维码后提示用户不要重复支付。

#### 问题3：用户退款了怎么办？

调用退款接口。

### 5.2 基于RabbitMQ延迟队列处理未支付订单。

订单创建成功如果订单未支付我们会在30分钟后进行删除。这里采用RabbitMQ延迟队列去处理。

#### 问题1：具体怎么做的？

1）创建订单的同时向MQ发送一条消息给一个队列并设置消息的TTL（过期时间），比如：设置30分钟，由于该队列设置了死信交换机，30分钟后消息将投递到死信交换机。

2）当消息过期，消息发到了死信交换机，同时发给了死信队列（死信队列绑定了死信交换机）

3）程序监听了死信队列，收到了过期的订单。

4）程序收到消息判断如果订单未支付则取消订单。如果说已支付不用处理。

#### 问题3：如何保证RabbitMQ的消息可靠性? 

1、设置消息持久化

首先设置交换机支持持久化（定义交换机时设置持久化为true）

其次设置队列支持持久化（定义队列时设置持久化为true）

发送消息时设置消息要持久化

2、消费者收到消息处理完成要确认

设置 消费者确认模式为自动确认 acknowledge-mode=auto ，当程序处理正常没有异常会发送ack，抛出异常则发送nack

也可以设置为手动确认，在程序处理完成的代码处手动发送ack。

3、消费失败重试

消费失败后在消费者本地进行重试，达到最大重试次数会将失败消息投递到指定交换机，交换机绑定一个异常消息队列，程序监听这个队列收到异常消息后放在数据库中单独处理，或由人工处理。

#### 问题4：如何避免消息重复投递或重复消费？

重复投递的原因：等待超时后，需要重试。

避免重复投递：消息生产时，生产者发送的消息携带一个`Message ID`（全局唯一ID），

作为去重和幂等的依据，避免重复的消息进入队列

 

重复消费的原因：消费者接收消息后，作好消息幂等性处理，根据消息的ID记录消息的处理状态，如果已处理则不再处理。

### 2.9 通过Redis技术进行数据的缓存,提高访问速度

#### 问题1：项目使用redis缓存了哪些数据? 

redis缓存的是白名单接口（无需认证即可访问）所需要的数据，缓存了普通用户所要查询的数据（我的订单、我的选课），缓存热点数据（最新发布的课程信息、推荐课程信息等）。

每类信息有不同的缓存过期时间，为了避免缓存雪崩缓存时间加了随机数。

验证码  

30秒    字符串

课程发布信息 

7天   hash

课程视频信息

7天   hash

我的课程

3分钟   hash

我的订单

3分钟   hash

#### 问题2：如何保证Redis缓存一致性？

缓存一致性是数据库和缓存保持一致，当修改了数据库的信息也要同时更新缓存的数据和数据库保持一致。

去查询数据时先查询缓存，如果缓存有就返回，如果没有就查询数据库，如果查不到则缓存一个null字符串（过期时间设置的小一些），如果查询到了，缓存到redis具体的信息。

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231511929.png)

当修改数据时常用的方案是延迟双删除：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231510573.png)

1、先更新数据库，再删除缓存。

如果更新了数据库，删除缓存的操作失败了，此时查询数据的请求查到的数据仍然是旧数据。

2、先删除缓存，再更新数据库

如果删除了缓存更新在更新数据库的操作之前可能被其它线程写入旧数据，此时缓存中的数据仍然是旧数据。

3、延迟双删，先删除缓存、再更新数据库，再延迟一定的时间去删除缓存。

为什么要两次删除缓存，因为有可能第一次删除缓存后其它查询请求将旧数据存储到了缓存。

为什么要延迟一定的时间去删除缓存，为了给mysql主从同步的时间，如果立即删除缓存很可能其它请求读到的数据还是旧数据。

延迟的时间不好确定，延迟双删仍然可能导致脏数据。

结论：以上方案当存在高并发时都无法解决数据库和缓存强一致性的问题。

**如何做缓存一致性？**

**需要根据需求来定：**

**1、实现强一致性 需要使用分布式锁控制，修改数据和向缓存存储数据使用同一个分布式锁。**

**2、实现最终一致性，缓存数据要加过期时间，即使出现数据不致性当过期时间一到缓存失效又会从数据库查询最新的数据存入缓存。**

**3、对于实时性要求强的，要实现数据强一致性要尽量避免使用缓存，可以直接操作数据库。**

**使用工具对数据进行同步方案如下：**

**1、使用任务表加任务调度的方案进行同步。**

**2、使用Canal基于MySQL的binlog进行同步。**

#### 问题3：针对高并发是如何对缓存进行处理的？

高并发可能导致缓存击穿，使用分布式锁进行控制避免缓存击穿，通过分布式锁控制只有一个线程去查询数据库，查完数据库后存入缓存。

我们项目使用redisson实现分布锁。

redisson实现Lock接口，基于此接口使用，具体方法是获取锁调用lock()方法，用完释放锁调用unlock()。

当线程还没有执行完时会有看门狗对锁进行续期，保证线程在执行过程中不会让锁过期。

针对高并发的还可以通过限流技术去避免高并发对系统造成压力。

#### 问题4：什么是缓存穿透、缓存雪崩、缓存击穿？怎么解决？

1）缓存穿透：

去访问一个数据库不存在的数据无法将数据进行缓存，导致查询数据库，当并发较大就会对数据库造成压力。缓存穿透可以造成数据库瞬间压力过大，连接数等资源用完，最终数据库拒绝连接不可用。

解决的方法：

缓存一个null值。

使用布隆过滤器。

2）缓存雪崩：

缓存中大量key失效后当高并发到来时导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用。

造成缓存雪崩问题的原因是是大量key拥有了相同的过期时间。

解决办法：

使用同步锁控制

对同一类型信息的key设置不同的过期时间，比如：使用固定数+随机数作为过期时间。

3）缓存击穿

大量并发访问同一个热点数据，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。

解决办法：

使用同步锁控制

设置key永不过期

## 6 搜索

### 6.1 使用Elasticsearch实现课程搜索功能。

#### 问题1：你们数据量很大吗？为啥使用Elasticsearch？

主要是考虑我们要实现全文检索的效果所以使用Elasticsearch，全文检索的方式去搜索数据性能很高，它基于倒排索引表。正排索引是从文章中找词，倒排索引是根据词找文章，性能高。词是在索引库存储的。输入一个关键字从索引库中找词，找到词之后就找到了文章，整体性能高。

我们网站的数据量不大，项目架构时架构师决定使用Elasticsearch。

#### 问题2：怎么使用Elasticsearch开发搜索模块？

1）首先创建索引（相当于mysql的表），将课程信息添加到索引库，对课程信息进行分词，存储到索引库。

2）开发一个搜索服务，编写一个搜索接口，调用Elasticsearch的api根据关键字搜索。

#### 问题3：如何保证索引同步？

我们项目是使用本地任务表加xxl-job任务调度进行索引同步，具体的作法如下：

1）添加或修改或删除课程的同时向任务表插入一条记录，这条记录就记录了是添加还是修改还是删除了哪个课程。

2）任务调度定时扫描任务表，根据任务表的内容对课程信息进行同步，如果添加了课程将课程添加到索引库，如果修改了课程就修改索引库的课程，如果是删除了课程将课程信息从索引库删除。

如果对于实时要求很高的场景可以使用Canal将MySQL的数据同步到索引 。

实时不高可以使用任务调度、Logstash、消息队列的方式。

详细如下：

MQ：向mysql写数据的时候向mq写入消息，搜索服务监听MQ，收到消息后写入索引。使用MQ的优势是代码解耦，但是需要处理消息可靠性的问题有一定的技术成本，做到消息可靠性需要做到生产者投递成功、消息持久化以及消费者消费成功三个方面，另外还要做好消息幂等性问题。

Logstash： 开源实时日志分析平台 ELK包括Elasticsearch、Kibana、Logstash，Logstash负责收集、解析和转换日志信息，可以实现MySQL与Elasticsearch之间的数据同步。也可以实现解耦合并且是官方推荐，但需要增加学习与维护成本。

任务调度：向mysql写数据的时候记录修改记录，开启一个定时任务根据修改记录将数据同步到Elasticsearch。

## 7 电商

### 2.1 商品管理

#### 问题1: **SPU与SKU**是什么

**SPU = Standard Product Unit  （标准产品单位）**

- 概念 : SPU 是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。
- 通俗点讲，属性值、特性相同的货品就可以称为一个 SPU
- 例如：**华为P30 就是一个 SPU**

**SKU=stock keeping unit( 库存量单位)**

- SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位。
- SKU 是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。
- 在服装、鞋类商品中使用最多最普遍。
- 例如：**华为P30 红色 64G 就是一个 SKU**

#### 问题2: 最基础的表有哪些

tb_spu  表 （SPU表）

| 字段名称       | 字段含义     | 字段类型 | 字段长度 | 备注 |
| -------------- | ------------ | -------- | -------- | ---- |
| id             | 主键         | VARCHAR  |          |      |
| sn             | 货号         | VARCHAR  |          |      |
| name           | SPU名        | VARCHAR  |          |      |
| caption        | 副标题       | VARCHAR  |          |      |
| brand_id       | 品牌ID       | INT      |          |      |
| category1_id   | 一级分类     | INT      |          |      |
| category2_id   | 二级分类     | INT      |          |      |
| category3_id   | 三级分类     | INT      |          |      |
| template_id    | 模板ID       | INT      |          |      |
| freight_id     | 运费模板id   | INT      |          |      |
| image          | 图片         | VARCHAR  |          |      |
| images         | 图片列表     | VARCHAR  |          |      |
| sale_service   | 售后服务     | VARCHAR  |          |      |
| introduction   | 介绍         | TEXT     |          |      |
| spec_items     | 规格列表     | VARCHAR  |          |      |
| para_items     | 参数列表     | VARCHAR  |          |      |
| sale_num       | 销量         | INT      |          |      |
| comment_num    | 评论数       | INT      |          |      |
| is_marketable  | 是否上架     | CHAR     |          |      |
| is_enable_spec | 是否启用规格 | CHAR     |          |      |
| is_delete      | 是否删除     | CHAR     |          |      |
| status         | 审核状态     | CHAR     |          |      |

tb_sku  表（SKU商品表）

| 字段名称      | 字段含义                        | 字段类型 | 字段长度 | 备注 |
| ------------- | ------------------------------- | -------- | -------- | ---- |
| id            | 商品id                          | VARCHAR  |          |      |
| sn            | 商品条码                        | VARCHAR  |          |      |
| name          | SKU名称                         | VARCHAR  |          |      |
| price         | 价格（分）                      | INT      |          |      |
| num           | 库存数量                        | INT      |          |      |
| alert_num     | 库存预警数量                    | INT      |          |      |
| image         | 商品图片                        | VARCHAR  |          |      |
| images        | 商品图片列表                    | VARCHAR  |          |      |
| weight        | 重量（克）                      | INT      |          |      |
| create_time   | 创建时间                        | DATETIME |          |      |
| update_time   | 更新时间                        | DATETIME |          |      |
| spu_id        | SPUID                           | BIGINT   |          |      |
| category_id   | 类目ID                          | INT      |          |      |
| category_name | 类目名称                        | VARCHAR  |          |      |
| brand_name    | 品牌名称                        | VARCHAR  |          |      |
| spec          | 规格                            | VARCHAR  |          |      |
| sale_num      | 销量                            | INT      |          |      |
| comment_num   | 评论数                          | INT      |          |      |
| status        | 商品状态 1-正常，2-下架，3-删除 | CHAR     |          |      |

 

### 2.2 购物车

#### 问题1:购物车流程是什么?

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231511031.png)

### 2.3  订单

#### 问题1:订单号生成规则有哪些?

订单号注意唯一性、安全性、尽量短等特点，生成方案常用的如下：

1、时间戳+随机数

年月日时分秒毫秒+随机数

2、高并发场景

年月日时分秒毫秒+随机数+redis自增序列

或

用户id+Redis的唯一数

为什么用redis自增序列?

 redis是单线程的，可以使用incr命令，每次都加一，这样次取得数字就是唯一的

3、订单号中加上业务标识

订单号加上业务标识方便客服，比如：第10位是业务类型，第11位是用户类型等。

4、雪花算法

雪花算法是推特内部使用的分布式环境下的唯一ID生成算法，它基于时间戳生成，保证有序递增，加以入计算机硬件等元素，可以满足高并发环境下ID不重复。

#### 问题2:最基本的数据表有哪些？

订单表

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231511255.png)

订单商品表

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231511362.png)

订单物流表

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231510348.png)

#### 问题3: 如何下单？

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231510401.png)

先请求订单创建订单。

远程调用商品服务减库存

使用Seata控制分布式事务，实现强一致性或弱一致性处理

#### 问题4：如何取消订单?

接上一个问题，程序收到延迟队列发的订单，如果订单未支付要取消订单，

取消订单需要在订单服务更新订单状态为取消，同时还要加回库存，这里存在分布式事务，因为加回库存与扣减库存不同，加回库存一定能成功，所以分布式事务采用最终一致性。

流程如下：

1、更新订单的状态为取消，同时向本地消息表写一条取消订单的记录。这里用本地事务控制。

2、使用任务调度扫描本地消息表，请求商品服务加回库存。

#### 问题5 防止超卖

什么是超卖？假如只剩下一个库存，却被多个订单买到了，简单理解就是库存不够了还能正常下单。

 

方案1：

业务上使用预售防止超卖现象发生。

方案2：

使用数据库行级锁，更新数据库库存，谁更新成功谁拿到库存，同时只能有一个线程更新成功。

方案3：

使用分布式锁，同时只能有一个线程来下单。

分布式锁可以使用redisson实现

## 8 其它

### 8.1 项目管理相关

#### 问题1：项目开发过程是什么？

启动阶段 项目的可行性分析、立项、招投标、合同签署。 计划阶段 范围定义、进度安排、资源计划、成本估计、质量保证计划、风险计划、实施计划等。 实施及控制阶段 项目实施、进度控制、费用控制、质量控制、变更控制等。 结束阶段 范围确认、质量验收、费用结算与审计、项目资料验收、项目交接与清算、项目审计与评估、项目总结等。

#### 问题2：bug处理流程是什么？

开发结束由测试人员对软件进行测试，通常使用项目管理软件管理缺陷，流程如下：

![img](https://raw.githubusercontent.com/raosirui/Picture/main/markdown/202411231510495.png)

#### 问题3: 前后端联调有bug怎么处理？

首先看接口文档，接口的url、请求及响应的数据格式，再进行接口bug重现对照接口文档看是哪的问题。

如果是后端的问题我就根据接口文档去修改代码，如果是前端的问题我会与前端工程师沟通确认。

#### 问题4: 开发一个接口流程是什么？

在前后端分离开发中通常由后端程序员设计接口，完成后需要编写接口文档，最后将文档交给前端工程师，前端和后端工程师参考文档进行开发。

在测试接口时各自完成单元测试，约定开发一部分模块后进行前后端联调。

遇到接口问题先查接口文档，再对照bug，确定问题进行修复。

#### 问题5: 如何设计一个接口？

根据产品原型中用户的操作去设计接口，比如：查询接口、新增接口，删除接口等。

首先确定接口协议：

通常协议采用HTTP，查询类接口通常为get或post，查询条件较少的使用get，较多的使用post。

还要确定content-type，参数以什么数据格式提交，结果以什么数据格式响应。

一般情况没有特殊情况结果以json 格式响应。

然后分析请求参数的格式，是key/value串还是json。

最后分析响应结果的格式，通过是json。

### 8.2 DevOps相关

#### 问题1:你部署过项目吗？

在我们公司的开发环境有一套持续集成的环境 ，使用的是jenkins软件实现的，生产环境由公司的运维人员负责。

我自己也有手动将微服务部署到Centos上的经历，先将项目打包，在centos上创建docker镜像，启动容器。

#### 问题2:什么是DevOps? 什么是CI/CD?

DevOps是开发和运维的组合，是一种思想理念，目标是提高软件开发、测试、运维、运营等各部门的沟通与协作质量。强调通过自动化的方法去管理软件变更、软件集成，使软件从构建到测试、发布更加快捷、可靠，最终按时交付软件。

CI/CD是一种DevOps的实现方案，含了一个 CI 和两个 CD，CI表示持续集成，CD包含持续交付和持续部署，三者具有前后依赖关系。

持续集成：是将开发分支合并到主分支，将所有模块的代码进行集成、编译、构建、自动化测试。

持续交付是将集成后的代码部署到类生产环境(预发布)，交付给测试、产品验收。

持续部署是在持续交付的基础上由开发人员或运维人员通过自动化的工具定期向生产环境部署稳定的构建版本。

#### 问题3:项目如何打包？

我们的项目是SpringBoot的工程，添加一个SpringBoot的maven打包插件进行打包。

插件添加完成在父工程对模块进行聚合，运行mvn package即可打包。

#### 问题4:项目如何部署？

我们公司是通过一套持续集成的环境的部署到测试以及生产环境的，使用的是jenkins和k8s。

自动化的环境是由jenkins自动从git拉取代码，进行编译、打包、创建镜像、上传到docker仓库，然后远程调用服务器进行容器部署。

我也有手动部署项目的经历，先将项目打包，在centos上创建docker镜像，启动容器。

大家学习中如果碰到困难，欢迎加入[黑马智学伴侣](https://mx67xggunk5.feishu.cn/docx/Qa3MdpPObosWtZxyIu9c1im0nVc) 提问交流，这里有学习交流群，老师、同学在线答疑。还有独享的企业级项目，避免与人撞车。
